//HELBREATH RETURN HGServer Sources

#pragma warning(disable : 4996)

#include "Game.h"

extern void PutLogList(char * cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];
extern void PutLogFileList(char * cStr);
extern void PutCrusadeLogFileList(char * cStr, BOOL bIsSave = TRUE);
extern void PutEkAndPkLogFileList(char * cStr);
extern void PutLogEventFileList(char * cStr);
extern void PutDebugMsg(char * cStr);	
extern void PutHackLog(char * cStr);
extern void PutFenixLogList(char * cStr);

int m_iHappyHour = 1;
bool bHappyHour = false;

//FurDay by prlucas
int m_iFuryDay = 1;
bool bFuryDay = false;

extern FILE * pLogFile;
extern HWND	G_hWnd;


int _tmp_iMoveLocX[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 1
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1},
	//3
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,19,18,17,16,
	 15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,-1},
	//5
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1},
	//7
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//8
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1}
};

int _tmp_iMoveLocY[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//1
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1},
	//3
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//5
	{15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//7
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 8
	{15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1}
};

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern BOOL	G_bIsThread;
extern void ThreadProc(void *ch);


CGame::CGame(HWND hWnd)
{
 int i, x;
	
	m_bIsGameStarted = FALSE;
	m_hWnd           = hWnd;
	m_pMainLogSock   = NULL;
	#ifdef DEF_RADMIN
	m_pRAdminSock	 = NULL;
	#endif
	m_pGateSock      = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;
	m_bIsWLServerAvailable  = FALSE;
	
	
	m_bAdminSecurity = TRUE;


	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;

	m_sForceRecallTime = 0 ;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{	m_pPortionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL;// Crafting
}
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	for (i = 0; i < DEF_MAXPARTYNUM; i++) 
	for (x = 0; x < DEF_MAXPARTYMEMBERS; x++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		m_stPartyInfo[i].iIndex[x] = 0;
	}
	m_bAnunciosActivo = TRUE;
	bVarRecall = FALSE;
	m_dwHeldenianFTime = -1; 
	bHeldenianFight = FALSE;
	bHFlag = FALSE;
	m_bIsHeldenianMode = FALSE;
    m_bHeldenianInitiated = FALSE; 
    m_bIsHeldenianMode = FALSE; 
    m_bHeldenianRunning = FALSE; 
    m_cHeldenianWinner = NULL; 
    m_sLastHeldenianWinner = 0; 
    m_cHeldenianModeType = 0; 
    m_iGodHMapIndex = -1;
    m_iBTFieldMapIndex = -1;
    m_iHeldenianAresdenLeftTower = 0; 
    m_iHeldenianElvineLeftTower = 0; 
    m_iHeldenianAresdenDead = 0; 
    m_iHeldenianElvineDead = 0;
    m_bClear = FALSE;
	m_bHeldSafe = FALSE;
	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;
	m_sAutoClearCount = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;

	m_iAutoRebootingCount = 0;

	m_pGold = NULL ;
	m_iAddUser = 0;
	//2009-03-18
	m_iExtHGServerPort = 0;
	m_dwHeldenianSafeTime = 0;
	m_iHeldenianAresdenFlags = 0;
	m_iHeldenianElvineFlags = 0;
	var_89C = 0;
	var_8A0 = 0;
	var_88C = 0;
	m_dwHeldenianFinishTime = 0;
	m_dwHeldenianGUID = 0;
	m_dwHeldenianWarStartTime = 0;
	m_dwHeldenianWarTime = 0;
	m_dwHeldenianWTime = 0;
	m_dwThunderTime = 0;
	m_iWorldLogServerPort = 0;
	m_iWorldMaxUser = 0;
	m_dwExitProcessTime = 0;
	m_dwCityWTime = 0;
	m_bCityWar = NULL;
	m_iCityWarElvineDead = 0;
	m_iCityWarAresdenDead = 0;
	m_cCityWarWinner = 0;
	m_cPvpEvent = 0;

	//New Addon - Setting.cfg
	m_iEnemyKillAdjust = 0;
	m_iGoldProbability = 0;
	m_iGoldProbMin = 0;
	m_iGoldProbMax = 0;
	m_sCharStatLimit = 0;
	m_sCharSkillLimit = 0;
	m_cRepDropModifier = 0;
	m_iPlayerMaxLevel = 0;
	m_bLogChatOption = 0;
	m_iPrimaryDropRate = 0;
	m_iSecondaryDropRate = 0;
	m_sMedidorExp79 = 1;
	m_sMedidorExp139 = 1;
	m_sMedidorExp159 = 1;
	m_sMedidorExp179 = 1;
	m_sMedidorExp249 = 1;
	m_sMedidorExp250 = 1;
	m_sSlateSuccessRate = 0;
	m_bPartyEkPerLevel140 = FALSE;
	m_iPartyEk140_1 = 0;
	m_iPartyEk140_2 = 0;
	m_iPartyEk140_3 = 0;
	m_bPartyEkPerLevel180 = FALSE;
	m_iPartyEk180_1 = 0;
	m_iPartyEk180_2 = 0;
	m_iPartyEk180_3 = 0;
	m_b100skill = FALSE;

	//ZeroEoyPnk - RushNet
	m_bIsRushNetMode = FALSE;
	RushWinner = 0;


	//ZerEoyPnk - News Addons
	for (i = 0; i < 2; i++)
	{
		dest_dx_portal[i] = 0;
		ini_dx_portal[i] = 0;
		dest_dy_portal[i] = 0;
		ini_dy_portal[i] = 0;
		LevelLimit_portal[i] = 0;
		MaxPlayer_portal[i] = 0;
		PortalPlayers[i] = 0;
		PortalAbility[i] = FALSE;
		dw_TimeOpenPortal[i] = NULL;
		dw_TimePortal[i] = NULL;
	}
	
	LastPortal = 0;
	
	//ZeroEoyPnk - RushNet
	m_bIsRushNetMode = FALSE;
	RushPrice = FALSE;
	EndRushPrice_Min = NULL;
	EndRushPrice_Hour = NULL;
	RushWinner = 0;

	DeathMatch = FALSE;
	for (i = 0; i < 15; i++)
		iDGtop[i] = -1;

	// 2002-09-09 #1
	m_bReceivedItemList = false;
	ServerActivated = FALSE;
}

CGame::~CGame()
{

}

BOOL CGame::bAccept(class XSocket * pXSock)
{
 register int i;
 class XSocket * pTmpSock;
 char  cTxt[120];
 int x;
 short sTotalConnection;
 sTotalConnection = 0;
 
	if ((m_bIsGateSockAvailable == FALSE) || (m_bIsLogSockAvailable == FALSE)   || 
		(m_bIsItemAvailable == FALSE)     || (m_bIsNpcAvailable == FALSE)       || 
		(m_bIsMagicAvailable == FALSE)    || (m_bIsSkillAvailable == FALSE)     || 
		(m_bIsPortionAvailable == FALSE)  || (m_bOnExitProcess == TRUE)         || 
		(m_bIsQuestAvailable == FALSE)    || (m_bIsBuildItemAvailable == FALSE) ||
		(m_bIsGameStarted == FALSE)
#ifdef DEF_DEFENCEHACKING
		// 2002-12-8 World server 보안 설정을 위해 
		|| (m_bIsWLServerAvailable == FALSE)
#endif 
		) 
		goto CLOSE_ANYWAY;

	// 비어있는 배열을 찾는다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] == NULL) {
		
		m_pClientList[i] = new class CClient(m_hWnd);
		// 클라이언트 인덱스 리스트에 기록 
		bAddClientShortCut(i);
		// 접속시간 기록 - 장시간 응답없는 클라이언트를 제거하기 위함이다. 
		m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = 
			m_pClientList[i]->m_dwHPTime = 
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime = 
					m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();
		
		pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i); 
	
		ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
		m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);
		if ((memcmp(m_pClientList[i]->m_cIPaddress, "218.212.16", 10) == 0)||(memcmp(m_pClientList[i]->m_cIPaddress, "67.228.85", 9) == 0)||(memcmp(m_pClientList[i]->m_cIPaddress, "218.111.12", 10) == 0)||(memcmp(m_pClientList[i]->m_cIPaddress, "69.84.41", 8) == 0)){
			delete m_pClientList[i];
			m_pClientList[i] = NULL;
			return FALSE;
		}
		m_iTotalClients++;

		for (x = 0; x < DEF_MAXCLIENTS; x++)
		if (m_pClientList[x] != NULL) {
			if ((strlen(m_pClientList[x]->m_cIPaddress) == 0)||(strlen(m_pClientList[i]->m_cIPaddress)== 0)){
				delete m_pClientList[i];
				m_pClientList[i] = NULL;
				m_iTotalClients--;
				return FALSE;
			}
			if(memcmp(m_pClientList[x]->m_cIPaddress, m_pClientList[i]->m_cIPaddress, 15) == 0) {
				sTotalConnection++;
				if (sTotalConnection == 20) {
					delete m_pClientList[i];
					m_pClientList[i] = NULL;
					m_iTotalClients--;
					return FALSE;
				}
			}
		}

		if (m_iTotalClients > m_iMaxClients) { 
			m_iMaxClients = m_iTotalClients;
			GetLocalTime(&m_MaxUserSysTime);
			wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
		}

		return TRUE;
	}

CLOSE_ANYWAY:;

	// 비어있는 배열이 없어 접속을 받을 수 없다. Accept하자 마자 끊는다.
	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;

	return FALSE;
}

void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
 register int i;
 char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120], cCheckServer, cCheckRecive, cLog[100];
 BOOL bIsObserverMode;
#ifdef DEF_V383
 cCheckServer = (char)0x49;
 cCheckRecive = (char)cKey;
#endif
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

	//Check Hack
#ifdef DEF_V383
	if (cCheckRecive != cCheckServer) {
		wsprintf(cLog, "(X)Cliente Distinto al Original !!! IP(%s)", m_pClientList[iClientH]->m_cIPaddress);
		PutHackLog(cLog);
		DeleteClient(iClientH, TRUE, TRUE);
		m_iTotalClients--;
		return;
	}
#endif

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;
	
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);
	
	bIsObserverMode = (BOOL)*cp;
	cp++;

	// 중복된 계정을 갖고있는 캐릭터를 삭제한다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
		// 패스워드가 일치하면 뚫고 들어갈 수 있다. 그러나 다르면 접속 불가. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			// 패스워드가 일치한다. 
			wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	// 3번째 FALSE:로그 서버로 카운팅 다운은 하지 말라는 메시지 
		}
		else {
			// v1.4 계정 정보를 입력해야 로그인 서버로 통보가 가능하다.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			wsprintf(G_cTxt, "(!) Player(%s) (%s)(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cAccountPassword); 
			PutLogList(G_cTxt);
			// 패스워드가 일치하지 않는다.  접속 불가. 
			DeleteClient(iClientH, FALSE, FALSE, FALSE);
			return;
		}
	}	
	
	// 중복된 이름을 갖고 있는 캐릭터가 있다면 마찬가지로 삭제 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		// 패스워드가 일치하면 뚫고 들어갈 수 있다. 그러나 다르면 접속 불가. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	
		}
		else {
			// v1.4 계정 정보를 입력해야 로그인 서버로 통보가 가능하다.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			wsprintf(G_cTxt, "(!) Player(%s) (%s)(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cAccountPassword); 
			PutLogList(G_cTxt);
			// 패스워드가 일치하지 않는다.  접속 불가. 
			DeleteClient(iClientH, FALSE, FALSE);
			return;
		}
	}
	/*
    if (m_pClientList[iClientH]->m_bIsOnlyClientAvailable == FALSE) {
		wsprintf(G_cTxt, "Account(%s), Char(%s), Pass(%s) Entro con un client ajeno", cAccountName, cCharName, cAccountPassword);
		PutLogList(G_cTxt);
		PutHackLog(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	else {*/
	// 정보 입력  
	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
	
	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;
		
	// Log Server로 데이터 요청 메시지를 보낸다. 
	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
	//}
}

void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey, BOOL bIsNoNameCheck)
{
 char  * pBuffer = NULL;
 short * sp;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cPlayerName[11], cTxt[120];
 int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet, iMapSide, iTmpMapSide, iStats;
 SYSTEMTIME SysTime;
 BOOL bFlag;
 char cPrice;
 short sSummonPoints;

if (	(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && 
					(m_pClientList[iClientH]->m_iHP > 0) && 
					(m_pClientList[iClientH]->m_iLevel >= 15) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DESTINY, NULL, NULL, NULL, NULL);
	
			int v_LocationFixed = 0;
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) v_LocationFixed = 1;
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) v_LocationFixed = 2;
			else v_LocationFixed = 0;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATUS_FIXED, m_pClientList[iClientH]->m_cSex, v_LocationFixed, NULL, NULL, NULL, NULL);

	if (m_iHappyHour == 2)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HAPPYHOURSTAR, NULL, NULL, NULL, NULL); 
	//FurDay by prlucas
	if (m_iFuryDay == 2)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FURYDAYSTAR, NULL, NULL, NULL, NULL); 
			
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->bPHackWPE == TRUE) {
		wsprintf(cTxt,"(X)Bump/RollBack Nombre del char (%s) ip(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress);
		PutHackLog(cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);
		// 최초 접속 데이터를 전송해 준다. 여기서 이름이 일치하는지 확인할 수도 있다.
	if (bIsNoNameCheck == FALSE) {
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		memcpy(cPlayerName, cp, 10);
        
		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy(cTxt, cPlayerName, 10);
		m_Misc.bDecode(cKey, cTxt);
		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		memcpy(cPlayerName, cTxt, 10);

		// 이름이 일치하는지 검사한다. 일치하지 않으면 삭제하고 귀환한다. 
		if ((memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0)) {
			wsprintf(cTxt, "(!) Player(%s) (%s)(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cAccountPassword); 
			PutLogList(cTxt);
			DeleteClient(iClientH, FALSE, TRUE);
			return;
		}
	}
	m_pClientList[iClientH]->bPHackWPE = TRUE; 

	// 캐릭터의 신상정보를 전송한다.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
//6
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;
//10
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;
//14
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;
//18
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;
//22
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;
//26
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;
//30
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;
//34
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;
//38
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;
//42
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;
//46
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;
//50
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;
//54
	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +  
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma); 

	m_pClientList[iClientH]->m_iLU_Pool =  m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70);
	
	wp = (WORD *)cp; 
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;
	//56
	//*cp = m_pClientList[iClientH]->m_cVar;
	*cp = 0;
	cp++;
//57
	*cp = 0;
	cp++;
//58
	*cp = 0;
	cp++;
//59
	*cp = 0;
	cp++;
//60
	*cp = 0;
	cp++;
//61
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;
//65
	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;
//69
	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;
//73
	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;
//77
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;
//87
	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;
//107
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;
//111
	// v1.4311
	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;
//112
	// v1.4311-3 추가 사투장예약 여부를 클라이언트에 보낸다.
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;
//116

	ip   = (int *)cp;
	*ip  = _UpdateVersion;
	cp  += 4;

	// 메시지 전송 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 120); // 118
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete []pBuffer;
		return;
	}

	// 캐릭터의 아이템 정보를 전송한다. 
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	// 먼저 소지하고 있는 아이템 
	// 아이템의 총 갯수 
	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
		iTotalItemA++;

	// v2.05 아이템 리스트를 중간 공백이 없게 만든다.
	bFlag = FALSE;
	while (bFlag == FALSE) {
		bFlag = TRUE;
		for (i = 0; i < DEF_MAXITEMS-1; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] == NULL) && (m_pClientList[iClientH]->m_pItemList[i+1] != NULL)) {
			m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemList[i+1];
			m_pClientList[iClientH]->m_pItemList[i+1] = NULL;
			//아이템 위치도 변경 
			m_pClientList[iClientH]->m_ItemPosList[i].x = m_pClientList[iClientH]->m_ItemPosList[i+1].x;
			m_pClientList[iClientH]->m_ItemPosList[i].y = m_pClientList[iClientH]->m_ItemPosList[i+1].y;
			bFlag = FALSE;
		}
	}

	// 아이템 인덱스가 바뀌었으니 다시 계산.
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	CalcTotalItemEffect(iClientH, -1, FALSE);
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	*cp = iTotalItemA;
	cp++;
	
	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			// 에러 방지용 코드이다. 문제가 있는 캐릭터의 데이터를 분석할것. 왜 널일까?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete []pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
#ifdef DEF_V383
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3; // v1.41 
		cp++;
#endif
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
	}

	// 다음 보관중인 아이템 
	// 아이템의 총 갯수 
	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
		iTotalItemB++;
	
	*cp = iTotalItemB;
	cp++;
	
	for (i = 0; i < iTotalItemB; i++) {
		// ### 의심스러운 ERROR POINT
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			// 에러 방지용 코드이다. 문제가 있는 캐릭터의 데이터를 분석할것. 왜 널일까?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete []pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
#ifdef DEF_V383
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3; 
		cp++;
#endif
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}
	
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	// 아이템 정보 전송 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*45 + iTotalItemB*44 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete []pBuffer;
		return;
	}

	//v2.19 2002-11-14 전면전 승리한쪽으 가격을 10프로 싸게 해준다.
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		cPrice = 0;

		if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			cPrice = -10;
	}
	//2009-03-21
	char cLost = 0; 
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		switch(m_sLastHeldenianWinner){
		case 1:
			cLost = 2;
			break;
		case 2:
			cLost = 1;
			break;
		}
		if(cLost == m_pClientList[iClientH]->m_cSide)
			cPrice += 100;
	}
	// 맵데이터를 전송한다.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
//6	
	// 플레이어의 위치를 확정한다. v1.41 관람자 모드라면 그위치 그대로 놓는다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		 bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
//8
	// 전송할 맵 데이터의 기준위치. 플레이어는 기준위치 (x, y)로부터 (x+14, y+12)에 위치한다.
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;
//10
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;
//12
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;
//14
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;
//16
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;
//18
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;
//20
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
//22
	ip  = (int *)cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;
//26
	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;
	//30
	// (!) 플레이어가 위치하는 맵이름을 기록한다.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;
//40
	// 명칭상의 맵 이름을 입력한다. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;
//50
	// 주야간 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = 1;
	else *cp = m_cDayOrNight;
	cp++;
//51
	// 기상 상태 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;
//52
	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;
//56
	// @@@ 플레이어를 맵상에 최초로 위치시킨다.
	
	// v1.41 여기서 관람자 모드라면 위치시키지 않는다. 
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH, 
			                                                       DEF_OWNERTYPE_PLAYER, 
																   m_pClientList[iClientH]->m_sX, 
								  								   m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;
//57
	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;
//61
	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	
	// 2002-11-14 물가 정보 추가
#ifdef DEF_V219
	*cp = cPrice;
	cp += 1;
#else 
	*cp = 0;
	cp += 1;
#endif

	// 맵의 정보를 추가한다. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );

	// 메시지 전송 
//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+3); // v2.23 // v1.41
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, iSize + 66); // v2.23 // v2.183 // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete []pBuffer;
		return;
	}

	if(pBuffer != NULL) delete []pBuffer;

	// 다른 클라이언트들에게 새 플레이어 접속을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	// 2002-11-15 클라이언트의 Side, OnTown, OnShop 정보를 설정한다.
	iSetSide(iClientH);

	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
	// 기존의 레벨이 높은 캐릭터가 민간인 모드로 설정 되어 있으면 
	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == TRUE ) ) 
		SetNoHunterMode(iClientH) ;



	// 플레이어가 다른 맵에 들어갔다. 만약 적국이라면 시간을 설정한다.
	// v2.13 운영자는 강콜되지 않는다.
	// 아레스덴이면 
	if (( DEF_ARESDEN == m_pClientList[iClientH]->m_cSide ) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	}
	// v2.13 운영자는 강콜되지 않는다. 
	else if (( DEF_ELVINE == m_pClientList[iClientH]->m_cSide) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	// v2.15 전면전시 중립이 마을로 들어가면 바로 강콜 
	} else if (( DEF_NETURAL == m_pClientList[iClientH]->m_cSide) && 
		(m_bIsCrusadeMode == TRUE) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) 
		|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ; 
	}

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) {
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
	}
	// v2.181 2002-10-24
	// 적 농경지나 건물에 들어가면 강콜 된다. 
	iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	if (iMapSide >= 3) iTmpMapSide = iMapSide - 2 ;
		else iTmpMapSide = iMapSide ;

	m_pClientList[iClientH]->m_bIsInBuilding = FALSE ;
	// 적마을이면 
	if  ((m_pClientList[iClientH]->m_cSide != iTmpMapSide) && (iMapSide != 0) ) {

		// 건물 안이면 
		if ( (iMapSide <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
			&& (m_pClientList[iClientH]->m_cSide != DEF_NETURAL) )
		{
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ;
			m_pClientList[iClientH]->m_bIsInBuilding = TRUE ;
		}
	}

	// 다른 서버에 있는 사투장으로 입장하는 경우 
	// v1.4311-3 추가 사투장에 입장하면 강콜타임을 시작한다.
	// v2.13 운영자는 강콜되지 않는다. 
	// v2.17 길드전 모드에서는 사투장에서 강콜되지 않는다.
#ifndef DEF_GUILDWARMODE
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
		     (m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		// 운영자가 강콜모드를 설정하지 않는경우에만 강콜타임이 설정된다.
				
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// 남아있을 수 있는 잔존 시간을 설정해 준다. 
		// 0 시부터 2시간 간격으로 계산된다 즉 0시에 입장하면 2시간동안 남아 있을수 있다.
		// 서버간의 시간 차이를 고려하여 여유시간 2분 있다. 즉 2시간 되기 2분전부터 리콜된다.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20; 
	}
#endif 	
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) || 
		   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		      && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; 
		 // 강콜시간이 5분 보다 길면 
		} else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20*5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ;  // 5분
		}
	}
	else {
	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}

	// v2.17 2002-7-15 강콜 시간을 사용자에게 보여준다.
	if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_bIsCrusadeMode == FALSE)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RECALLTIMELEFT,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt) ;
	}

	// 추가로 보내줘야 할 정보를 보낸다. v1.1
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	// v1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	// V1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}

	// Crusade 현재 크루세이드 모드이고 플레이어의 CrusadeGUID가 0 혹은 현재와 다르다면 처음 할당되는 것이다. 크루세이드 역할 초기화.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// 크루세이드모드이고 플레이어의 GUID가 0이란 것은 처음 크루세이드 모드에 들어왔다는 의미. 역할 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// 크루세이드모드이고 플레이어의 GUID가 현재 크루세이드 아이디와 다르다는 것은 저번에 벌어졌던 크루세이드의 결과이다.
			// 이런 경우 전공에 따른 포상을 할 수 없다. 최소한 크루세이드 모드가 종료된 다음 다음 전면전이 시작되기 전에 접속을 해야 포상을 얻을 수 있다.
			// 이전에 할당되었던 역할, 건설 포인트, 전쟁 공헌도 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		// 크루세이드 모드가 아닌 경우 역할과 공헌 포인트만 초기화. 전쟁 공헌도는 잠시후에 계산되어서 포상된다.
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}
		else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}
		if (m_bIsHeldenianMode == TRUE) { 
			sSummonPoints = m_pClientList[iClientH]->m_iCharisma*300; 
			if (sSummonPoints > 12000) sSummonPoints = 12000; 
			if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) { 
				m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID; 
				m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints; 
			} 
			else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) { 
					m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints; 
					m_pClientList[iClientH]->m_iWarContribution = 0; 
					m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID; 
				} 
				if (m_bIsHeldenianMode == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL, NULL); 
				if (bHeldenianFight == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL, NULL); 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL); 
					bUpdateHeldenianStatus(-1); 
 				} 
    // Heldenian
	if ((m_bIsHeldenianMode == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) {
    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
	}

	// Crusade
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);

	// v2.15
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	AutoSkill(iClientH);
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsGateAvailable == TRUE) {
		for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalDynamicGate; i++) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateX1,
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateY1, 0, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);			
		}
	}
	if (m_bIsApocalypseMode == TRUE) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL, NULL);
	}
	if ((m_bIsApocalypseMode == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap == TRUE)&&(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		RequestTeleportHandler(iClientH, "2   ", "druncncity", -1, -1);
	}
    SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_HELDENIANPRICES, (char)m_sLastHeldenianWinner, m_pClientList[iClientH]->m_cSide, NULL, NULL);

	if ((m_bIsHeldenianMode == FALSE) && (iCheckLugar(iClientH) == 3)){
		RequestTeleportHandler(iClientH, "1   ");
	}

	if (m_bCityWar == TRUE)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CITYWARBEGIN, m_iCityWarAresdenDead, m_iCityWarElvineDead, NULL, NULL);

	if (DeathMatch == TRUE)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DEATHMACHSTAR, NULL, NULL, NULL, NULL);

	if (m_bStones)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STONESON, NULL, NULL, NULL, NULL);
	else{	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone1", 10) == 0)
				RequestTeleportHandler(iClientH, "1");
	}
	if (bAllVsAll)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ALLVSALLON, 2, NULL, NULL, NULL);
	else if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone1", 10) == 0)
				RequestTeleportHandler(iClientH, "1");
}



void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{
 int i, iExH;
 char * cp, cData[120], cTmpMap[30];
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->bPHackWPE == TRUE) {
		m_pClientList[iClientH]->bPHackWPE = FALSE;
	}
	 
	/*if ((bAllVsAll) && (strcmp(m_pClientList[iClientH]->m_cMapName, "fightzone1") == 0))
	{	iTotalAVACurrentKills++;
		CheckAllVsAllWinner();
	}*/

	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}
	
		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		if ((m_pClientList[iClientH]->m_iAllocatedFish != NULL) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL)) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;
		
		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
		
		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
			m_pClientList[i]->m_iWhisperPlayerIndex = -1;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
		}

		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_DISCONNECT;
		cp++;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		bStockMsgToGateServer(cData, 11);
			
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
		          	                                                 m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY);

		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
	}
	
	if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)) {
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
			
			strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;

			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			
			if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {

				if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN  ) {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 30*1;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04 10 mins
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04 10 mins
						}
					}
					if (strcmp(cTmpMap, "elvine") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 30*1 ; // 3 mins
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						 memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
				}
				else {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 30*1;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04 10 mins.
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04 10 mins.
						}
					}
					// v2.16 2002-5-31
					if (strcmp(cTmpMap, "aresden") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 30*1 ; // 3 mins
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						 memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
				}
			}
		}
		else if (bForceCloseConn == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
			
			ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 10*60;
		}
		
		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN )
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 10);
				else
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN )
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 10);
				else
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}
		
		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
		}
		else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	//	else bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
	}
	else {
		if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE) {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;
				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout); 
		//bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 7;
				cp += 2;
				wp = (WORD *)cp;
				*wp = NULL;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE); 
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
			goto DC_LOOPBREAK1;
		}
DC_LOOPBREAK1:;
		for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
		if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
		}
	}

		m_iTotalClients--;

	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = NULL;
	
	RemoveClientShortCut(iClientH);
}

void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
 int * ip, i, iRet, iShortCutIndex;
 char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200],  cData_Srt_Av[200];
 DWORD * dwp;
 WORD  * wp;
 short * sp, sRange, sX, sY;
 int   * ipStatus, iTemp, iTemp2, iTemp3, iDumm;
 BOOL    bOwnerSend, bFlag;
 char  cKey ;
 
	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	ipStatus = (int *)&iDumm;
	cKey = (char)(rand() % 255) +1;

	// All-Data
	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	// Short-Data
	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	// Short-Data-Additional-value
	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);
	
	// 메시지 전달 범위 설정 
	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		 sRange = 1;
	else sRange = 0;
	
	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		// 플레이어의 이벤트이다.
		if (m_pClientList[sOwnerH] == NULL) return;
		
		// 본인에게도 전송되는 메시지인가?
		switch (wMsgType) {
		case DEF_OBJECTNULLACTION:
		case DEF_OBJECTDAMAGE:
		case DEF_OBJECTDYING:
			bOwnerSend = TRUE;
			break;
		default:
			bOwnerSend = FALSE;
			break;
		}

		// 메시지의 종류에 따라서 형식에 달라진다. 
		// DEF_MSGTYPE_CONFIRM, DEF_MSGTYPE_REJECT, DEF_OBJECTNULLACTION와 다른 클라이언트의 인접영역에 있는 경우는 
				
		// 전체 메시지 형식 작성 
		wp  = (WORD *)cp_a;
		*wp = sOwnerH;			// ObjectID
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;
		// v1.4
		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;

		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pClientList[sOwnerH]->m_iStatus;
		cp_a += 4;
		
		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;
		

		if (wMsgType == DEF_OBJECTNULLACTION) {// v1.4
			if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				 *cp_a = 1; 
			else *cp_a = 0; 
		}
		else *cp_a = 0;
		cp_a++;

		// 부분 데이터 형식 작성 
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;			// ObjectID	(+30000)
		cp_s += 2;
				
		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;
		// 아래부분은 OBJECTDAMAGE일 경우에만 전송된다. 먹은 Damege의 크기와 공격받은 종류  
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		// 좌표정보는 죽는 동작에만 들어간다.
		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
	
		// 부분 데이터 추가 정보 형식 작성 OBJECTATTACK의 경우 
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;			// ObjectID	(+30000)
		cp_sv += 2;
	
		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;
		
		//for (i = 1; i < DEF_MAXCLIENTS; i++) {
		bFlag = TRUE;
		iShortCutIndex = 0;
		while (bFlag == TRUE) {
			// DEF_MAXCLIENTS 까지 루프를 돌지 않기 위한 방법. 클라이언트 숏컷 리스트에서 0이 나오면 끝이다.
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			//if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
			if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
			if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
				 (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
				 (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
				 (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
				 (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange) ) {
				
				if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
					if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0) {
						iTemp = m_pClientList[sOwnerH]->m_iStatus;
					}
					else if (i != sOwnerH) {
						iTemp = iTemp3;
					}
					else {
						iTemp = m_pClientList[sOwnerH]->m_iStatus;
					}
				}
				else {
					iTemp = m_pClientList[sOwnerH]->m_iStatus;
				}
				
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;
				
				/*iTemp = *ipStatus;
				iTemp = 0x0FFFFFFF & iTemp;
				iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
				iTemp  = (iTemp | (iTemp2 << 28));
				*ipStatus = iTemp;*/

				// 경계 안에 속한 클라이언트가 있다. 
				if ( (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9) &&
				     (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) &&
				     (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) &&
				     (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7) ) {
					// *** 이미 이름과 특성치등의 데이터가 보내진 객체들이다.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// 이 메시지는 위치에 상관없이 모든 데이터를 보내야 한다. 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43,cKey); //v2.23 :41 // v1.4 :36
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43,cKey); // v1.4 :36
						}
						break;
					
					case DEF_OBJECTMAGIC:
					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
					//case DEF_OBJECTDYING:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						}
						break;

					case DEF_OBJECTDYING:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						}
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						}
						break;

					default:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9,cKey); 
						}
						break;
					}
				}
				else {
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// 이 메시지는 위치에 상관없이 모든 데이터를 보내야 한다. 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43,cKey);  // v1.4 :36
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43,cKey);  // v1.4 :36
						}
						break;
					
					case DEF_OBJECTMAGIC:
					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
					if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						}
						break;

					case DEF_OBJECTDYING:	
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						else {
							if (i != sOwnerH)
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						}
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						}
						break;

					default:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43,cKey); // v1.4
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43,cKey);  // v1.4
						}
						break;
					}
				}
			}
			
		}
	}
	else {
		if (m_pNpcList[sOwnerH] == NULL) return;
		
		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;			
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pNpcList[sOwnerH]->m_iStatus;
		cp_a += 4;
		if (wMsgType == DEF_OBJECTNULLACTION) {// v1.4
			if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				 *cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;
		cp_a++;

		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;	
		cp_s += 2;
		
		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;


		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
		
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;			// ObjectID	(+40000)
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL)) 
			if ( (m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
				 (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
				 (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
				 (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
				 (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange) ) {
				
				iTemp = *ipStatus;
				iTemp = 0x0FFFFFFF & iTemp;				
				iTemp2 = iGetNpcRelationship(sOwnerH, i);
				iTemp  = (iTemp | (iTemp2 << 28));
				*ipStatus = iTemp;

				// 경계 안에 속한 클라이언트가 있다. 
				if ( (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
				     (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
				     (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
				     (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7) ) {
					// *** 이미 이름과 특성치등의 데이터가 보내진 객체들이다.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// 이 메시지는 위치에 상관없이 모든 데이터를 보내야 한다. 
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);  // v1.4 : 24
						break;
					
					case DEF_OBJECTDYING:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						break;

					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						break;

					default:
						if (m_pClientList[i]->m_pXSock != NULL)
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9,cKey);
						break;
					}
				}
				else {
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);  // v1.4 : 24
						break;
					
					case DEF_OBJECTDYING:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15,cKey); 
						break;

					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11,cKey); 
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13,cKey); 
						break;

					default:
						if (m_pClientList[i]->m_pXSock != NULL)
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);  // v1.4
						break;
					}
					// +++
				}
			}
		}
	}
}


int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
 register int * ip, ix, iy, iSize, iTileExists, iIndex;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal;
 int   iTemp, iTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	
	iIndex = 0;
	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;
		iIndex++;

		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		// @@@ !!! @@@ 이곳에 조건이 입력되야만 정보가 전달된다!!!
		if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			 (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			iTileExists++;
			// 위치정보 입력 
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			// 헤더 정보를 작성한다.
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {
				// 간혹 핸들이 있는데도 NULL인 경우로 에러발생. 원인파악중. 에러 보완 루틴 삽입. 
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != NULL)	ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				// 캐릭터 정보 삽입 
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					ip = (int *)cp;
					
					if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide) {
						if (iClientH != pTile->m_sOwner) {
							iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus & 0x0F0FFFF7F;
						}
						else {
							iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
						}
					}
					else {
						iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					}
					/*
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
					iTemp = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					*/
					
					ip  = (int *)cp;
					
					iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp; // 상위 4비트 클리어
			  	//sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner); // 2002-11-14
					iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH); 
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;
					
					iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp; // 상위 4비트 클리어
					iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}
			
			if ((ucHeader & 0x02) != 0) {
				// 죽은 캐릭터 정보 삽입 
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					ip = (int *)cp;
					
					if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide) {
						if (iClientH != pTile->m_sOwner) {
							iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus & 0x0F0FFFF7F;
						}
						else {
							iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
						}
					}
					else {
						iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					}
					
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
					iTemp = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					
					
					/*ip  = (int *)cp;
					
					iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp; // 상위 4비트 클리어
			  	//sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner); // 2002-11-14
					iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH); 
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;*/
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;
					
					iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp; // 상위 4비트 클리어
					iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					iTemp  = (iTemp | (iTemp2 << 28));
					*ip = iTemp;
					cp += 4;
					iSize += 4;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {
				// 아이템 정보 삽입 
				// 스프라이트 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				// 스프라이트 프레임 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				// 아이템 색 추가됨 v1.4 
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				// 동적 객체 종류 할당 
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
							
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		}

	}

	*pTotal = iTileExists;
	return iSize;
}


void CGame::OnTimer(char cType)
{
 DWORD dwTime;
 int iRet =0, i;
// SYSTEMTIME SysTime;
 
	dwTime = timeGetTime();

	//if ((dwTime - m_dwGameTime1) > 200) {
	GameProcess();
	//	m_dwGameTime1 = dwTime;
	//}


	if ((dwTime - m_dwGameTime2) > 3000) {
		CheckClientResponseTime();
		SendMsgToGateServer(MSGID_GAMESERVERALIVE, NULL);
		// 화면 갱신 
		InvalidateRect(G_hWnd, NULL, TRUE);
		m_dwGameTime2 = dwTime;
		// v1.41 
		_CheckGateSockConnection();
		
		// v1.41
		if ((m_bIsGameStarted == FALSE)     && (m_bIsItemAvailable == TRUE)      && 
			(m_bIsNpcAvailable == TRUE)     && (m_bIsGateSockAvailable == TRUE)  &&
			(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE)     &&
			(m_bIsSkillAvailable == TRUE)   && (m_bIsPortionAvailable == TRUE)   &&
			(m_bIsQuestAvailable == TRUE)   && (m_bIsBuildItemAvailable == TRUE) && 
			(m_iSubLogSockActiveCount == DEF_MAXSUBLOGSOCK)	
	#ifdef DEF_DEFENCEHACKING
				// 2002-12-8 World server 보안 설정을 위해 
				&& (m_bIsWLServerAvailable == TRUE)
	#endif 
			) {
			// 게임을 시작할 준비가 되었다. 메시지를 보낸다.
			PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
			m_bIsGameStarted = TRUE;
		}
	}
	//web actualiza
	if ((dwTime - m_dwGameTime8) > 60*1000) 
	{
		//PutLogProcessList("PROCESS #11");
		m_dwGameTime8 = dwTime;
	}

	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		SendStockMsgToGateServer();

		// v2.05
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(G_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				// 2.14 성후니 셧다운시 무조건 로그 저장 
				SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
				return;
			}
		}

		//New Command Portal - ZeroEoyPnk
		if (PortalAbility[1] == TRUE)
		{
			if (dwTime - dw_TimePortal[1] > dw_TimeOpenPortal[1])
				ClosePortal(1);
		}

		if (PortalAbility[2] == TRUE)
		{
			if (dwTime - dw_TimePortal[2] > dw_TimeOpenPortal[2])
				ClosePortal(2);
		}

		m_dwGameTime6 = dwTime;	
	}

	if ((dwTime - m_dwGameTime3) > 3000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		SpecialEventHandler();
		//EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwMinute) > 1000*50) {
		CheckDayOrNightMode();
		DoAbaddonThunderDamageHandler();
		CrusadeWarStarter(); 
	//	ApocalypseStarter(); 
		HeldenianFightStarter();
		//2009-03-18
		SYSTEMTIME SysTime;
		GetLocalTime(&SysTime);

		CityWarStarter();
				
		m_dwMinute = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) {
		MobGenerator();
		

		if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
			m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
			m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
			
			wsprintf(G_cTxt, "(!) Conectando ... (%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
			PutLogList(G_cTxt);
			
			m_iSubLogSockInitIndex++;
		}
		
		m_dwGameTime4 = dwTime;
	}

	if ((dwTime - m_dwFishTime) > 4000) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		m_dwFishTime = dwTime;
	}
#ifdef DEF_HIGH	
	if ((m_bAnunciosActivo == TRUE)&&(dwTime >= m_dwAnuncios)) {
		m_sAutoClearCount++;
		if (m_sAutoClearCount == 35){
			for (i=0;i < DEF_MAXCLIENTS;i++){
				if(m_pClientList[i] != NULL)
					SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "En 10 minutos se limpiaran los mapas.");
			} 
		} else if(m_sAutoClearCount == 36){
			AutoClearMap();
			m_sAutoClearCount = 0;
		} else {
			bReadMessageConfigFile("Anuncios.cfg");
			Anuncios();
		}
		m_dwAnuncios = timeGetTime() + 1000*60*10;
	}
#endif

	if ((dwTime - m_dwWhetherTime) > 1000*20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;
	}

	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect() == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;

			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	// v1.432-2 10초마다 섹터 정보 분석 
	if ((dwTime - m_dwMapSectorInfoTime) > 1000*10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		// v2.03 광물이 나오는 빈도수를 줄임 
		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			// 시간이 지남에 따라 활동 빈도 카운트를 감소시킴.
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}

/*	if ((DeathMatch == FALSE) && (ServerActivated == TRUE))// MORLA 2.11 - Deathmach Automtico
    {
        SYSTEMTIME SysTime;
        GetLocalTime(&SysTime);
		if ((3 == SysTime.wHour) || (5 == SysTime.wHour) || (20 == SysTime.wHour) || (21 == SysTime.wHour)) {
			openDeathmach();
			PutLogList("Auto start Deathmatch!");
		}		
	}

	if ((DeathMatch == TRUE)&&(bManualDeathmach == FALSE))
    {
        SYSTEMTIME SysTime;
        GetLocalTime(&SysTime);
		if ((4 == SysTime.wHour) || (6 == SysTime.wHour) || (16 == SysTime.wHour) || (22 == SysTime.wHour)) {
			closeDeathmach();
			PutLogList("Auto stop Deathmatch!");			
		}   		
	}*/

	if ((m_bIsHeldenianStarter == TRUE) && (m_bIsHeldenianMode == TRUE) && (dwTime >= m_dwHeldenianWTime)) {
		bHFlag = TRUE;
		GlobalEndHeldenianMode();
		m_dwHeldenianWTime = dwTime;
	}
	//2009-03-18	
	if ((m_bCityWar == TRUE) && (dwTime >= m_dwCityWTime) && (m_bCityWarStarter == TRUE))
		EndCityWar();

}

void CGame::CheckClientResponseTime()
{
 register int i, iPlusTime, iMaxSuperAttack, iValue;
 short sTemp, sItemIndex;
 DWORD dwTime;
 int a;
	
  dwTime = timeGetTime();
	
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
		// elvine
					if ((strcmp(m_pClientList[i]->m_cMapName, "elvbrk11") == 0) && (m_pClientList[i]->m_iLevel == 200))	{
					if ((strcmp(m_pClientList[i]->m_cLocation, "elvine") == 0) ||
					(strcmp(m_pClientList[i]->m_cLocation, "elvhunter") == 0))	//si es Elvine
					RequestTeleportHandler(i, "2   ", "gshop_2", -1, -1);//lo manda a shop elv
					ShowClientMsg(i, "You are now Max Level!");
			}//aresden
					if ((strcmp(m_pClientList[i]->m_cMapName, "arebrk11") == 0) && (m_pClientList[i]->m_iLevel == 200))	{
					if ((strcmp(m_pClientList[i]->m_cLocation, "aresden") == 0) ||
					(strcmp(m_pClientList[i]->m_cLocation, "arehunter") == 0))	//si es Elvine
					RequestTeleportHandler(i, "2   ", "gshop_1", -1, -1);//lo manda a shop elv
					ShowClientMsg(i, "You are now Max Level!");
			}//
			if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete != TRUE) {
				    delete m_pClientList[i];
                 	m_pClientList[i] = NULL;
					m_iTotalClients--;
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// 플레이어의 전체 채팅 불가능 지속시간을 줄인다. 
				 if (	(memcmp(m_pClientList[i]->m_cLocation, "NONE", 4) == 0) && 
					(m_pClientList[i]->m_iHP > 0) && 
					(m_pClientList[i]->m_iLevel >= 10) && (m_pClientList[i]->m_iAdminUserLevel == 0))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_DESTINY, NULL, NULL, NULL, NULL);

				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;
				
				// 평판을 내릴 수 있는 시간을 줄인다.
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;
				
				// 배고파질 시간이 되면 카운트를 하나 깍는다.
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
					// 시간이 다 되었다.
					// v2.03 운영자는 배고파지지 않는다. 
					if ((m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 )) {
						// 레벨이 DEF_LEVELLIMIT이하이면 배고픔 지수를 깍지 않는다.
					}
					else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;
					
					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30) ) {
						// 배고픔을 느끼는 상태이다. 클라이언트에게 통보한다. 
						SendNotifyMsg(NULL, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}
				
				// 배가 고프면 오르는 시간이 길어진다.
				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;
				
				iPlusTime = abs(iPlusTime);
				
				// HP가 올라갈 시간이 되면 올린다.
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}
				
				// MP가 올라갈 시간이 되면 올린다.
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}
				
				// SP가 올라갈 시간이 되면 올린다.
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}
				
				// 중독 효과를 계산한다.
				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}
				
				
				// ExpStock을 계산할 시점이면 
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
				}

				// AutoExe 계산 시점이면 
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME) {
					// v2.17 2002-8-2 자동으로 올라가는 경험치를 증가 시켰다.
					iValue = (m_pClientList[i]->m_iLevel);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						// 자동 시간 계산 경험치로는 레벨이 오르지 않으므로 처리한다.
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							GetExp(i, iValue);
							CalcExpStock(i);
						}
					}
			
					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}
						
				// v1.432 특수 능력 사용 가능 시간을 줄인다. 3씩 줄어든다.
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					// 사용자에게 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
					// v2.95 02/06/06 14:33 ResurrectionWand(MS.10) y (MS.20)
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if((m_pClientList[i]->m_iInt + m_pClientList[i]->m_iAngelicInt) > 99 && (m_pClientList[i]->m_iMag + m_pClientList[i]->m_iAngelicMag) > 99){
								m_pClientList[i]->m_cMagicMastery[94] = TRUE;
								SendNotifyMsg(NULL, i, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;
				
				// v1.432 특수 능력 사용중인 시간을 체크 
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
					if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime)/1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
						// 사용시간이 다 되었다.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
						// 다음 사용 가능 시간을 입력한다.
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						// 효과 비트 클리어
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						// 외형이 변했음을 알린다.
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					// 맵 갇힘 시간 종료. 클리어한다.
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}

				// v2.04 죽었을때 페널티 시간 
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;
				
				//tiempo safe
				if (m_pClientList[i] == NULL) break;
				if ((m_bHeldSafe == TRUE) && (m_bIsHeldenianMode == FALSE) && (dwTime >= m_dwHeldenianSafeTime))
				{
					m_bHeldSafe = FALSE;
				}
				if (m_pClientList[i] == NULL) break;
				if ( (m_pClientList[i]->m_b5MinutosFinales == TRUE) ) {
					// Heldenian
					if ((m_bIsHeldenianMode == FALSE) && (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsHeldenianMap == TRUE))
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						// 쩍째짙 쨈 쨉쩐첬쨈. 째짯짝 쨍짰쨈.
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_b5MinutosFinales = FALSE;
						for (a = 0; a < DEF_MAXMAPS; a++)
						{ 
							if (m_pMapList[a] != NULL) { 
								RemoveOccupyFlags(a);
								m_pMapList[a]->BorrarFlag();
							}
						}
						// 쩌짱쨉쨈쨈 쨍쩍철쨍짝 쨘쨍쨀쩍쨈.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}
				}

				if (m_pClientList[i] == NULL) break;
				if(m_bCityWar == TRUE)
				{
					if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName,"GodH",4)==0)||((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName,"GodH",4)==0)&&m_pClientList[i]->m_iLevel < 121))
					{
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					} 
				}

				if (m_pClientList[i] == NULL) break;
				if ( (m_pClientList[i]->m_bIsWarLocation == TRUE) ) {
					// Crusade
					if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[i]->m_bIsInBuilding == TRUE))
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						// 시간이 다 되었다. 강제 리콜한다.
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = FALSE;
											
						// 소환된다는 메시지를 보낸다.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "0   ");
					}
				}
				
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					// 아이템 제작 명령이 2개 이상 접수되었다면 이상한 것이다. 정상적이라면 1개 까지 올 수 있다.
					//wsprintf(G_cTxt, "(!) 해킹 용의자(%s) 속도 조작", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				// 속도버그 체크용. 단위시간당 지나치게 많은 경험치를 얻은 캐릭은 블록된다.
/*#ifndef DEF_TESTSERVER
				if (m_pClientList[i] == NULL) break;
				if ((dwTime - m_pClientList[i]->m_dwSpeedHackCheckTime) > (DWORD)1000*60*60) {
					if ((m_pClientList[i]->m_iExp - m_pClientList[i]->m_iSpeedHackCheckExp) > 300000) {
						// 1시간에 경험치를 30만 이상 얻었다. 
						wsprintf(G_cTxt, "(!) Character(%s) Get %dExp in 1 hour.. Hack suspect", m_pClientList[i]->m_cCharName, (m_pClientList[i]->m_iExp - m_pClientList[i]->m_iSpeedHackCheckExp));
						
						SYSTEMTIME SysTime;
						GetLocalTime(&SysTime);
												
						if ((SysTime.wMonth+1) >= 13) {
							m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear+1;
							m_pClientList[i]->m_iPenaltyBlockMonth = 1;
							m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
						}
						else {
							m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear;
							m_pClientList[i]->m_iPenaltyBlockMonth = SysTime.wMonth+1;
							m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
						}
						
						PutLogList(G_cTxt);
						PutLogFileList(G_cTxt);
						PutHackLog(G_cTxt);
						DeleteClient(i, TRUE, TRUE);
					}
					else {
						m_pClientList[i]->m_dwSpeedHackCheckTime = dwTime;
						m_pClientList[i]->m_iSpeedHackCheckExp = m_pClientList[i]->m_iExp;
					}
				}
#endif*/
				if (m_pClientList[i] == NULL) break;
				// 하위 레벨 제한에 걸린다면 
				// v2.13 운영자는 강콜이 않된다.
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					// 소환된다는 메시지를 보내고 강제 리콜.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// 상위 레벨 제한에 걸린다면 
				// v2.13 운영자는 강콜이 않된다.
				if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					// 소환된다는 메시지를 보내고 강제 리콜.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}
				

				if (m_pClientList[i] == NULL) break;
				// v2.20
				if ((m_bIsCrusadeMode == FALSE)
					&& (m_pClientList[i]->m_bIsHunter == TRUE )
					&& (((m_iMiddlelandMapIndex == m_pClientList[i]->m_cMapIndex) && (m_iMiddlelandMapIndex != -1)) 
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresdend1",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvined1",8) == 0)
   					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone3",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone4",9) == 0)
					   || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middle",6) == 0) )
					&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				//News Portals - ZeroEoyPnk
				if (m_pClientList[i] == NULL) break;
				if (PortalAbility[1] == TRUE)
				{
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, Portal_Init[1], 11) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, ini_dx_portal[1], ini_dy_portal[1], NULL, Portal_Init[1]);
					}
				}
				if (m_pClientList[i] == NULL) break;
				if (PortalAbility[1] == TRUE)
				{
					if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, Portal_Init[1], 11) == 0) &&
						(m_pClientList[i]->m_iLevel <= LevelLimit_portal[1]) &&
						((m_pClientList[i]->m_sX > ini_dx_portal[1] - 1) && (m_pClientList[i]->m_sX < ini_dx_portal[1] + 2)) &&
						((m_pClientList[i]->m_sY > ini_dy_portal[1] - 1) && (m_pClientList[i]->m_sY < ini_dy_portal[1] + 2)))
					{
						RequestTeleportHandler(i, "2   ", Portal_MapName[1], dest_dx_portal[1], dest_dy_portal[1]);
						PortalPlayers[1]++;
						if (PortalPlayers[1] >= MaxPlayer_portal[1])
						ClosePortal(1);
					}
				}

				//News Portals - ZeroEoyPnk
				if (m_pClientList[i] == NULL) break;
				if (PortalAbility[2] == TRUE)
				{
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, Portal_Init[2], 11) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN2, ini_dx_portal[2], ini_dy_portal[2], NULL, Portal_Init[2]);
					}
				}
				if (m_pClientList[i] == NULL) break;
				if (PortalAbility[2] == TRUE)
				{
					if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, Portal_Init[2], 11) == 0) &&
						(m_pClientList[i]->m_iLevel <= LevelLimit_portal[2]) &&
						((m_pClientList[i]->m_sX > ini_dx_portal[2] - 1) && (m_pClientList[i]->m_sX < ini_dx_portal[2] + 2)) &&
						((m_pClientList[i]->m_sY > ini_dy_portal[2] - 1) && (m_pClientList[i]->m_sY < ini_dy_portal[2] + 2)))
					{
						RequestTeleportHandler(i, "2   ", Portal_MapName[2], dest_dx_portal[2], dest_dy_portal[2]);
						PortalPlayers[2]++;
						if (PortalPlayers[2] >= MaxPlayer_portal[2])
						ClosePortal(2);
					}
				}

				if (m_pClientList[i] == NULL) break;
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE) && 
					(m_bIsApocalypseMode == FALSE) &&
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					RequestTeleportHandler(i, "1   ");
					}
				if (m_pClientList[i] == NULL) break;
				if (m_bIsApocalypseMode == TRUE) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "abaddon", 7) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, 167, 169, NULL, m_pClientList[i]->m_cMapName);
					}
			    	if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "inferniaA", 9) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, 119,29, NULL, m_pClientList[i]->m_cMapName);
					}
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "inferniaB", 9) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, 31,28, NULL, m_pClientList[i]->m_cMapName);
					}
			
				
				// v3.2
				if (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsGateAvailable == TRUE) {
					if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_1", 7) == 0) || (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_2", 7) == 0)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1,
							m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1, NULL, m_pClientList[i]->m_cMapName);
					}
				}
				
				if (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsInferniaAGate == TRUE) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "inferniaA", 9) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1,
							m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1, NULL, m_pClientList[i]->m_cMapName);
					}
				}
						
				if (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsInferniaBGate == TRUE) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "inferniaB", 9) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1,
							m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1, NULL, m_pClientList[i]->m_cMapName);
					}
				}
				
				if (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsProcellaGate == TRUE) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "procella", 8) == 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1,
							m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1, NULL, m_pClientList[i]->m_cMapName);
					}
				}

				
				if (m_pClientList[i] == NULL) break;
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsGateAvailable == TRUE) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_2", 7) == 0) &&
					((m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2))) {
						RequestTeleportHandler(i, "2   ", m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cDynamicGateDestMap, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtX, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtY);
				}

				if (m_pClientList[i] == NULL) break;
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsGateAvailable == TRUE) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_1", 7) == 0) &&
					((m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2))) {
						RequestTeleportHandler(i, "2   ", m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cDynamicGateDestMap, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtX, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtY);
				}
				
				
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsInferniaAGate == TRUE) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "inferniaA", 9) == 0) &&
					((m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2))) {
						RequestTeleportHandler(i, "2   ", m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cDynamicGateDestMap, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtX, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtY);
				}
				
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsInferniaBGate == TRUE) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "inferniaB", 9) == 0) &&
					((m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2))) {
						RequestTeleportHandler(i, "2   ", m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cDynamicGateDestMap, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtX, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtY);
				}
				
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsProcellaGate == TRUE) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "procella", 8) == 0) &&
					((m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX1 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY1) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2) ||
					(m_pClientList[i]->m_sX == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateX2 && m_pClientList[i]->m_sY == m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateY2))) {
						RequestTeleportHandler(i, "2   ", m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cDynamicGateDestMap, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtX, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_sDynamicGateTgtY);
				}
				}
				if (m_pClientList[i] == NULL) break;
				// 필살기 카운트 증가 
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39초마다 한개씩 축적 된다.
					
					m_pClientList[i]->m_iSuperAttackCount = 0;
					// 필살기는 최대 Level/10 개 까지 축적된다.
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 8);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;
						
					// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}

				// v1.42 고정 스태미너 카운트 감소 
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade 맵정보를 보내는 중이었다면 계속 보낸다.
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					// 누적된 건설 포인트가 있다.
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

#ifdef DEF_RADMIN
void CGame::OnRAdminSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pRAdminSock == NULL) return;

	iRet = m_pRAdminSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		bSendMsgToLS(MSGID_HGUP, NULL, NULL); 
		PutLogList("(!!!) Radmin-socket connected!");
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnRadminRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("(!!!) Radmin-socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		delete m_pRAdminSock;
		m_pRAdminSock = NULL;
		PutLogList("(!!!) Radmin-log-socket connection lost!");
		break;
	}
}

void CGame::OnRadminRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pRAdminSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_RADMIN, pData, dwMsgSize, NULL, cKey) == FALSE) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}
#endif
void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pMainLogSock == NULL) return;

	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// 로그서버로의 연결이 이루어 졌으므로 게임서버 등록 메시지를 전송한다.
		PutLogList("(!!!) Main-log-socket connected!");
		bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// 메시지가 수신되었다. 
		OnMainLogRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("(!!!) Main-log-socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// 확인코드가 일치하지 않는다. 
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// 수신해야 할 메시지 크기가 버퍼보다 크다.	종료해야만 한다.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// 소켓에 에러가 났다.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 소켓이 닫혔다.
		delete m_pMainLogSock;
		m_pMainLogSock = NULL;
		PutLogList("(!!!) Main-log-socket connection lost!");
		m_bIsLogSockAvailable = FALSE;

		// 로그 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		}
		break;
	}
}

void CGame::OnMainLogRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// 메시지 큐에 이상이 생겼다. 치명적인 에러.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

// v2.14 GM Log 를 윌드 서버로 보내기 위해 수정함 .
BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag,char * pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i, iSize;
 char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
  char text[256];
 int   * ip, iSendSize;
 char cKey;
 cKey = (char)(rand() % 255) +1;
	// v1.41
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));
    
	switch (dwMsg) {
#ifdef DEF_RADMIN
	case MSGID_HGUP:
		if (m_pRAdminSock == NULL) return FALSE;
		dwp  = (DWORD *)G_cData50000;
		*dwp = MSGID_HGUP;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE);

		memcpy(cp, m_cServerName, 11);
		cp += 11;

		iRet = m_pRAdminSock->iSendMsg(G_cData50000, 15);
		break;
#endif
	case MSGID_SENDSERVERSHUTDOWNMSG:
		if (m_pMainLogSock == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// 이 메시지는 m_pMainLogSock으로 보내야 한다. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		break;
	
	case MSGID_GAMESERVERSHUTDOWNED:
		if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// 이 메시지는 m_pMainLogSock으로 보내야 한다. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		return TRUE;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
	
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:
		
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cServerName, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		//testcode
		wsprintf(G_cTxt, "(TestLog) Enter Game Confirm Level: %d", m_pClientList[iClientH]->m_iLevel);
		PutLogList(G_cTxt);
		strcat(text, m_pClientList[iClientH]->m_cCharName);//fixed: correct name
        strcat(text, " has connected."); //global message
        for (i = 1; i < DEF_MAXCLIENTS; i++)
        SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, text);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_REGISTERGAMESERVER:
		// 로그 서버에게 게임서버 등록을 요청한다.
		if (m_pMainLogSock == NULL) return FALSE;

		//wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		//PutLogList(cTxt);
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));

		memcpy(cp, cAccountName, 10);
		cp += 10;
/*
		memcpy(cp, DEF_PASSWORD, 10);
		cp += 10;
*/
		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = (WORD) m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11);
		return TRUE;

	case MSGID_REQUEST_PLAYERDATA:
		
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//testcode
		if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		memcpy((char *)cp, cTemp, 15);
		cp += 15;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;
    	//Crusade 
/*	case MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA:
		
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_iMiddlelandMapIndex < 0) return FALSE;
		
		//testcode
		PutLogList("(!) Middleland Aresden OccupyFlag data saved.");
				
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 1);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;

	case MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA:
		
		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_iMiddlelandMapIndex < 0) return FALSE;
		
		//testcode
		PutLogList("(!) Middleland Elvine OccupyFlag data saved.");
				
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 2);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;
	*/
	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

#ifdef DEF_DBGAMESERVER
		// v2.14 DB 저장 속도 향상 
		dwp = (DWORD *) cp ;
		*dwp = m_pClientList[iClientH]->m_dwCharID  ;
		cp += 4 ;

		*cp = (char)bFlag; // 카운팅 플래그 
		cp++;
		
		iSize = _iComposePlayerDataFileContents(iClientH, cp);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 41 + iSize);
		iSendSize = 41 + iSize;
		break;
#else

		*cp = (char)bFlag; // 카운팅 플래그 
		cp++;
		
		iSize = _iComposePlayerDataFileContents(iClientH, cp);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		iSendSize = 37 + iSize;
		break;
#endif

	case MSGID_REQUEST_NOSAVELOGOUT:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		
		*cp = (char)bFlag; // 카운팅 플래그 
		cp++;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;

	case MSGID_REQUEST_CREATENEWGUILD:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_DISBANDGUILD:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;
	case MSGID_GAMEMASTERLOG:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;
		

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEMASTERLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
			
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;
		// v2.15 
	case MSGID_GAMEITEMLOG:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
//		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEITEMLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
			
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	case MSGID_GAMECRUSADELOG:

		// Sub-log-socket을 사용한 전송에서는 반드시 체크해야 하는 루틴.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
//		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMECRUSADELOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);
			
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Sub-log-socket을 사용해서 로그 서버로 메시지를 보낼때 에러가 발생했다.
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);

		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;
				
		// 다시 연결을 시도
		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		// v1.41 sub-log-socket 전송 실패 카운트 증가 
		m_iSubLogSockFailCount++;

		// v1.41 보내려다 실패한 메시지는 다른 소켓을 사용하여 전송해야 한다. 
		// 이 방법이 모든 메시지의 전송을 보장하지는 않는다. 최소한의 장치인 셈.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

		return FALSE;
	}

	return TRUE;
}



void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
 WORD * wp;
 DWORD * dwp ;
 char * cp, cCharName[11], cTxt[120];
 int  i; 
 
 	// 로그 서버로부터 플레이어 데이터가 도착했다. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	// 이름이 일치하는 클라이언트 배열을 검색한다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
			case DEF_LOGRESMSGTYPE_CONFIRM:
				// 클라이언트 데이터가 정상적으로 수신되었다. 
				InitPlayerData(i, pData, dwSize); 
				break;
	
			case DEF_LOGRESMSGTYPE_REJECT:
				// 이 클라이언트의 데이터 초기화가 거부되었다. 접속을 끊는다.
				// v2.15 2002-5-21
				if( *cp == 1) {
					ZeroMemory(cTxt, sizeof(cTxt));
					dwp  = (DWORD *)(cTxt + DEF_INDEX4_MSGID);
					*dwp = MSGID_PREVENTCLIENTHACK;
					wp   = (WORD *)(cTxt + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_MSGTYPE_REJECT;

					m_pClientList[i]->m_pXSock->iSendMsg(cTxt, 6); 
				}
				else {
					wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
					PutLogList(G_cTxt);
					//PutLogFileList(G_cTxt); // v1.4

					DeleteClient(i, FALSE, FALSE);
				}
				break;
			
			default:
				break;
			}				
			
			return;
		}	
	}

	// 이름이 일치하는 클라이언트를 찾을 수 없다.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
 char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus;
 DWORD * dwp;
 WORD  * wp;
 int     i, iRet;
 BOOL    bRet;
 char  cPrice = 0;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return; // 이미 초기화 된 캐릭터의 데이터이다. 이런일이 있을 수 있을까?
	
	wsprintf(G_cTxt,"<%d> New client: %s", iClientH, m_pClientList[iClientH]->m_cIPaddress);
	PutLogList(G_cTxt);
	
	// Log Server로부터의 메시지를 분석하여 플레이어의 데이터를 초기화한다. 
    // 만약 로그서버로부터의 메시지가 파일손상등의 이유로 내용이 정확하게 맞지 않으면 초기화 하지 않고 클라이언트를 삭제한다.
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	// 계정정보 저장  v1.43	부터 더이상의 계정 정보는 필요없다. 
	//m_pClientList[iClientH]->m_cAccountStatus = *cp;
	cp++;

	// 길드 정보 읽는다. 이 값이 0이면 길드이름과 랭크는 무효다.  
	cGuildStatus = *cp;
	cp++;

	// 기본 명중률은 0%(방어률과는 약간 의미가 다름. 맨손공격시의 명중률은 따로 계산된다)
	m_pClientList[iClientH]->m_iHitRatio     = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide         = 0;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	// 리턴값이 FALSE이면 클라이언트 데이터가 무언가 잘못된 것. 클라이언트를 삭제하고 리턴한다.
	if (bRet == FALSE) {
		wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, FALSE, TRUE); //!!!
		return;
	}
	
	// *******^^^^^^^^^^^^^^^^^^^^특성치값 로딩 완료^^^^^^^^^^^^^^^^^^^^^********
	//***************************************************************************

	// (!) 특성치를 복구한다. 
	___RestorePlayerCharacteristics(iClientH);

	// (!) 잘못된 특성치를 복구한다. 
	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		// 좌표가 모두 -1이면 위치한 맵의 InitialPoint로 간다.
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}



	//Aviso que el RushNet Esta activado
	if (m_bIsRushNetMode == TRUE)
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RUSH, 10, NULL, NULL, NULL, NULL);
		UpdateRushNet(0);
	}


	// Side, OnTown, OnShop 정보를 가져온다.
	iSetSide(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH, NULL);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
	// 기존의 레벨이 높은 캐릭터가 민간인 모드로 설정 되어 있으면 
	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == TRUE ) ) 
		SetNoHunterMode(iClientH) ;

	// 다음 레벨의 경험치를 구한다.
	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	// 특성치 재계산.
	CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
	// 무게 계산
	iCalcTotalWeight(iClientH);

	// MORLA 2.10 - Top DeathMach:
	if (DeathMatch == TRUE)
		for (i=1; i<=15; i++)
		{
			if ((iDGtop[i] != NULL) && (iDGtop[i] != -1))
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DGKILL, i, aDGTopKills[i], aDGTopDeaths[i], aDGTopClientH[i]);
		}

	// 특수 이벤트 계산 
//	CheckSpecialEvent(iClientH);

//	CheckSpecialEventThirdYear(iClientH);

	// 2002-7-4 
	if ((m_pClientList[iClientH]->m_iAdminUserLevel >= 1) && (m_pClientList[iClientH]->m_iAdminUserLevel <= 5))
	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINCOMMAND,m_pClientList[iClientH]->m_bActivarComandos, NULL, NULL, NULL);
		m_pClientList[iClientH]->AdminChat = TRUE;
	}

	// GuildName이 NONE이 아니고 GuildStatus가 0이면 접속중이 아닐때 길드가 지워졌다는 의미.
	if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
		// 길드가 비접속중일때 사라졌으므로 지금 알려준다.
		ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
	}
	
	if (m_pClientList[iClientH]->m_iQuest != NULL) { 
	//		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
	//		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
			_bCheckIsQuestCompleted(iClientH);
	}


	//v2.19 2002-11-14 전면전 승리한쪽으 가격을 10프로 싸게 해준다.
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		cPrice = 0;

		if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			cPrice = -10;
	}
	//2009-03-21
	char cLost = 0; 
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		switch(m_sLastHeldenianWinner){
		case 1:
			cLost = 2;
			break;
		case 2:
			cLost = 1;
			break;
		}
		if(cLost == m_pClientList[iClientH]->m_cSide)
			cPrice += 100;
	}


	// 메시지 전송 도중 에러가 발생하여 클라이언트가 삭제되었다면 처리 종료 
	if (m_pClientList[iClientH] == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_PREVENTCLIENTHACK;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	// 데이터 초기화 확인 메시지 전송
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		// ## BUG POINT!!! 먼저 로그 메시지 출력후 삭제한다.
		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		
		DeleteClient(iClientH, FALSE, TRUE); //!!!!!
		return;
	}

	// 클라이언트의 데이터가 초기화 되었다. 
	m_pClientList[iClientH]->m_bIsInitComplete = TRUE;

	// 로그 서버에게 이 계정의 플레이어가 게임중에 들어왔음을 알려준다. 
	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	// v2.06 12-5 GateServer에 이 플레이어의 파티가 유효한지 묻는다.
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 5; // 파티 멤버 확인 요청
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

		// 일단 파티 리스트에 등록한다.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
			goto IPD_LOOPBREAK1;
		}
IPD_LOOPBREAK1:;
	}

	if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1,2)) {
		case 1: 
			RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
			break;
		case 2: 
			switch (m_pClientList[iClientH]->m_cSide) {
			case 0: RequestTeleportHandler(iClientH, "2   ", "gshop_1", -1, -1); break;
			case 1: RequestTeleportHandler(iClientH, "2   ", "gshop_1", -1, -1); break;
			case 2: RequestTeleportHandler(iClientH, "2   ", "gshop_2", -1, -1); break;
			}
			break;
		}
	}

	return;
}

void CGame::GameProcess()
{
	NpcProcess();
	MsgProcess();
	DelayEventProcess();
	if (m_bIsRushNetMode == TRUE) SendHpReliquia();
}

BOOL CGame::bReadProgramConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode, cTxt[120];
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		//	PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						// 서버의 이름이 너무 길다. 
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
/*					// v2.04 게임서버 IP 자동으로 인식 
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					char ServerAddr[50];
					::gethostname(ServerAddr,50); 
					struct hostent *pHostEnt;
					pHostEnt = ::gethostbyname(ServerAddr);
					if( pHostEnt != NULL ){
						wsprintf(ServerAddr, "%d.%d.%d.%d",
						( pHostEnt->h_addr_list[0][0] & 0x00ff ),
						( pHostEnt->h_addr_list[0][1] & 0x00ff ),
						( pHostEnt->h_addr_list[0][2] & 0x00ff ),
						( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
					}
					strcpy(m_cGameServerAddr,ServerAddr );

					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
*/
					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Log server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
					
				case 5:
					// 맵을 등록한다.
					if (strlen(token) > 10) {
						// 맵의 이름이 너무 길다.
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;

				case 6:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 7:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 8:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						// 주소가 15바이트 이상. 오류다. 
						wsprintf(cTxt, "(!!!) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address :  : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 9:
					m_iExtHGServerPort = atoi(token);
					wsprintf(cTxt, "(*) External GameServer server port : %d", m_iExtHGServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 8;
				if (memcmp(token, "external-server-port", 20) == 0)		cReadMode = 9;
			}
			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete []cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
BOOL CGame::bReadMessageConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		return FALSE;
	}
	else {
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cMsg1, sizeof(m_cMsg1));
					if (strlen(token) > 100) {
						return FALSE;
					}
					strcpy(m_cMsg1, token);
					cReadMode = 0;
					break;

				}
			}
			else {
				if (memcmp(token, "msg-1", 5) == 0)			cReadMode = 1;
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete []cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		// 12-16 성후니 변경 
        // PutLogList("(!) Cannot open Crusade Schedule file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						// 스트럭쳐 번호
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != NULL) {
							// 이미 할당된 번호가 있다. 에러이다.
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate potion number.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						
						cReadModeB = 2;
						break;

					case 2:
						// 맵 이름
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;

					
					case 3:
						// 종류
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						// 위치
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						// 위치
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}	

		delete pStrTok;
		delete []cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}
	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}



BOOL CGame::_bRegisterMap(char * pName)
{
 int i;
 char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	// 먼저 이미 등록된 맵인지 검색한다. 
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
		// 이미 등록된 맵이다. 
		wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
		PutLogList(cTxt);
		return FALSE;
	}

	// 등록되어 있지 않은 맵이므로 등록한다.	
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] == NULL) {
		m_pMapList[i] = (class CMap *)new class CMap(this);
		wsprintf(cTxt, "(*) Add map (%s)   - Loading map info files...", pName);
		PutLogList(cTxt);
		// 맵의 정보와 NPC리스트, 이벤트 리스트등을 로드한다.
		// 맵 데이터 파일 로드. 
		if (m_pMapList[i]->bInit(pName) == FALSE) {
			wsprintf(cTxt, "(!!!) Data file loading fail!", pName);
			PutLogList(cTxt);
			return FALSE;	
		};
		
		PutLogList("(*) Data file loading success.");
		// 맵 이벤트 파일 로드는 NPC 컨피규레이션 데이터가 수신된 후에  
		
		// v1.3 미들랜드라면 인덱스를 표시해놓는다.
		if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
			m_iMiddlelandMapIndex = i;

		// v1.3 아레스덴 인덱스를 표시해놓는다.
		if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0)) 
			m_iAresdenMapIndex = i;

		// v1.3 엘바인 인덱스를 표시해놓는다.
		if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0)) 
			m_iElvineMapIndex = i;
	
		if ((m_iBTFieldMapIndex == -1) && (strcmp("BtField", pName) == 0))
			m_iBTFieldMapIndex = i;

		if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0))
			m_iGodHMapIndex = i; 
#ifdef DEF_HIGH
		if ((m_iFenixVipMapIndex == -1) && (strcmp("FenixVip", pName) == 0))
			m_iFenixVipMapIndex = i;
#endif
		m_iTotalMaps++;
		return TRUE;
	}

	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
	PutLogList(cTxt);
	return FALSE;
}

#ifdef DEF_DBGAMESERVER

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
	char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char   seps[] = "= \t\n";
	char   cReadModeA, cReadModeB;
	int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
	class  CStrTok * pStrTok;
	short  sTmpType, sTmpAppr1;
	BOOL   bRet;
	int    iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	BOOL   bIsNotUsedItemFound = FALSE;

	if (m_pClientList[ iClientH ] == NULL) return FALSE;

	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;
	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);
	pOriginContents = pContents;
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				ZeroMemory(m_pClientList[ iClientH ]->m_cMapName, sizeof(m_pClientList[ iClientH ]->m_cMapName));
				strncpy(m_pClientList[ iClientH ]->m_cMapName, token, sizeof(m_pClientList[ iClientH ]->m_cMapName)-1);
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strncpy(cTmpName, token, sizeof(cTmpName)-1);
				for (i = 0; i < DEF_MAXMAPS; i++)
					if ((m_pMapList[ i ] != NULL)	&& (memcmp(m_pMapList[ i ]->m_cName, cTmpName, 10) == 0)) {
						m_pClientList[ iClientH ]->m_cMapIndex = (char)i;
					}

					if (m_pClientList[ iClientH ]->m_cMapIndex == -1) {
						wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[ iClientH ]->m_cCharName, cTmpName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeA = 0;
					break;

			case 2:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				
				if (_bGetIsStringIsNumber(token) == FALSE) {
				wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
				PutLogList(cTxt);
				delete pContents;
				delete pStrTok;
				return FALSE;
				}
				m_pClientList[ iClientH ]->m_cAccountStatus = atoi(token);
				
				cReadModeA = 0;
				break;

			case 5:
				switch(cReadModeB) {
			case 1:
				if (iItemIndex >= DEF_MAXITEMS) {
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				if (_bInitItemAttr(m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ], token) == FALSE) {
					wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[ iClientH ]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;
				if ( iGetItemWeight(m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Player(%s) Item (%s) too heavy for player to carry", m_pClientList[ iClientH ]->m_cCharName, m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_cName);
					PutLogFileType(G_cTxt, LOGTYPE_EVENTS);
					PutLogList(G_cTxt);
				}

				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				if (memcmp(m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_wCurLifeSpan = atoi(token);
				cReadModeB = 12;
				break;

			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_dwAttribute = atoi(token);

				if (m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
					if ( (m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue1 != m_pClientList[ iClientH ]->m_sCharIDnum1) ||
						(m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue2 != m_pClientList[ iClientH ]->m_sCharIDnum2) ||
						(m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue3 != m_pClientList[ iClientH ]->m_sCharIDnum3) ) {
							wsprintf(cTxt, "(!) 쨈쨍짜 쨩챌쨋첨 쩐 쩌철: Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[ iClientH ]->m_cCharName, m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_cName,
								m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue1,
								m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue2,
								m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sTouchEffectValue3,
								m_pClientList[ iClientH ]->m_sCharIDnum1,
								m_pClientList[ iClientH ]->m_sCharIDnum2,
								m_pClientList[ iClientH ]->m_sCharIDnum3); 
							PutLogList(cTxt);
						}
				}

				cReadModeA = 0;
				cReadModeB = 0;

				if ((m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_dwAttribute & 0x00000001 ) != NULL) {
					m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_wMaxLifeSpan = m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_sItemSpecEffectValue1;
				}

				_AdjustRareItemValue(m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]);

				if ((m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)){	// SNOOPY: Translated to English 
						wsprintf(G_cTxt, "(!) Player:(%s) had a Zem type item with 0 life in his bag, put 1 life!", m_pClientList[iClientH]->m_cCharName);				
						PutLogList(cTxt);
						PutLogFileList(G_cTxt);
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);

					if (m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_wPrice;
						delete m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ];
						m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ] = NULL;

						// v1.41
						bIsNotUsedItemFound = TRUE;
					}
					else
						if (_bCheckDupItemID(m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]) == TRUE) {
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]);

							iNotUsedItemPrice += m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ]->m_wPrice;
							delete m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ];
							m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ] = NULL;
						}
						else iItemIndex++;
						break;
				}
				break;

			case 6:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;

			case 7:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[ iClientH ]->m_sItemEquipmentStatus[ i ] = -1;

				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[ iClientH ]->m_bIsItemEquipped[ i ] = FALSE;

				if (bIsNotUsedItemFound == FALSE) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[ i ]);
						if ((token[ i ] == '1') && (m_pClientList[ iClientH ]->m_pItemList[ i ] != NULL)) {
							if (m_pClientList[ iClientH ]->m_pItemList[ i ]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								m_pClientList[ iClientH ]->m_bIsItemEquipped[ i ] = TRUE;
							else m_pClientList[ iClientH ]->m_bIsItemEquipped[ i ] = FALSE;
						}
						else m_pClientList[ iClientH ]->m_bIsItemEquipped[ i ] = FALSE;

						if ((m_pClientList[ iClientH ] != NULL) && (m_pClientList[ iClientH ]->m_bIsItemEquipped[ i ] == TRUE)) {
							if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
								m_pClientList[ iClientH ]->m_bIsItemEquipped[ i ] = FALSE;
						}
					}
				}

				cReadModeA = 0;
				break;

			case 12:
				ZeroMemory(m_pClientList[ iClientH ]->m_cGuildName, sizeof(m_pClientList[ iClientH ]->m_cGuildName));
				strncpy(m_pClientList[ iClientH ]->m_cGuildName, token, sizeof(m_pClientList[ iClientH ]->m_cGuildName)-1);
				cReadModeA = 0;
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14:
				// HP 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15:
				// DefenseRatio
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[ iClientH ]->m_iOriginDefenseRatio = atoi(token);
				//m_pClientList[ iClientH ]->m_iCurDefenseRatio = m_pClientList[ iClientH ]->m_iOriginDefenseRatio;
				cReadModeA = 0;
				break;

			case 16:
				// HitRatio
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[ iClientH ]->m_iOriginHitRatio = atoi(token);
				//m_pClientList[ iClientH ]->m_iCurHitRatio = m_pClientList[ iClientH ]->m_iOriginHitRatio;
				cReadModeA = 0;
				break;

			case 17:
				// Level  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 18:
				// Str 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19:
				// Int 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20:
				// Vit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21:
				// Dex 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22:
				// Mag 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23:
				// Charisma 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24:
				// Luck 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25:
				// Exp 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iExp = atoi(token);
				cReadModeA = 0;
				break;

			case 26:
				// Magic-Mastery
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[ iClientH ]->m_cMagicMastery[ i ] = token[ i ] - 48;
				}
				cReadModeA = 0;
				break;

			case 27:
				// Skill-Mastery
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;
				//
			case 28:
				// Warehouse
				switch(cReadModeB) {
			case 1:
				if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				if (_bInitItemAttr(m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[ iClientH ]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;

				if ( iGetItemWeight(m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) 쨀쨍짱(%s) 쩐(%s) 째쨀쩌철 쩔쨔철쨌쩔챙", m_pClientList[ iClientH ]->m_cCharName, m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_cName);
					PutLogFileType(G_cTxt, LOGTYPE_EVENTS);
					PutLogList(G_cTxt);
				}

				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				if (memcmp(m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;


			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;

				if ((m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != NULL) {
					m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
				}

				int iValue = (m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue > 0) {
					switch (m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
					case 5:
					case 6:
						m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
						break;
					}
				}

				_AdjustRareItemValue(m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]);

				if (   (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) 
					&& (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) 
				{	// SNOOPY: Translated to English 
					wsprintf(G_cTxt, "(!) Player:(%s) had a Zem type item with 0 life in his WH, put 1 life!", m_pClientList[iClientH]->m_cCharName);				
					PutLogList(G_cTxt);
					PutLogFileList(G_cTxt);
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
				}

					if (m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex] = NULL;
					}
					else 
						if (_bCheckDupItemID(m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]) == TRUE) {
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]);

							iNotUsedItemPrice += m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
							delete m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex];
							m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex] = NULL;		
						}
						else iItemInBankIndex++;
						break;
				}
				break;

			case 29:
				ZeroMemory(m_pClientList[ iClientH ]->m_cLocation, sizeof(m_pClientList[ iClientH ]->m_cLocation));
				strncpy(m_pClientList[ iClientH ]->m_cLocation, token, sizeof(m_pClientList[ iClientH ]->m_cLocation)-1);
				if (memcmp(m_pClientList[ iClientH ]->m_cLocation+3,"hunter",6) == 0)
					m_pClientList[ iClientH ]->m_bIsPlayerCivil = TRUE;
				cReadModeA = 0;
				break;

			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;

			case 31:
				// m_iSP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32:
				// m_cLU_Pool
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iLU_Pool = atoi(token);
				cReadModeA = 0;
				break;
			/*
			case 33:
				// m_cLU_Vit
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cLU_Vit = atoi(token);
				cReadModeA = 0;
				break;

			case 34:
				// m_cLU_Dex
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cLU_Dex = atoi(token);
				cReadModeA = 0;
				break;

			case 35:
				// m_cLU_Int
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cLU_Int = atoi(token);
				cReadModeA = 0;
				break;

			case 36:
				// m_cLU_Mag
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cLU_Mag = atoi(token);
				cReadModeA = 0;
				break;

			case 37:
				// m_cLU_Char
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_cLU_Char = atoi(token);
				cReadModeA = 0;
				break;
*/
			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iRewardGold = atoi(token);
				cReadModeA = 0;
				break;

			case 41:
				// Skill-SSN
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != NULL) {
					ZeroMemory(m_pClientList[ iClientH ]->m_cProfile, sizeof(m_pClientList[ iClientH ]->m_cProfile));
					strncpy(m_pClientList[ iClientH ]->m_cProfile, token, sizeof(m_pClientList[ iClientH ]->m_cProfile)-1);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

				case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iAdminUserLevel = 0; //Default it to 0
				if (atoi(token) > 0) {
				for (i = 0; i < DEF_MAXADMINS; i++) {
					if(strlen(m_stAdminList[ i ].m_cGMName) == 0) break; //No more GM's on list
						if ((strlen(m_stAdminList[ i ].m_cGMName)) == (strlen(m_pClientList[ iClientH ]->m_cCharName))) {
							if(memcmp(m_stAdminList[ i ].m_cGMName,m_pClientList[ iClientH ]->m_cCharName,strlen(m_pClientList[ iClientH ]->m_cCharName)) == 0){
								m_pClientList[ iClientH ]->m_iAdminUserLevel = atoi(token);
								break; //Break goes to cReadModeA = 0;, so no need to do it again
							}
						}
					}
				}
				cReadModeA = 0;
				break;
				
			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iRating = atoi(token);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				if (m_pClientList[ iClientH ]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[ iClientH ]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
			case 1:
				// Penalty Block Year
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iPenaltyBlockYear = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// Penalty Block Month
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iPenaltyBlockMonth = atoi(token);

				cReadModeB = 3;
				break;

			case 3:
				// Penalty Block day
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iPenaltyBlockDay = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iContribution = atoi(token);

				   // Contribution Code By kr4usser
					if(m_pClientList[iClientH]->m_iContribution <= 500)
					{
						m_pClientList[iClientH]->m_iContribution = 2000;
					}
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_bIsQuestCompleted = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iSpecialEventID = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 67:
				switch (cReadModeB) {
			case 1:
				// FightZone Number
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iFightzoneNumber = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iReserveTime = atoi(token);


				cReadModeB = 3;
				break;
			case 3:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[ iClientH ]->m_iFightZoneTicketNumber = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;

				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iSuperAttackLeft = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				ZeroMemory(m_pClientList[ iClientH ]->m_cLockedMapName, sizeof(m_pClientList[ iClientH ]->m_cLockedMapName));
				strncpy(m_pClientList[ iClientH ]->m_cLockedMapName, token, sizeof(m_pClientList[ iClientH ]->m_cLockedMapName)-1);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 78:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iDeadPenaltyTime = atoi(token);
				cReadModeA = 0;
				break;

			case 79: // v2.06 12-4
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iPartyID = atoi(token);
				if (m_pClientList[ iClientH ]->m_iPartyID != NULL) m_pClientList[ iClientH ]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				cReadModeA = 0;
				break;

			case 80:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[ iClientH ]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[ iClientH ]->m_iGizonItemUpgradeLeft = atoi(token);
				if( m_pClientList[ iClientH ]->m_iGizonItemUpgradeLeft < 0) m_pClientList[ iClientH ]->m_iGizonItemUpgradeLeft = 0;
				cReadModeA = 0;
				break;
			}
		}
		else {
			if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[ iClientH ]->m_pItemList[ iItemIndex ] = new class CItem;
			}
			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[ iClientH ]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}
			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;
			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;
			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}
			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;
			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;
			if (memcmp(token, "character-LU_Pool", 17) == 0)     cReadModeA = 32;
			/*
			if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
			if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;
			*/
			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;
			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;
			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;
			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;
			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 15) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 15) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-quest-number",22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)	 cReadModeA = 57;
			if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 60;
			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;
			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;
			if (memcmp(token, "reserved-fightzone-id", 21) == 0)	{
				cReadModeA = 67;
				cReadModeB = 1;
			}
			if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72; 
			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;
			if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0)           cReadModeA = 79;
			if (memcmp(token, "gizon-item-upgade-left", 22) == 0) cReadModeA = 80;
			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}
		token = pStrTok->pGet();
	}													  

DPDC_STOP_DECODING:;	

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[ iClientH ]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);
		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@
		return FALSE;
	}


	// verified all data below
	bRet = m_pMapList[m_pClientList[ iClientH ]->m_cMapIndex]->bIsValidLoc(m_pClientList[ iClientH ]->m_sX, m_pClientList[ iClientH ]->m_sY);
	if (bRet == FALSE) {
		GetMapInitialPoint(m_pClientList[ iClientH ]->m_cMapIndex, &m_pClientList[ iClientH ]->m_sX, &m_pClientList[ iClientH ]->m_sY, m_pClientList[ iClientH ]->m_cLocation);
	}
	if ((m_pClientList[ iClientH ]->m_iLU_Pool > 255) || (m_pClientList[ iClientH ]->m_iLU_Pool < 0)) return FALSE;
	if ((m_pClientList[ iClientH ]->m_iStr < 10) || (m_pClientList[ iClientH ]->m_iStr > DEF_CHARPOINTLIMIT)) return FALSE;
	if ((m_pClientList[ iClientH ]->m_iDex < 10) || (m_pClientList[ iClientH ]->m_iDex > DEF_CHARPOINTLIMIT)) return FALSE;
	if ((m_pClientList[ iClientH ]->m_iVit < 10) || (m_pClientList[ iClientH ]->m_iVit > DEF_CHARPOINTLIMIT)) return FALSE;
	if ((m_pClientList[ iClientH ]->m_iInt < 10) || (m_pClientList[ iClientH ]->m_iInt > DEF_CHARPOINTLIMIT)) return FALSE;
	if ((m_pClientList[ iClientH ]->m_iMag < 10) || (m_pClientList[ iClientH ]->m_iMag > DEF_CHARPOINTLIMIT)) return FALSE;
	if ((m_pClientList[ iClientH ]->m_iCharisma < 10) || (m_pClientList[ iClientH ]->m_iCharisma > DEF_CHARPOINTLIMIT)) return FALSE;
	char cStatPointTotal;
	cStatPointTotal = m_pClientList[ iClientH ]->m_iStr + m_pClientList[ iClientH ]->m_iDex + m_pClientList[ iClientH ]->m_iVit +
		m_pClientList[ iClientH ]->m_iInt + m_pClientList[ iClientH ]->m_iMag + m_pClientList[ iClientH ]->m_iCharisma;
	if (m_pClientList[ iClientH ]->m_iLU_Pool < 3) m_pClientList[ iClientH ]->m_iLU_Pool = 3;
	if ((cStatPointTotal + (m_pClientList[ iClientH ]->m_iLU_Pool-3)) != ((m_pClientList[ iClientH ]->m_iLevel-1)*3 + 70)) {
		if (cStatPointTotal > ((m_pClientList[ iClientH ]->m_iLevel-1)*3 + 70)) return FALSE;
		m_pClientList[ iClientH ]->m_iLU_Pool = ((m_pClientList[ iClientH ]->m_iLevel-1)*3 + 73) - ((m_pClientList[ iClientH ]->m_iStr + m_pClientList[ iClientH ]->m_iDex + m_pClientList[ iClientH ]->m_iVit + m_pClientList[ iClientH ]->m_iInt + m_pClientList[ iClientH ]->m_iMag + m_pClientList[ iClientH ]->m_iCharisma));
	}
	if ((m_Misc.bCheckValidName(m_pClientList[ iClientH ]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[ iClientH ]->m_cAccountName) == FALSE)) 
		return FALSE;
	if (m_pClientList[ iClientH ]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[ iClientH ]->m_iPenaltyBlockYear*10000 + m_pClientList[ iClientH ]->m_iPenaltyBlockMonth*100 + m_pClientList[ iClientH ]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}
	if (m_pClientList[ iClientH ]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[ iClientH ]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[ iClientH ]->m_iFightzoneNumber = 0; 
			m_pClientList[ iClientH ]->m_iReserveTime = 0;
			m_pClientList[ iClientH ]->m_iFightZoneTicketNumber = 0;
		}
	}
	if (m_pClientList[ iClientH ]->m_iAdminUserLevel < 0) m_pClientList[ iClientH ]->m_iAdminUserLevel = 0;
	if (m_pClientList[ iClientH ]->m_cSex == 1) {
		sTmpType = 1;
	}
	else if (m_pClientList[ iClientH ]->m_cSex == 2) {
		sTmpType = 4; 
	}
	switch (m_pClientList[ iClientH ]->m_cSkin) {
	case 1:
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}
	if (m_pClientList[ iClientH ]->m_iAdminUserLevel >= 10) sTmpType = m_pClientList[ iClientH ]->m_iAdminUserLevel;
	sTmpAppr1 = (m_pClientList[ iClientH ]->m_cHairStyle << 8) | (m_pClientList[ iClientH ]->m_cHairColor << 4) | (m_pClientList[ iClientH ]->m_cUnderwear);
	m_pClientList[ iClientH ]->m_sType  = sTmpType;
	m_pClientList[ iClientH ]->m_sAppr1 = sTmpAppr1;
	iCalcTotalWeight(iClientH);
	if (m_pClientList[ iClientH ]->m_sCharIDnum1 == 0) {
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;
		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[ iClientH ]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[ iClientH ]->m_cCharName[_i] ^ m_pClientList[ iClientH ]->m_cCharName[_i]);
		}
		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 
		m_pClientList[ iClientH ]->m_sCharIDnum1 = _sID1;
		m_pClientList[ iClientH ]->m_sCharIDnum2 = _sID2;
		m_pClientList[ iClientH ]->m_sCharIDnum3 = _sID3;
	}
	m_pClientList[ iClientH ]->m_iRewardGold += iNotUsedItemPrice;
	m_pClientList[ iClientH ]->m_iSpeedHackCheckExp = m_pClientList[ iClientH ]->m_iExp;
	return TRUE;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{

 char sql[256] ;
 char  cTxt[120], cTmp[21];
 char  * cp;
 
 int   i, * ip;
 short * sp, * pIDX ;
 short Skillidx,Itemidx,BankItemidx ;
 int   iFlag = 0 ;
 BOOL	bFind = FALSE ;
 DWORD * dwp, dTemp;

	if (m_pClientList[iClientH] == NULL) return 0;

	cp = pData ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sCharIDnum1 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sCharIDnum2 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sCharIDnum3 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iLevel ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iStr ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iVit ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iDex ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iInt ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iMag ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iCharisma ;
	cp += 2 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iExp ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iLU_Pool ;
	cp += 4 ;

/*	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Str ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Vit ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Dex ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Int ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Mag ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cLU_Char ;
	cp += 2 ;
*/

	*cp = (char) m_pClientList[iClientH]->m_cSex ;
	cp++ ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cSkin ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cHairStyle ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cHairColor ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_cUnderwear ;
	cp += 2 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iApprColor ;
	cp += 4 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr1 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr2 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr3 ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sAppr4 ;
	cp += 2 ;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10 ) ;
	cp += 10 ;

	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10 ) ;
	cp += 10 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sX ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_sY ;
	cp += 2 ;

	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		strcpy(cp, "__________");
	}
	else strcpy(cp, m_pClientList[iClientH]->m_cProfile) ;

	cp += 100 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iAdminUserLevel ;
	cp += 2 ;

	if (m_pClientList[iClientH]->m_iContribution < 0) m_pClientList[iClientH]->m_iContribution = 0;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iContribution ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iSpecialAbilityTime ;
	cp += 4 ;

	memcpy(cp, m_pClientList[iClientH]->m_cLockedMapName, 10) ;
	cp += 10 ;

	ip = (int *) cp ;
	*ip = (int) m_pClientList[iClientH]->m_iLockedMapTime ;
	cp += 4 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iPenaltyBlockYear ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iPenaltyBlockMonth ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iPenaltyBlockDay ;
	cp += 2 ;

	
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
	// GuildRank가 -1이면 길드이름은 무의미하다.
		memcpy(cp, m_pClientList[iClientH]->m_cGuildName,20);
	}
	else strcpy(cp, "NONE");
	cp += 20 ;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank가 -1이면 길드GUID는 무의미하다.
		ip  = (int *)cp;
		*ip = (int) m_pClientList[iClientH]->m_iGuildGUID;
	} else 	{
		ip  = (int *)cp;
		*ip = (int) -1 ;
	}
	cp += 4 ; 

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iGuildRank ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iFightzoneNumber ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iReserveTime ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iFightZoneTicketNumber ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short)  m_pClientList[iClientH]->m_iQuest ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iQuestID ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iCurQuestCount ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iQuestRewardType ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iQuestRewardAmount ;
	cp += 2 ;
	
	*cp = (char ) m_pClientList[iClientH]->m_bIsQuestCompleted ;
	cp ++ ; 

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iSpecialEventID ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int)  m_pClientList[iClientH]->m_iWarContribution ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iCrusadeDuty ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_dwCrusadeGUID ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iConstructionPoint ;
	cp += 4 ;


	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iRating ;
	cp += 4 ;

	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);	
	
	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iHP ;
	cp += 4 ;

	if (m_pClientList[iClientH]->m_iMP <= 0)  
		m_pClientList[iClientH]->m_iMP = 30;	

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iMP ;
	cp += 4 ;

	if (m_pClientList[iClientH]->m_iSP < 0) 
		m_pClientList[iClientH]->m_iSP = 20;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iSP ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iEnemyKillCount ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iPKCount ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iRewardGold ;
	cp += 4 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iHungerStatus ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iSuperAttackLeft ;
	cp += 2 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_ShutUp ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_Rating ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_ForceRecall ;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar;
	cp += 4 ;

	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iDeadPenaltyTime ;
	cp += 4 ;

	// V2.1 성후니 파티제를 위해서 추가 
	ip  = (int *)cp;
	*ip = (int) m_pClientList[iClientH]->m_iPartyID ;
	cp += 4 ;
	
	// v2.15 지존 패치를 위해 추가 
	ip = (int * )cp ;
	*ip = (int) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft ;
	cp += 4 ;

	ZeroMemory(cTxt, sizeof(cTxt)) ;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTmp,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(cTxt, cTmp);
	}

	memcpy(cp, cTxt, 100) ;
	cp += 100 ;

	sp  = (short *)cp;
	*sp = (short) m_pClientList[iClientH]->m_iDownSkillIndex; ;
	cp += 2 ; 

	pIDX = (short *) cp ;
	cp += 2;

	Skillidx = 0;
	
	for( i = 0 ; i < 60 ; i++ ) {
		if ( m_pClientList[iClientH]->m_cSkillMastery[i] > 0 ) {
			sp = (short *) cp ;
			*sp = (short) i ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_cSkillMastery[i] ;
			cp += 2 ;
				
			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_iSkillSSN[i] ;
			cp += 4 ;

			Skillidx++;
		}
	}

	*pIDX = (short) Skillidx ;

	Itemidx = 0;

	pIDX = (short *) cp ;
	cp += 2;
			
	for (i = 0; i < DEF_MAXITEMS; i++){
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

			memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName,20);
			cp += 20 ;

			dwp = (DWORD *) cp ;
			*dwp = (DWORD ) m_pClientList[iClientH]->m_pItemList[i]->m_dwCount ;
			cp += 4 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 ;
			cp += 2 ;
			
			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3 ;
			cp += 2 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan ;
			cp += 4 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute ;
			cp += 4 ;

			*cp = (char) m_pClientList[iClientH]->m_bIsItemEquipped[i] ;
			cp ++ ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_ItemPosList[i].x ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_ItemPosList[i].y ;
			cp += 2 ;

			Itemidx++;
		}
	}

	// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
	*cp = (char) m_pClientList[iClientH]->m_bIsBankModified ;
	cp ++ ;

	*pIDX = (short) Itemidx ;
	pIDX = (short *) cp ;
	cp += 2;

	BankItemidx = 0;

	for (i = 0; i < DEF_MAXBANKITEMS; i++) {

		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
			memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
			cp += 20 ;

			dwp = (DWORD *) cp ;
			*dwp = (DWORD ) m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount ;
			cp += 4 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType ;
			cp += 2 ; 

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3;
			cp += 2 ;
			
			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2 ;
			cp += 2 ;

			sp = (short *) cp ;
			*sp = (short) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3 ;
			cp += 2 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan ;
			cp += 4 ;

			ip = (int *) cp ;
			*ip = (int) m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute ;
			cp += 4 ;
	
			BankItemidx++;
		}
	}

	*pIDX = (short) BankItemidx ;

	iFlag +=  m_pClientList[iClientH]->m_sCharIDnum1 + m_pClientList[iClientH]->m_iGuildGUID + m_pClientList[iClientH]->m_iDownSkillIndex + Skillidx + Itemidx + BankItemidx ;

//	ip = (int *) cp ;
//	*ip = (int) iFlag ;
	
	return (582 + 4 + 8*Skillidx + 2 + 55*Itemidx + 2 + 50*BankItemidx +4  ) ;
}

#else // FILE_MODE

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
 char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
 char   seps[] = "= \t\n";
 char   cReadModeA, cReadModeB;
 int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
 class  CStrTok * pStrTok;
 short  sTmpType, sTmpAppr1;
 BOOL   bRet;
 int    iTemp;
 SYSTEMTIME SysTime;
 __int64 iDateSum1, iDateSum2;
 BOOL   bIsNotUsedItemFound = FALSE;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// 소지품 검사용 
	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;

	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				// 플레이어가 속해있는 맵 이름을 얻는다. 
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				strcpy(m_pClientList[iClientH]->m_cMapName, token);
				// 이제 이 맵의 인덱스값을 찾아 할당한다. 
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, token);
				for (i = 0; i < DEF_MAXMAPS; i++)
				if ((m_pMapList[i] != NULL)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
					// 맵의 인덱스는 i이다.
					m_pClientList[iClientH]->m_cMapIndex = (char)i;
				}
				
				if (m_pClientList[iClientH]->m_cMapIndex == -1) {
					// 만약 플레이어가 속한 맵이 존재하지 않는다면 (이런 경우는 발생하기 힘들다. 로그 서버에서 먼저 검색한 후 접속하기 때문)
					wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				cReadModeA = 0;
				break;

			case 2:
				// 플레이어의 맵상의 위치 X
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				// 플레이어의 맵상의 위치 Y
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				// 플레이어의 계정 상태를 얻는다. <- 이 기능은 현재 쓰지 않는다. 계정정보는 별도로 전달되므로 
				/*
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cAccountStatus = atoi(token);
				*/
				cReadModeA = 0;
				break;
			
			case 5:
				// 소지하고 있는 아이템 정보를 읽어 초기화 한다.
				switch(cReadModeB) {
				case 1:
					// v2.12
					if (iItemIndex >= DEF_MAXITEMS) {
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					// token값은 아이템의 이름. 이 이름을 가진 아이템의 특성을 m_pItemConfigList에서 찾아 할당한다.
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
						// 플레이어가 소지한 아이템이 리스트에 없다. 에러
						wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
						PutLogList(cTxt);
						
						// Debug code @@@@@@@@@@@@@@@
						HANDLE hFile;
						DWORD  nWrite;
						hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
						WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, NULL);
						CloseHandle(hFile);
						///////////// @@@@@@@@@@@@@@@
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					// m_dwCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					// 갯수가 마이너스이면 1으로 세팅된다.
					iTemp = atoi(token);
					if (iTemp < 0) iTemp = 1;
					//만약 중량이 초과되었다면 1개로 줄인다.
					if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
						iTemp = 1;
						wsprintf(G_cTxt, "(!) 캐릭터(%s) 아이템(%s) 개수 오버플로우", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName);
						PutLogFileList(G_cTxt);
						PutLogList(G_cTxt);
					 }
					
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
					cReadModeB = 3;

					// v1.3 소지하고 있는 골드의 총 합을 검사한다. 
					if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
						iTotalGold += iTemp;
					break;

				case 3:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sItemSpecEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sItemSpecEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sItemSpecEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_wCurLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);
					
					cReadModeB = 12;
					break;
							   
				case 12:
					// m_dwAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);
					
					// v1.4 개인 고유 아이템을 확인한다. 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
						if ( (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
							 (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
							 (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
							// 자신의 것이 아닌 아이템을 갖고 있다. 
						/*	wsprintf(cTxt, "(!) 다른 사람의 아이템 소지: Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
								     m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
									 m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
									 m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
									 m_pClientList[iClientH]->m_sCharIDnum1,
									 m_pClientList[iClientH]->m_sCharIDnum2,
									 m_pClientList[iClientH]->m_sCharIDnum3); 
							PutLogList(cTxt);*/
							//PutLogFileList(cTxt);
						}
					}
					
					cReadModeA = 0;
					cReadModeB = 0;

					// v1.41 아이템이 Custom-Made라면 설정치를 재조정한다. 
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001 ) != NULL) {
						// 최대 수명이 ItemSpecialEffectValue1
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
						// 무기나 방어구의 경우 가중치 ItemSpecialEffectValue2
					}

					// v2.16 2002-6-11 고광현수정 
					int iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue > 0) {
						// 업그레이드 된 아이템. 방어구나 방패라면 최대 수명을 ItemSpecialEffectValue1로 설정한다.
						switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
						case 5: // 방패 
						case 6: // 방어구 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
							break;
						}
					}

					// v1.42 희귀 아이템 플래그가 설정되어 있다면 최대 수명, 스피드, 무게 등을 재설정 해야 한다. 
					_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

					// v1.41 현재 수명 최대 수명을 능가하면 버그이므로 되돌린다.
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan)
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) && 
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {

						wsprintf(G_cTxt, "(!) character (%s) have the GemStone of Sacrifice to lifespan 0 !", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					// v2.05 +대미지류 아이템 특성치로 정보 변경, 변환 
					bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);

					// v1.4 이제 이 아이템이 현재 사용이 인정된 아이템인가를 찾는다. 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

						// v1.41
						bIsNotUsedItemFound = TRUE;
					}
					else
					if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) == TRUE) {
						// v1.42 복제된 아이템들을 삭제한다.
						_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					}
					else iItemIndex++;
					break;
				}
				break;
			
			case 6:
				// 캐릭터의 성별 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;
			
			case 7:
				// 캐릭터의 피부색 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:
				// 캐릭터의 헤어 스타일 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9:
				// 캐릭터의 머리색 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10:
				// 캐릭터의 속옷색
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				// 아이템 장착 상태가 반드시 마지막이어야 한다!!!!!
				
				// 아이템 장착 상태 초기화한 후 설정한다.
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

				// 아이템 장착상태를 초기화한다.
				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

				// v1.41 사용하지 않는 아이템을 소지하고 있었다면 장착상태를 모두 무시. 
				if (bIsNotUsedItemFound == FALSE) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[i]);
						if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
							// 장착될 수 있는 성질의 아이템이라면 장착 
							if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								 m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
							else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
						}
						else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
							// 아이템이 장착되어 있다면 장착 효과를 계산한다.
							if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; // 만약 특성치 변동으로 장착된 아이템이 장착되지 않아야 한다면 장착 안한것을 표시 
						}
					}
				}

				cReadModeA = 0;
				break;
			
			case 12:
				// 소속 길드이름을 초기화한다.
				// 길드 이름은 최대 20자 
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, token);
				cReadModeA = 0;
				break;

			case 13:
				// 길드 랭크 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14:
				// HP 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15:
				// DefenseRatio 사용하지 않는다. 무의미해 짐 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginDefenseRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurDefenseRatio = m_pClientList[iClientH]->m_iOriginDefenseRatio;
				cReadModeA = 0;
				break;

			case 16:
				// HitRatio  사용하지 않는다. 무의미해 짐 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginHitRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurHitRatio = m_pClientList[iClientH]->m_iOriginHitRatio;
				cReadModeA = 0;
				break;

			case 17:
				// Level  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 18:
				// Str 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19:
				// Int 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20:
				// Vit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21:
				// Dex 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22:
				// Mag 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23:
				// Charisma 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24:
				// Luck 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25:
				// Exp 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iExp = atoi(token);
				cReadModeA = 0;
				break;
			
			case 26:
				// Magic-Mastery 설정한다. // 0이면 사용 불가. 1이면 배운 상태.
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
				}
				cReadModeA = 0;
				break;

			case 27:
				// Skill-Mastery 설정한다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;
			//
			case 28:
				// Warehouse에 맡겨논 아이템 정보를 읽어 초기화 한다.
				switch(cReadModeB) {
				case 1:
					// v2.12
					if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					// token값은 아이템의 이름. 이 이름을 가진 아이템의 특성을 m_pItemConfigList에서 찾아 할당한다.
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
						// 플레이어가 저장하고 있는 아이템이 리스트에 없다. 에러
						wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
						PutLogList(cTxt);
						
						// Debug code @@@@@@@@@@@@@@@
						HANDLE hFile;
						DWORD  nWrite;
						hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
						WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, NULL);
						CloseHandle(hFile);
						///////////// @@@@@@@@@@@@@@@
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					// m_dwCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					// 갯수가 마이너스이면 1으로 세팅된다.
					iTemp = atoi(token);
					if (iTemp < 0) iTemp = 1;

					// 만약 가질 수 있는 중량이 초과된 아이템이 있다면 1개로 줄인다.
					if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
						iTemp = 1;
						wsprintf(G_cTxt, "(!) 캐릭터(%s) 아이템(%s) 개수 오버플로우", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName);
						PutLogFileList(G_cTxt);
						PutLogList(G_cTxt);
					}

					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
					cReadModeB = 3;

					// v1.3 소지하고 있는 골드의 총 합을 검사한다. 
					if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
						iTotalGold += iTemp;
					break;

				case 3:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sItemSpecEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sItemSpecEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sItemSpecEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_wCurLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);
					
					cReadModeB = 12;
					break;
							   
				case 12:
					// m_dwAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					// v1.41 아이템이 Custom-Made라면 설정치를 재조정한다. 
					if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != NULL) {
						// 최대 수명이 ItemSpecialEffectValue1
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
						// 무기나 방어구의 경우 가중치 ItemSpecialEffectValue2
				
					}

					// v2.16 2002-5-21 고광현수정 
					int iValue = (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue > 0) {
						// 업그레이드 된 아이템. 방어구나 방패라면 최대 수명을 ItemSpecialEffectValue1로 설정한다.
						switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
						case 5: // 방패 
						case 6: // 방어구 
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
							break;
						}
					}

					// v1.42 희귀 아이템 플래그가 설정되어 있다면 최대 수명, 스피드, 무게 등을 재설정 해야 한다. 
					_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

					// v1.41 수명이 최대수명을 초과한다면 버그이므로 되돌린다.
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;

					// v1.433
					if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) && 
						(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						// 로그 남긴다. 
						wsprintf(G_cTxt, "(!) character (%s) have the GemStone of Sacrifice to lifespan 0 !", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						// 수명 1로 환원 
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
					}
					
					// v1.4 이제 이 아이템이 현재 사용이 인정된 아이템인가를 찾는다. 
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
					}
					else 
					if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) == TRUE) {
						// v1.42 복제된 아이템들을 삭제한다.
						_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;		
					}
					else iItemInBankIndex++;
					break;
				}
				break;
			//
			case 29:
				// 플레이어 소속의 마을을 초기화한다.
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				cReadModeA = 0;
				break;

			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;
			
			case 31:
				// m_iSP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32:
				// m_cLU_Pool
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
				cReadModeA = 0;
				break;
				
			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRewardGold = atoi(token);
				cReadModeA = 0;
				break;

			case 41:
				// Skill-SSN 설정한다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != NULL) {
					ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
					strcpy(m_pClientList[iClientH]->m_cProfile, token);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status 설정한다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

			case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRating = atoi(token);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID: 이전에 생성되었던 길드들은 모두 -1이 되 버릴 것이다.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				// v1.3 잘못된 위치값을 보정한다. 
				if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
				case 1:
					// Penalty Block Year
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Penalty Block Month
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					// Penalty Block day
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iSpecialEventID = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			// v1.4311-3 추가 사투장 예약에 관계된 파일 내용 읽기 
			case 67:
				switch (cReadModeB) {
				case 1:
					// FightZone Number
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 예약한 시간 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iReserveTime = atoi(token);
					
					
					cReadModeB = 3;
					break;
				case 3:
					// 남은 티켓숫자 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				
				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				
				m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 78:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
				cReadModeA = 0;
				break;

			case 79: // v2.06 12-4
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iPartyID = atoi(token);
				if (m_pClientList[iClientH]->m_iPartyID != NULL) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				cReadModeA = 0;
				break;

			case 80: // v2.15 지존아이템업그레이드
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
				cReadModeA = 0;
				break;
			case 81: 
				if (strlen(token) > 21) {
					strcpy(token,m_pClientList[iClientH]->m_cIPaddress);	
				}
				ZeroMemory(m_pClientList[iClientH]->m_cIP2, sizeof(m_pClientList[iClientH]->m_cIP2));
				strcpy(m_pClientList[iClientH]->m_cIP2, token);
				cReadModeA = 0;
				break;

			case 82:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_dwHeldenianGUID = atoi(token);
				cReadModeA = 0;
				break;

			}
		}
		else {
			if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}
			
			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}

			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;
			
			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;
			
			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}
			
			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;

			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;

			if (memcmp(token, "character-LU_Pool", 17) == 0)    cReadModeA = 32;
			/*if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
    	if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;*/

			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;
			
			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;
			
			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;

			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;

			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 15) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 15) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}

			if (memcmp(token, "character-quest-number",22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)	 cReadModeA = 57;
		
			if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 60;

			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;

			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;

			// v1.4311-3 추가 월드 서버로 부터온 메세지로부터 예약된 사투장에 관한 값 읽기 reserved-fightzone-id
			if (memcmp(token, "reserved-fightzone-id", 21) == 0) {
				cReadModeA = 67;
				cReadModeB = 1;
			}

			if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72; 
					
			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;
			if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0)           cReadModeA = 79; // v2.06 12-4
			if (memcmp(token, "gizon-item-upgade-left", 22) == 0) cReadModeA = 80; // v2.15 지존아이템업그레이드
            if (memcmp(token, "ip-muerte", 9)== 0) cReadModeA = 81; 
			if (memcmp(token, "heldenian-GUID", 14) == 0)    cReadModeA = 82;
			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}
		
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );							    
	}													  

DPDC_STOP_DECODING:;	
#ifdef DEF_HIGH
			
#endif
	delete pStrTok;
	delete []pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);
		
		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@
		
		return FALSE;
	}
	
	// 읽혀진 플레이어 데이터를 검사해서 오류가 없는지를 확인하여 리턴값을 결정한다.
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
		/*
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
			PutLogList(cTxt);
			return FALSE;
		}
		*/
	}

	// 특성치 값에 오류가 있는지 검사 ==========================================================================
	if ((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > DEF_CHARPOINTLIMIT))
		return FALSE;	

	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
		return FALSE;

	// v1.4 계정이름이나 캐릭터 이름에 잘못된 코드가 들어가 있다면 접속 불가.
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) 
		return FALSE;

	// v1.4 징계 먹은 캐릭터의 징계기간 안이면 접속 불가
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}

	// v1.4311-3 추가 유효하지 않은 사투장 예약을 가지고 있으면 초기화 
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			// 예약이 취소됨 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}

	// v1.42 잘못 입력된 운영자 레벨 값을 클리어 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

	// ============================================================================================================


	// 내용을 바탕으로 Appearance를 계산, 할당한다.
	if (m_pClientList[iClientH]->m_cSex == 1) {
		// 남자이다. 
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		// 여자이다.
		sTmpType = 4; 
	}

	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		// 백인이면 그대로.
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}

	// v1.41 운영자 암행용 
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) 
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	// 소지품 총 중량계산 
	iCalcTotalWeight(iClientH);

	// v1.3 지나치게 많은 돈을 소지한 캐릭터 이름을 적는다. 
	//if (iTotalGold > 800000) {
	//	wsprintf(G_cTxt, "(!) 해킹 용의자(%s) Gold(%d)", m_pClientList[iClientH]->m_cCharName, iTotalGold);
		//PutLogFileList(G_cTxt);
	//}

	// v.135 
	/*
	if ((m_pClientList[iClientH]->m_cSkillMastery[0] >= 70) || (m_pClientList[iClientH]->m_cSkillMastery[1] >= 70) ||
		(m_pClientList[iClientH]->m_cSkillMastery[12] >= 70)) {
		wsprintf(G_cTxt, "(!) 해킹 용의자(%s) 높은 스킬 (%d %d %d)", m_pClientList[iClientH]->m_cCharName, 
			             m_pClientList[iClientH]->m_cSkillMastery[0], m_pClientList[iClientH]->m_cSkillMastery[1],
						 m_pClientList[iClientH]->m_cSkillMastery[12]);
		PutLogFileList(G_cTxt);
	}
	*/
	
	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		// v1.3 이 캐릭터의 ID 번호가 부여되지 않은 상태이다. 할당한다. 
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}
		
		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 
				
		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	// v1.4 없어진 아이템에 대한 보상금을 지급. 
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;

	// 
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;


	return TRUE;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
 SYSTEMTIME SysTime;
 char  cTxt[120], cTmp[21];
 POINT TempItemPosList[DEF_MAXITEMS];
 int   i, iPos;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");
		
	// 쨍짠 첬책
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	// 쨀쨍짱 쨌 
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		// 쨀쨍짱 쨌 쩌쨀짚쨉철 쩐쩐쨈쨍챕 
		strcat(pData, "__________");
	}
	else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");

	// 쨌쨔쩐챤 쩌쩌 짠징
	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");

	/// 짹챈쨉책 쨩처 
	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank째징 -1쨍챕 짹챈쨉책쨍짠쨘 쨔짬쨔쨈.
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	}
	else strcat(pData, "NONE");
	strcat(pData, "\n");
	
	// 짹챈쨉책 GUID 
	strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank째징 -1쨍챕 짹챈쨉책GUID쨈 쨔짬쨔쨈.
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	}
	else strcat(pData, "-1");
	strcat(pData, "\n");
		
	// 짹챈쨉책 쩌첩짠
	strcat(pData, "character-guild-rank = ");
	itoa( m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	// X짜 첬책 
	strcat(pData, "character-loc-x   = ");
	itoa( m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// Y짜 첬책 
	strcat(pData, "character-loc-y   = ");
	itoa( m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	//
	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH); 

	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MP       = %d",  m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d",  m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Pool  = %d", m_pClientList[iClientH]->m_iLU_Pool);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*	
	wsprintf(cTxt, "character-LU_Str   = %d", m_pClientList[iClientH]->m_cLU_Str);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Vit   = %d", m_pClientList[iClientH]->m_cLU_Vit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Dex   = %d", m_pClientList[iClientH]->m_cLU_Dex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Int   = %d", m_pClientList[iClientH]->m_cLU_Int);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Mag   = %d", m_pClientList[iClientH]->m_cLU_Mag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Char  = %d", m_pClientList[iClientH]->m_cLU_Char);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	*/
	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-reward-gold = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*
	wsprintf(cTxt, "party-rank = %d", m_pClientList[iClientH]->m_iPartyRank);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum1 = %d", m_pClientList[iClientH]->m_sPartyIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum2 = %d", m_pClientList[iClientH]->m_sPartyIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum3 = %d", m_pClientList[iClientH]->m_sPartyIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");
	*/

	//
	// 쨌쨔쩐챤 짱쩌쨘징 쨌 
	strcat(pData, "sex-status       = ");
	itoa( m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa( m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa( m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa( m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa( m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "admin-user-level = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "penalty-block-date = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-completed = %d", (int)m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "special-event-id = %d", (int)m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "super-attack-left = %d", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v1.4311-3 째징 쩔첫쨉책쩌짯쨔철쩔징 쨩챌천책 째체쨌 쨘짱쩌철쨍짝 쨘쨍쨀쩍쨈.
	// 쨩챌천책 쩔쨔쩐 째체쨌쨉 쨀쨩쩔챘 첬책 reserved-fightzone-id 쩔쨔쩐쨉 쨩챌천책쨔첩짙/쨀짱짜쨔쩍째짙/쨀짼쨘쩌째쨔쩌철
	wsprintf(cTxt, "reserved-fightzone-id = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime,m_pClientList[iClientH]->m_iFightZoneTicketNumber  );
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 짱쩌철 쨈쨌 쨔쩔챘 쨀짼쨘 쩍째짙
	wsprintf(cTxt, "special-ability-time = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 찼짹채 쨍 쨍짠
	wsprintf(cTxt, "locked-map-name = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 찼짹채 쨍 쩍째짙
	wsprintf(cTxt, "locked-map-time = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 짤쨌챌쩌쩌쨉책쩔징쩌짯 쨍쨘 첨짜.
	wsprintf(cTxt, "crusade-job = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// 짤쨌챌쩌쩌쨉책 째챠짱 쩐쨉챨 
	wsprintf(cTxt, "crusade-GUID = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "construct-point = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.04 쨩챌쨍쩍 채쨀쩌 쨍 
	wsprintf(cTxt, "dead-penalty-time = %d", m_pClientList[iClientH]->m_iDeadPenaltyTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.06 12-4 쩌 쩐쨉챨
	wsprintf(cTxt, "party-id = %d", m_pClientList[iClientH]->m_iPartyID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.15 철쨍쩐쩐첨짹쨌쨔쨉책
	wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	strcat(pData, "ip-muerte = ");
    strcat(pData, m_pClientList[iClientH]->m_cIP2);
    strcat(pData, "\n");
	
	/*wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");*/

	strcat(pData,"\n\n");

	// 쨀쨍짱 쩔체짜철 Appr4째쨀쨍짝 첬책쨈. 째쨘 째쩌짯쨔철쩔징쩌짯쨈 쨩챌쩔챘철 쩐쨍쨍챌 쨌짹쩌짯쨔철->짭쨋처쩐챨짰째짙쩔징 쨩챌쩔챘쨉쨈.
	strcat(pData, "appr1 = ");
	itoa( m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	// 체천쨍챨쨉책 쨌징짹쨍짝 짭쨍짰쩐챤쨈.
	//m_pClientList[iClientH]->m_sAppr2 = m_pClientList[iClientH]->m_sAppr2 & 0x0FFF;
	itoa( m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa( m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa( m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa( m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	// 쩐 짚쨘쨍 첬책 
	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
		TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;

	// 째짖째짖 쩐쨩 첬책쨈.
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		// v1.4 쩐 쩌첩쩌짯쨍짝 챌쨔챔징쨈. 
		TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
		TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
		iPos++;
		
		strcat(pData, "character-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	// v1.4 챌 째챔쨩챗쨉 쩐 짠징 짹창쩐챦 
	for (i = 0; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
		strcat(pData, "character-bank-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	
	strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData,"\n");

	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "skill-mastery     = ");				
	
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

		strcat(pData, cTxt); // 쳉짹창째짧 쳉쨌
	}
	strcat(pData,"\n");
			
	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

		strcat(pData, cTxt); // 쳉짹창째짧 쳉쨌
	}
	strcat(pData,"\n");
	
	// 쩐 책첩 쨩처쨍짝 첬책쨈. 쨔쨉책쩍 쨍 쨍쨋철쨍쨌쩔징 쩐챤쩐 .
	strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
	strcat(pData, "item-equip-status = ");
	
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");
	              
	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) && 
			(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
			 cTxt[iEP] = '1';
		}
		iEP++;
	}
	strcat(pData, cTxt);
	strcat(pData, "\n");

	
	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");
	
	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");

	return strlen(pData);
}
#endif


BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemConfigListIndex, iTemp;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok( pContents, seps );   
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iItemConfigListIndex = atoi(token);
					
					//testcode
					if (iItemConfigListIndex == 490)
						iItemConfigListIndex = atoi(token);
					
					// 만약 이미 이런 아이 값을 가진 아이템이 정의되어 있다면 에러이다.
					if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
						// 이미 같은 고유번호를 가진 아이템이 정의되어 있다. 중복 정의 에러!
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					if (memcmp(m_pItemConfigList[iItemConfigListIndex]->m_cName, "자이안트-소드", strlen("자이안트-소드")) == 0) {
						int i;
						i = 0;
					}
					cReadModeB = 3;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						 m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;
					
					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;
				
				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}
	
DICFC_STOPDECODING:;

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);

	// 2002-09-09 #1
	m_bReceivedItemList = true;

	return TRUE;
}


BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
 register int i;
 char cTmpName[22];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	memcpy(cTmpName, pItemName, 20);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {
			// 같은 이름을 가진 아이템 설정을 찾았다. 설정값을 복사한다.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// 최초로 생성된 아이템의 수명은 최대치이다.
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
			return TRUE;
		}
	}

	// 아이템리스트를 모두 검색했음에도 발견되지 않았다. 
 	return FALSE;
}

// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다. 
BOOL CGame::_bInitItemAttr(class CItem * pItem, int iItemID)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	//strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (iItemID ==  m_pItemConfigList[i]->m_sIDnum) {
			// 같은 이름을 가진 아이템 설정을 찾았다. 설정값을 복사한다.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// 최초로 생성된 아이템의 수명은 최대치이다.
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
			return TRUE;
		}
	}

	// 아이템리스트를 모두 검색했음에도 발견되지 않았다. 
 	return FALSE;
}



BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;
	
	return TRUE;
}


BOOL CGame::_bReadMapInfoFiles(int iMapIndex)
{
	if (__bReadMapInfo(iMapIndex) == FALSE) {
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{
 register int i, iIndex, iMapIndex, iFollowIndex;
 char cTmpName[11], cFollowSide;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	iMapIndex    = -1;
	iFollowIndex = -1;

	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) {
		iIndex = i;
		iMapIndex = m_pNpcList[i]->m_cMapIndex;
		goto NEXT_STEP_SNFM1;
	}

NEXT_STEP_SNFM1:;

	switch (cFollowOwnerType) {
	case DEF_OWNERTYPE_NPC:
		for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) {
			// 따라다닐 대상을 발견했다.
			// 다른 맵에 존재하는 대상은 따라다닐 수 없다. 
			if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pNpcList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	
	case DEF_OWNERTYPE_PLAYER:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) {
			// 따라다닐 대상을 발견했다.
			// 다른 맵에 존재하는 대상은 따라다닐 수 없다. 
			if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pClientList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	}

NEXT_STEP_SNFM2:;

	if ((iIndex == -1) || (iFollowIndex == -1)) return FALSE;

	m_pNpcList[iIndex]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
	m_pNpcList[iIndex]->m_cFollowOwnerType  = cFollowOwnerType;
	m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
	m_pNpcList[iIndex]->m_cSide             = cFollowSide;


	return TRUE;
}


BOOL CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)
{
 register int i, t, j, k, iMapIndex;
 char  cTmpName[11], cTxt[120];
 short sX, sY, sRange;
 BOOL  bFlag;
 SYSTEMTIME SysTime;

	if (strlen(pName) == 0)   return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;

	GetLocalTime(&SysTime);

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;
    
/*	if (m_bIsApocalypseMode == TRUE)
	{
		if(memcmp(cTmpName, "inferniaA", 9) == 0){return FALSE;}
		else if(memcmp(cTmpName, "inferniaB", 9) == 0){return FALSE;}
			else if(memcmp(cTmpName, "procella", 8) == 0) {return FALSE;}
	}
*/
	if ((m_bIsApocalypseMode == TRUE)&&(memcmp(cTmpName, "abaddon", 7) == 0)&&(memcmp(pNpcName, "Abaddon", 7) != 0)) return FALSE;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}
	
	if (iMapIndex == -1) return FALSE;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == NULL) {
		m_pNpcList[i] = new class CNpc(pName);
		
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) {
			wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		// 생성시 요일제한에 걸리는지 검사해야 한다. 10보다 크면 모든 요일에 다 생성가능. 0이면 일요일, 1이면 월요일...
		if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
			if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek)	{
				// 지금 생성이 불가능한 NPC이다.
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;	
			}
		}

		// 처음 생성위치 결정 
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
		case DEF_MOVETYPE_RANDOM:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				// 포인터도 NULL이 아니고 그 값도 NULL이 아니라면 시작 위치를 할당한다.
				sX = *poX;
				sY = *poY;
			}
			else {
				for ( j = 0; j <= 30; j++) {
					// 만들 수 있는 좌표가 나올때 까지 30번 반복 
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

					bFlag = TRUE;
					for (k = 0; k < DEF_MAXMGAR; k++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
						// 피해야 할 좌표가 있다. 
						if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
							(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
							(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
							(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
							// Avoid Rect안이므로 이 위치에는 생성시킬 수 없다.	
							bFlag = FALSE;
						}
					}
					if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;

				}
				// 실패!
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;

GET_VALIDLOC_SUCCESS:;
				// sX, sY에 생성 가능하다.
			}
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			// pArea 영역 안에서 생성한다. 
			sRange = (short)(pArea->right - pArea->left);
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			// 10개의 생성위치중 한곳을 랜덤하게 선택 
			sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].x;
			sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].y;
			break;

		default:
			// poX, poY가 NULL이 아니라면 WaypointList 0번이 시작위치 
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				// 포인터도 NULL이 아니고 그 값도 NULL이 아니라면 시작 위치를 할당한다.
				sX = *poX;
				sY = *poY;
			}
			else {
				sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}
		
		if (m_pNpcList[i]->m_sAreaSize == 0) {
			if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) {
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;
			}
		}
		else {
			if (bGetNpcMovementArea(i, sX, sY, iMapIndex, m_pNpcList[i]->m_sAreaSize) == FALSE) {
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;		
			}
		}

		if ( (bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0) ) {
			// 플레이어가 있는 자리에서는 생성되지 않는 모드라면 
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		if ((poX != NULL) && (poY != NULL)) {
			// 포인터가 NULL이 아니라면 생성좌표를 입력한다.
			*poX = sX;
			*poY = sY;
		}

		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;
		
		// 제자리에서 맴돌고 있는지를 확인하기 위한 좌표 변수 
		m_pNpcList[i]->m_vX = sX;
		m_pNpcList[i]->m_vY = sY;

		// WaypointIndex를 카피한다.
		for (t = 0; t < 10; t++)
			m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

		// 총 WaypointIndex의 수를 계산한다.
		m_pNpcList[i]->m_cTotalWaypoint = 0;
		for (t = 0; t < 10; t++)
		if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

		if (pArea != NULL) {
			// RANDOMAREA Copy
			SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}

		// 움직이는 방식에 따라 시작 Destination을 결정한다.
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
			m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
			m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
			break;
		
		case DEF_MOVETYPE_SEQWAYPOINT: 
			m_pNpcList[i]->m_cCurWaypoint = 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			m_pNpcList[i]->m_cCurWaypoint = 0;
			
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
			m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
			m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
			break;

		case DEF_MOVETYPE_RANDOM:
			m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
			m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
			break;
		}

		m_pNpcList[i]->m_tmp_iError  = 0;
		m_pNpcList[i]->m_cMoveType          = cMoveType;

		switch (m_pNpcList[i]->m_cActionLimit) {
		case 2:
		case 3:
		case 5:
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;
			switch (m_pNpcList[i]->m_sType) {
			case 15: // ShopKeeper-W
			case 19: // Gandlf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kennedy
				m_pNpcList[i]->m_cDir      = 4 + iDice(1,3) -1;
				break;
			case 91:
				m_pNpcList[i]->m_cDir = 3;
			break;

			default:
				m_pNpcList[i]->m_cDir      = iDice(1,8);
				break;
			}
			break;
		
		default: 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[i]->m_cDir      = 5;
			break;
		}
		m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
		m_pNpcList[i]->m_iTargetIndex	    = NULL;
		m_pNpcList[i]->m_cTurn              = (rand() % 2);
		
		switch (m_pNpcList[i]->m_sType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			// 인간형 NPC라면 전투모드, 무기, 방패 플래그를 설정한다.
			m_pNpcList[i]->m_sAppr2 = (short)0xF000;
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4); // 무기
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9); // 방패 
			break;

		case 36:
		case 37:
			// 크루세이드용 건축물이라면 3단계로 완성된다.
			m_pNpcList[i]->m_sAppr2 = 3;
			break;

		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
			if (m_bIsRushNetMode == TRUE)
				m_pNpcList[i]->m_sAppr2 = 0;
			else 
				m_pNpcList[i]->m_sAppr2 = 3;
			break;

		default:
			m_pNpcList[i]->m_sAppr2 = 0;
			break;
		}
		
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime      += (rand() % 300);
		m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
		m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
		m_pNpcList[i]->m_bIsMaster          = bIsMaster;
		// 소환몹 생성 시간을 기록한다.
		if (bIsSummoned == TRUE) 
			m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

		// 고정 Berserk 상태 추가. 
		if (bFirmBerserk == TRUE) {
			m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
			m_pNpcList[i]->m_iStatus = m_pNpcList[i]->m_iStatus | 0x20; // 100000
			// 고정 Berserk 상태의 몹은 경험치를 2배 더 많이 갖는다. 
			m_pNpcList[i]->m_iExpDice *= 2;
		}

		// !!!
		if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;

		m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
		m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
		m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;
		//testcode
		if (iGuildGUID != 0) {
			wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
			PutLogList(G_cTxt);
		}
		
		if (m_pNpcList[i]->m_sAreaSize == 0) {
			m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
		}
		else {
			m_pMapList[iMapIndex]->SetBigOwner(i, DEF_OWNERTYPE_NPC, sX, sY, m_pNpcList[i]->m_sAreaSize);
		}
		m_pMapList[iMapIndex]->m_iTotalActiveObject++;
		m_pMapList[iMapIndex]->m_iTotalAliveObject++;

		switch (m_pNpcList[i]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 96:
		case 98:
		case 94:
			m_pMapList[iMapIndex]->bAddCrusadeStructureInfo((char)m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
			break;
		case 64:
			m_pMapList[iMapIndex]->bAddCropsTotalSum();
			return i;
			break;
		}
		
	

		// 다른 클라이언트에게 알린다.
		SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		return i;  //v2.19 2002-12-16 농사 스킬 관련 return 값을 m_pNpcList의 번호로 한다.
	}

	return FALSE;
}

void CGame::NpcProcess()
{
 register int i, iMaxHP;
 DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXNPCS; i++) { 
		
		if (m_pNpcList[i] != NULL) {
			if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
				switch (iDice(1,7)) {
				case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
				case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
				case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
				case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
				case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
				case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
				case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			}
			else dwActionTime = m_pNpcList[i]->m_dwActionTime; 

			// v1.42 냉동 상태라면 움직임이 50% 느려진다.
			if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] != 0) 
				dwActionTime += (dwActionTime/2);
		}
		
		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			// 시간 저장.
			m_pNpcList[i]->m_dwTime = dwTime;
			if ((m_bIsRushNetMode == TRUE) && ((m_pNpcList[i]->m_sType == 92) || (m_pNpcList[i]->m_sType == 39) ||
				(m_pNpcList[i]->m_sType == 87) || (m_pNpcList[i]->m_sType == 89)))
			{				
				if (m_pNpcList[i]->m_sType == 92)
					if (m_pNpcList[i]->m_iHP > 50000) m_pNpcList[i]->m_iHP = 50000;
				if (m_pNpcList[i]->m_sType == 39)
					if (m_pNpcList[i]->m_iHP > 15000) m_pNpcList[i]->m_iHP = 15000;
				if ((m_pNpcList[i]->m_sType == 87) || (m_pNpcList[i]->m_sType == 89))
					if (m_pNpcList[i]->m_iHP > 10000) m_pNpcList[i]->m_iHP = 10000;
			}
			else	
			{
				if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
					// 마나를 올릴 시간이 되었으면 올린다. 
					if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
						m_pNpcList[i]->m_dwMPupTime = dwTime;	
						
						//if (m_pNpcList[i]->m_bIsSummoned == FALSE) // 소환된 몬스터는 MP가 올라가지 않는다. 
						m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));
						
						if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
							m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
					}
				}
			
			
				// HP를 올릴 시간이 되었으면 올린다. 
				if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
					// 시간 재 갱신 
					m_pNpcList[i]->m_dwHPupTime = dwTime;	
					
					iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
					if (m_pNpcList[i]->m_iHP < iMaxHP) {
						
						if (m_pNpcList[i]->m_bIsSummoned == FALSE) // 소환된 몬스터는 HP가 올라가지 않는다. 
							m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice); // Hit Point는 17초마다 1D3씩 올라간다.
						
						if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
						if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
					}
				}
			}
			switch (m_pNpcList[i]->m_cBehavior) {
			case DEF_BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case DEF_BEHAVIOR_STOP:
				NpcBehavior_Stop(i);
				break;
			case DEF_BEHAVIOR_MOVE:
				NpcBehavior_Move(i);
				break;
			case DEF_BEHAVIOR_ATTACK:
				NpcBehavior_Attack(i);
				break;
			case DEF_BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}

			// !!! m_pNpcList는 NULL일 수 있다. 
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) {
				// 몬스터의 종류에 따라 소환 시간이 달라진다. 
				switch (m_pNpcList[i]->m_sType) {
				case 29: // 오우거: 1분 30초  
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*90) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				case 64: //v2.20 2002-12-20 농작물 살아 있는 시간.
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_PLANTTIME) 
						DeleteNpc(i);
					break;
				
				default: // 일반적인 경우: 소환몹이 시간이 다 되어 사라져야 한다.
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				}
			}
		}
	}
}


void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 WORD * wp;
 int  * ip;
 char * cp, * cp2;
 char   cBuffer[256], cTemp[256], cSendMode = NULL;
 char notice[128];

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 83 +30) return;
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
 	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
 	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
	 
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	cp = (char *)(pData + 21);
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
			char cTemp[200] ;
			ZeroMemory(cTemp,sizeof(cTemp)) ;
			pData[dwMsgSize-1] = NULL;
			wsprintf(cTemp,"GM Chat(%s):\"%s\"",m_pClientList[iClientH]->m_cCharName,cp) ;

			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
	}

	switch (m_bLogChatOption) {
		case 1:
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0){
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			break;
		case 2:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			break;
		case 3:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}
			else{
				ZeroMemory(cTemp,sizeof(cTemp));
				pData[dwMsgSize-1] = 0;
				wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
			}	
			break;
		case 4:		
			break;
	}
	switch (*cp) {
	case '$':
		*cp = 32;
		
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3) ) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 4;
		}
		else cSendMode = NULL;
		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;
	
	case '@':
		*cp = 32;
		
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;
		}
		else cSendMode = NULL;
		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;
	
	case '!':
		*cp = 32;
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10;
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
		
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) ) {			
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 2;
		}
		else cSendMode = NULL;
		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->AdminChat == TRUE)) cSendMode = 10;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->AdminChat == FALSE)) cSendMode = 35;
		break;

	case '^':
		*cp = 32;
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) && (m_pClientList[iClientH]->m_iGuildRank != -1) ) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;	// 메시지 창에 띄운다.
		}
		else cSendMode = NULL;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		break;
		
	case '~':
		*cp = 32;
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 3;
		}
		else cSendMode = NULL;
		
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
	break;

	case '/':
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);
		
		if (memcmp(cp, "/summonguild", 12) == 0) {
		if ((!m_bIsCrusadeMode) || (m_pClientList[iClientH]->m_iGuildRank == 0)) {    
		if (m_pClientList[iClientH]->m_iGuildRank == 0) {    
		  if (dwGetItemCount(iClientH, "Gold") >= 200000)  {
		  SetItemCount(iClientH, "Gold", dwGetItemCount(iClientH, "Gold") - 200000);
		  AdminOrder_SummonGuild(iClientH, cp, dwMsgSize - 21);
		return;
		}
		}
		}
		}

		if (memcmp(cp, "/checkcnt", 9) == 0)
		{	ZeroMemory(notice, sizeof(notice));
			wsprintf(notice,"You have %d points of contribution", m_pClientList[iClientH]->m_iContribution);
			ShowClientMsg(iClientH, notice);
			return;
		}
		
		if (memcmp(cp, "/checkek", 8) == 0)
		{	ZeroMemory(notice, sizeof(notice));
			wsprintf(notice,"You have %d points of enemy kills", m_pClientList[iClientH]->m_iEnemyKillCount);
			ShowClientMsg(iClientH, notice);
			return;
		}
		
		if (memcmp(cp, "/checkrep", 9) == 0)
		{	ZeroMemory(notice, sizeof(notice));
			wsprintf(notice,"You have %d points of enemy kills", m_pClientList[iClientH]->m_iRating);
			ShowClientMsg(iClientH, notice);
			return;
		}
		
		if (memcmp(cp, "/checkmjp", 9) == 0)
		{	ZeroMemory(notice, sizeof(notice));
			wsprintf(notice,"You have %d points of majestics", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
			ShowClientMsg(iClientH, notice);
			return;
		}

		if (memcmp(cp, "/showdmg", 8) == 0)
		{	PlayerOrder_ShowDamage(iClientH);
			return;
		}

		if (memcmp(cp, "/manastoneevent1", 16) == 0)
		{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
			StarterEnderStonesEvents(1);
			return;
		}
		
		if (memcmp(cp, "/manastoneevent2", 16) == 0)
		{	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
			StarterEnderStonesEvents(2);
			return;
		}

		if (memcmp(cp, "/tpstoneevent", 13) == 0)
		{	if (!m_bStones) return;
			RequestTeleportHandler(iClientH, "2", "fightzone1", -1 -1);
			return;
		}

		if (memcmp(cp, "/autoss", 7) == 0)
		{	m_pClientList[iClientH]->m_bAutoSS = !m_pClientList[iClientH]->m_bAutoSS;
			switch(m_pClientList[iClientH]->m_bAutoSS)
			{	case TRUE:  wsprintf(notice,"Auto Screen Shot Active, EK Events.");break;
				case FALSE: wsprintf(notice,"Auto Screen Shot Inactive");break;
			}
			ShowClientMsg(iClientH, notice);
			return;
		}

		if (memcmp(cp, "/happyhour ", 11) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)
            ManualStartHappyHour(iClientH, cp, dwMsgSize - 21);
			return;
		}
		//FurDay by prlucas
		if (memcmp(cp, "/furyday ", 9) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)
            ManualStartFuryDay(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setattackmode ", 15) == 0 ) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/who", 4) == 0) {
			wsprintf(notice,"Use Ctrl + W to see how many people online");
			ShowClientMsg(iClientH, notice);
			return;
		}
		
		if (memcmp(cp, "/verip ", 7) == 0)
        {
            if (m_pClientList[iClientH]->m_iAdminUserLevel < 4)
            {
                AdminOrder_VerIP(iClientH, cp, dwMsgSize - 21);
                return;
            }
            return;
        }

		if (memcmp(cp, "/checkplayer ", 13) == 0) {
		AdminOrder_CheckPl(iClientH, cp, dwMsgSize -21);
		return;
		}

		if (memcmp(cp, "/showframes", 11) == 0) {
			wsprintf(notice,"Use Ctrl + N to see how many Frames per Second");
			ShowClientMsg(iClientH, notice);
		
		}

        if (memcmp(cp, "/send ", 6) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)
			AdminOrder_Pushplayer(iClientH, cp, dwMsgSize -21);
			return;
		}

        if (memcmp(cp, "/criticals",10) == 0) {
            wsprintf(notice,"Use Ctrl + C to add Crtis ");
			ShowClientMsg(iClientH, notice);
            return;
        }

		if( memcmp( cp, "/checkdefence ", 12) == 0) {
		int dr = m_pClientList[iClientH]->m_iDefenseRatio + m_pClientList[iClientH]->m_iAddDR;
		int pahead = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
		int pabody = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
		int papants = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS];
		int paarms = m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
		int mr = m_pClientList[iClientH]->m_iAddResistMagic + m_pClientList[iClientH]->m_cSkillMastery[3];
		int ma = m_pClientList[iClientH]->m_iAddAbsMD;
		wsprintf(G_cTxt, "DR=%d, PA[HEAD]=%d, PA[BODY]=%d, PA[PANTS]=%d, PA[ARMS]=%d, MR=%d, MA=%d", dr, pahead, pabody, papants, paarms, mr, ma );
		SendNotifyMsg( NULL, iClientH, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, G_cTxt );
		return;
		}

		if (memcmp(cp, "/clearnpc", 9) == 0) {
			AdminOrder_ClearNpc(iClientH);
			return;
		}

		if (memcmp(cp, "/admins", 7) == 0) {
			PlayerCommandCheckAdmins(iClientH);
			return;
		}      

		if (memcmp(cp, "/dc", 3) == 0) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) 
		DeleteClient(iClientH, TRUE, TRUE);
		 return;
		}

		if (memcmp(cp, "/getskills", 10) == 0) {
            AutoSkill(iClientH);
            return;
		}


		if ((memcmp(cp, "/fi ", 4) == 0)) {
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/to", 3) == 0)) {
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/setpf123 ", 10) == 0)) {
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/pf123 ", 4) == 0)) {
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/sharap ", 8) == 0) {
			
			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/user+", 6) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)m_iAddUser+= 6;
			return;
		}
		if (memcmp(cp, "/user-", 6) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)m_iAddUser-= 6;
			return;
		}

		if ((memcmp(cp, "/rep+ ", 6) == 0))  {
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/rep- ", 6) == 0)) {
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/hold", 5) == 0)) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/tgt ", 5) == 0) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
			return;
		}


		if ((memcmp(cp, "/free", 5) == 0)) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/closeass ", 10) == 0) {
			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if ((memcmp(cp, "/ban", 4) == 0)) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/dissmiss ", 9) == 0) {
			UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/attack ", 8) == 0) {
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/teleport ", 10) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}



		if (memcmp(cp, "/summondemon ", 13) == 0) {
			AdminOrder_SummonDemon(iClientH);
			return;
		}

		// v2.14 유저소환기능 추가
		if (memcmp(cp, "/summonplayer ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4)
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		} //no?

		if (memcmp(cp, "/unsummonall ", 13) == 0) {
			AdminOrder_UnsummonAll(iClientH);
			return;			
		}

		// v2.17 2002-6-3 고광현수정
		if (memcmp(cp, "/unsummonboss ", 14) == 0) {
			AdminOrder_UnsummonBoss(iClientH);
			return;			
		}

		if (memcmp(cp, "/checkip ", 9) == 0) {
			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setinvi ", 9) == 0) {
			AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/gns ", 4) == 0) {
			AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		// 2002-7-15 
		if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
			AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
			return;
		}
 
		if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summonall ", 11) == 0) {
			AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/disconnectall ", 15) == 0) {
			AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createitem ", 12) == 0) {

			
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/activarcrusada ",16) == 0) {
			// 2002-7-4 크루세이드를 시작할 수 있는 운영자의 레벨을 낮췄다.
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
				GlobalStartCrusadeMode();
	    	}
			return;
		}
		
		if (memcmp(cp, "/begincitywar", 13) == 0) {
			// 2002-7-4 크루세이드를 시작할 수 있는 운영자의 레벨을 낮췄다.
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
				BeginCityWar();
	    	}
			return;
		}
		
		if (memcmp(cp, "/endcitywar", 11) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
				EndCityWar();
	    	}
			return;
		}

		if (memcmp(cp, "/city ", 6) == 0) {
			AdminOrder_ChangeCity(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/endcrusade ", 11) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
				ManualEndCrusadeMode(0);

			}
			return;
		}
		
		// v3.2
		if (memcmp(cp, "/startapoca ", 12) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
			GlobalStartApocalypseMode();
			}
			return;
		}
         //Ovl
		if (memcmp(cp, "/comandoson", 8) == 0) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 1)
		m_pClientList[iClientH]->m_bActivarComandos = TRUE;
					char cInfoString[500]; // SNOOPY: Say to GM
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Bienvenido de vuelta GM!");
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		return;
		}

		if (memcmp(cp, "/monstercount", 13) == 0) {
			AdminOrder_MonsterCount(iClientH,cp,dwMsgSize - 21);
			return;
		}			
		    if (memcmp(cp, "/startheldenian ", 16) == 0) { 
            if (m_pClientList[iClientH]->m_iAdminUserLevel > 2)	{ 
				//if (strcmp(m_cServerName, "CIUDADES") == 0) {
				if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
                 ManualStartHeldenianMode(iClientH, cp, dwMsgSize - 21); 
				//}  
			}
            return; 
				} 
			
			if (memcmp(cp, "/beginheldenianfight", 20) == 0) { 
            if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) { 
				//if (strcmp(m_cServerName, "CIUDADES") == 0) {
				if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
                HeldenianFight(iClientH);
				//}
			} 
            return; 
				} 
				
			if (memcmp(cp, "/endheldenian", 14) == 0) { 
             if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) { 
				 if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
                 ManualEndHeldenianMode(iClientH, cp, dwMsgSize - 21); 
			 } 
               return; 
				 } 

				if (memcmp(cp, "/endheldenian", 14) == 0) { 
             if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) { 
				 if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
                 ManualEndHeldenianMode(iClientH, cp, dwMsgSize - 21); 
			 } 
               return; 
				 } 
		if (memcmp(cp, "/setzerk ", 9) == 0) {
			AdminOrder_SetZerk(iClientH, cp, dwMsgSize - 21);
			return;	
		}
		
		if (memcmp(cp, "/desbug ", 8) == 0) {
			Desbug(iClientH, cp, dwMsgSize - 21);
			return;
		}
		if (memcmp(cp, "/setmsg ", 8) == 0) {
			
				SetAccountMsg(iClientH, cp, dwMsgSize - 21);
				return;
			
		}
		if (memcmp(cp, "/goto ", 6) == 0) {
			AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/playerban ", 11) == 0) {
			AdminOrder_ban(iClientH, cp, dwMsgSize - 21);
			return;
		}
	
		if (memcmp(cp, "/jailban ", 9) == 0) {
			AdminOrder_banjail(iClientH, cp, dwMsgSize - 21);
			return;
		}
         
		if (memcmp(cp, "/status", 7) == 0) {
		    AdminOrder_SetStatus(iClientH, cp, dwMsgSize - 21);
		    return;
		}

		if (memcmp(cp, "/weather", 8) == 0) { 
			AdminOrder_Weather(iClientH, cp, dwMsgSize - 21); 
			return; 
		}

		if (memcmp(cp,"/time ", 6) == 0) {
			AdminOrder_Time(iClientH, cp, dwMsgSize - 21);
				return;
		}
	
		if (memcmp(cp, "/showversion", 12) == 0) {
			ShowVersion(iClientH);
			return;
		}

		if (memcmp(cp, "/clearmap", 9) == 0) {
			AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
			return;
		}
		if (memcmp(cp, "/kill ", 6) == 0) {
			AdminOrder_Kill(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/revive ", 8) == 0) {
			AdminOrder_Revive(iClientH, cp, dwMsgSize - 21);
			return;
		}
	
		if (memcmp(cp, "/endapocalypse ", 15) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
				GlobalEndApocalypseMode();
			}
			return;
		}

		if (memcmp(cp, "/createparty", 12) == 0) {
			RequestCreatePartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/joinparty ", 11) == 0) {
			RequestJoinPartyHandler(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/dismissparty", 13) == 0) {
			RequestDismissPartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/getpartyinfo", 13) == 0) {
			GetPartyInfoHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/deleteparty", 12) == 0) {
			RequestDeletePartyHandler(iClientH);
			return;
		}
		if (memcmp(cp, "/asigek", 7) == 0) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
			{
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 3)
				AdminOrder_SetEK(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}

		if (memcmp(cp, "/addmaj", 7) == 0) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
			{ 
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 2)
				AdminOrder_SetMAJ(iClientH, cp, dwMsgSize - 21);
			}
 
		return;
		}

		if (memcmp(cp, "/addrep", 7) == 0) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE) 
			{
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 3)
				AdminOrder_SetRep(iClientH, cp, dwMsgSize - 21);
			}
		return;
		}

		if (memcmp(cp, "/addcrit", 8) == 0) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
			{
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 3)
				AdminOrder_SetCrit(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}
		
		if (memcmp(cp, "/addpk", 6) == 0) {
		AdminOrder_SetPK(iClientH, cp, dwMsgSize - 21);;
		return;
		}


		if ((memcmp(cp, "/setobservermode ", 17) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel > 2)) {
		
			AdminOrder_SetObserverMode(iClientH);
			return;
		}

		if ((memcmp(cp, "/getticket ", 11) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel > 2)) {
			
			AdminOrder_GetFightzoneTicket(iClientH);
			return;
		}

		if (memcmp(cp, "/portal ", 8) == 0) {
			AdminOrder_Portal(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/closeportal1", 13) == 0) {
			ClosePortal(1);
			return;	
		}
		if (memcmp(cp, "/closeportal2", 13) == 0) {
			ClosePortal(2);
			return;	
		}

		if (memcmp(cp, "/openrushnet", 13) == 0) {
			if (this->m_pClientList[iClientH]->m_iAdminUserLevel >= 3)
				LocalStartRushNetMode();
			return;	
		}
		if (memcmp(cp, "/closerushnet", 13) == 0) {
			if (this->m_pClientList[iClientH]->m_iAdminUserLevel >= 3)
				LocalEndRushNetMode(0);
			return;	
		}

		if (memcmp(cp, "/openrush", 10) == 0) {
			if (this->m_pClientList[iClientH]->m_iAdminUserLevel >= 3)
				if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
					LocalStartRushNetMode();
			return;	
		}

		if (memcmp(cp, "/closerush", 10) == 0) {
			if (this->m_pClientList[iClientH]->m_iAdminUserLevel >= 3)
				if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
					LocalEndRushNetMode(0);
			return;	
		}

		if (memcmp(cp, "/activarchat", 12) == 0) {
			if (m_pClientList[iClientH]->m_bActivarComandos == TRUE)
			{
				if (m_pClientList[iClientH]->AdminChat == TRUE)
					m_pClientList[iClientH]->AdminChat = FALSE;
				else m_pClientList[iClientH]->AdminChat = TRUE;
			}
			return;
		}	

		if (memcmp(cp, "/zerkme", 7) == 0)
		{
			ZerkMe(iClientH);
			return;
		}

		if (memcmp(cp, "/maname", 7) == 0)
		{
			ManaMe(iClientH);
			return;
		}


		if (memcmp(cp, "/changecity", 11) == 0)
        {
            PlayerOrder_ChangeCity(iClientH);
        }

		if (memcmp(cp, "/deathmach 1", 12) == 0) {
            if (m_pClientList[iClientH]->m_iAdminUserLevel == 4) return;
			bManualDeathmach = true;
			openDeathmach();		
			return;
		}
		
		if (memcmp(cp, "/deathmach 0", 12) == 0) {
            if (m_pClientList[iClientH]->m_iAdminUserLevel == 4) return;
			bManualDeathmach = false;
			closeDeathmach();
			return;
		}
	
				
		return;
	}

	pData[dwMsgSize-1] = NULL;
		
	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1) && (iDice(1,3) != 2)) {

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
		
		while (*cp != NULL) {
			if ((cp[0] != NULL) && (cp[0] != ' ') && (cp[1] != NULL) && (cp[1] != ' ')) {
				switch (iDice(1,3)) {
				case 1:	memcpy(cp, "워", 2); break;
				case 2:	memcpy(cp, "우", 2); break;
				case 3:	memcpy(cp, "월", 2); break;
				}
				cp += 2;
			}
			else cp++; 
		}
	}
		
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
	
	if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
	
		cSendMode = 20;
		
	
		if (*cp == '#') cSendMode = NULL;


		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
	}


	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			switch (cSendMode) {
			case NULL:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
					 (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
					 (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
					 (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
					 (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7)) 
				{
					if (m_bIsCrusadeMode == TRUE) {
						if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 1:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ((memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
					(memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0)) {					
					if (m_bIsCrusadeMode == TRUE) {
						if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 2:
			case 10: // Global
			case 35:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
					
			case 3:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ( (m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;

			case 4:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ((m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			}
		}
	}
	else {
	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);	
		
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) {
		
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)(cBuffer);
			*cp =  GSM_WHISFERMSG;
			cp++;

			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD)dwMsgSize;
			cp += 2;
		
			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;

			bStockMsgToGateServer(cBuffer, (13 +dwMsgSize));

		}
		else if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL) {
			
			if( strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0)  {
				iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);	
				if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
					char cTxt[200] ;
					
					ZeroMemory(cTxt,sizeof(cTxt)) ;

					wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName,pData+21,m_pClientList[iClientH]->m_cWhisperPlayerName) ;
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTxt);
				}
			}
		}

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 DWORD * dwp;
 WORD * wp;
 short * sp;
 char * cp, cTemp[256], cSendMode = NULL;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;
	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;
	
	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:	
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
			if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
							
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
		}
		break;

	case 2: 
	case 10: 
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
		}
		break;
	}
}


int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)
{
 char cData[100];
 DWORD * dwp, dwTime;
 WORD  * wp;
 int     iRet, iExp, tdX, tdY, uX,uY,vX1,vX2,vY1,vY2;
 short   sOwner, sAbsX, sAbsY, sItemIndex;
 char    cOwnerType;
 BOOL    bNearAttack = FALSE, bFarAttack = FALSE;
	

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if ((dX == 0)||(dY == 0)) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

#ifndef NO_MSGSPEEDCHECK	
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (80*8*7 -3000)) {
				
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}
#endif
	
	if ((wTargetObjectID != NULL) && (wType != 2)) {
		tdX = 0;
		tdY = 0;

		if (wTargetObjectID < DEF_MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ( (wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS)) ) {
			// NPC
			if (m_pNpcList[wTargetObjectID - 10000] != NULL) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

		if (sOwner == (wTargetObjectID - 10000)) {
			if(m_pNpcList!=NULL)
			{
				tdX = m_pNpcList[sOwner]->m_sX;
				dX = tdX;
				tdY = m_pNpcList[sOwner]->m_sY;
				dY = tdY;
			}
			bNearAttack = FALSE;
			bFarAttack = TRUE;
		}
		if (bFarAttack != TRUE) {
			if ((tdX == dX) && (tdY == dY)) {
				bNearAttack = FALSE;
			}
			else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
				dX = tdX;
				dY = tdY;
				bNearAttack = TRUE;
			}
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
      (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if (bFarAttack == FALSE) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) { // Storm Bringer
					if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
				}
				else {
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			}
			else {
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		}
		else {
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(sX, sY, cDir, sOwner)) != FALSE)
				wType = 0;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;
	
	iExp = 0;
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
	
	if (sOwner != NULL) { //1
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) {//2
			if(iCheckLugar(iClientH) != 1){
            
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {//4
						if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874){ // Directional bow
{  
	uY = dY - sY;
	uX = dX - sX;
	while((uX)||(uY))
	{
		if(abs(uX) >= abs(uY/2))
		{
			if(uX > 0) uX--;
			else if(uX <0) uX++;
		}
		if(abs(uY) >= abs(uX/2))
		{
			if(uY > 0) uY--;
			else if(uY <0) uY++;
		}
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, (dX-uX), (dY-uY));
		iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, (dX-uX), (dY-uY), wType, bNearAttack, bIsDash, FALSE); // 1
	}
}
}
#ifdef DEF_V383
					else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 560){ // battle axe
					{   
						if (((abs(tdX - dX) >= 1) && (abs(tdY - dY) >= 1)) || ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1))) { // Coords
				            m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
					        iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
						}
						vX1 = vX2 = dX;
						vY1 = vY2 = dY;
						if((dX-sX)&&(dY-sY))
						{
							switch(cDir)
							{
							case 2:
								vX1--;
								vY2++;
								break;
							case 4:
								vX1--;
								vY2--;
								break;
							case 6:
								vX1++;
								vY2--;
								break;
							case 8:
								vX1++;
								vY2++;
								break;
							}
						}
						else if((!(dX-sX))&&(dY-sY))
						{
							vX1++;
							vX2--;
						}
						else if((dX-sX)&&!(dY-sY))
						{
							vY1++;
							vY2--;
						}
						if(iDice(1,2)==1)
						{
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, vX1, vY1);
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, vX1, vY1, wType, bNearAttack, bIsDash, TRUE); // 1
						}
						if(iDice(1,2)==1)
						{
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, vX2, vY2);
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, vX2, vY2, wType, bNearAttack, bIsDash, TRUE); // 1
						}
					}
					}
#endif
					else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873) { // 8Fire-Bow
						if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {//9
							if ((((bHeldenianFight == FALSE)&&(m_bIsHeldenianMode == TRUE))||((m_bHeldSafe == TRUE)&&(m_bIsHeldenianMode == FALSE))) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)){
							iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
							}
							else {
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1,7)+3)*1000, 8);
							iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
							}
							}//9
					}//8
					else {//10
						iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
					}//10
				}//4
				else {//11
					iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
				}//11
			}//3
			else iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}//2
	}//1
	else _CheckMiningAction(iClientH, dX, dY);

	if (iExp != 0) {
		GetExp(iClientH, iExp, TRUE);
	}
	
	if (bResponse == TRUE) {
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOTION_ATTACK_CONFIRM;
	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}
//npc hp by necru
//MORLA2 - NPCBar cuando Golpean
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				break;

			case DEF_OWNERTYPE_NPC:
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCBAR, (m_pNpcList[sOwner]->m_iHP*100)/(m_pNpcList[sOwner]->m_iHitDice * 6 + m_pNpcList[sOwner]->m_iHitDice), m_pNpcList[sOwner]->m_iMana, NULL, NULL);
					if (m_pNpcList[sOwner]->m_iMana != 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCBAR2, (m_pNpcList[sOwner]->m_iMana*100)/m_pNpcList[sOwner]->m_iMaxMana, NULL, NULL, m_pNpcList[sOwner]->m_cNpcName);
					else 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCBAR2, 0, NULL, NULL, m_pNpcList[sOwner]->m_cNpcName);
				break;
			}	

	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError, char cArea, short sOwnerH)
{
 register char  cDir, cTmpDir;
 register int   aX, aY, dX, dY;
 register int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;
 
	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
	for (i = cDir; i <= cDir + 7;i++) {
		cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (cArea > 0)
		{
			if (m_pMapList[cMapIndex]->bGetBigMoveable(sOwnerH,dX + aX, dY + aY, cArea) == TRUE) return cTmpDir;
		}
		else
		{
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}
	}

	if (cTurn == 1)
	for (i = cDir; i >= cDir - 7;i--) {
		cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (cArea > 0)
		{
			if (m_pMapList[cMapIndex]->bGetBigMoveable(sOwnerH,dX + aX, dY + aY, cArea) == TRUE) return cTmpDir;
		}
		else
		{
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}
	}

	return 0;
}

char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
 register int i;
 short sX, sY;	
	
	for (i = 0; i < 25; i++) 
	if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
		 (m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE) ) {
		sX = *pX + _tmp_cEmptyPosX[i];
		sY = *pY + _tmp_cEmptyPosY[i];	
		*pX = sX;
		*pY = sY;
		return TRUE;
	}
	
	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return FALSE;
}

void CGame::NpcBehavior_Move(int iNpcH)
{
 char  cDir;
 short sX, sY, dX, dY, absX, absY;
 short sTarget, sDistance;
 char  cTargetType;
	
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) && 
		(m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2:
	case 3:
	case 5:
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_STOP;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		return;
	}
	
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);
		
		if ((absX <= 2)	&& (absY <= 2)) {
			CalcNextWayPointDestination(iNpcH);
		}

		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}

	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) {
			if (iDice(1,3) == 3) {
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
				return;
			}
		}
		else {
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
			// 여기서 표효 동작같은것을 위한 메시지 발송. 
			return;
		}
	}
	
	// 마스터 몹은 이동 속도가 느리다.
	if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1,3) == 2)) return;
	
	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
		// 따르는 객체의 위치에 따라 이동을 결정한다. 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			// 따라다니던 개체가 죽으면 랜덤이동으로 전환.
			if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				return;
			}

			dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		case DEF_OWNERTYPE_NPC:
			// 따라다니던 개체가 죽으면 랜덤이동으로 전환. -> 01-12-19 주변의 다른 동급 몬스터를 마스터로 선택한다. 찾을 수 없었다면 랜덤 무브
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				//bSerchMaster(iNpcH);
				return;
			}
			
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		}

		if (abs(sX - dX) >= abs(sY - dY)) 
			 sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);

		if (sDistance >= 3) {
			// 따르는 대상이 임계치 이상 떨어져 있으면 이동한다. 
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			}
			else {
				cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError,m_pNpcList[iNpcH]->m_sAreaSize,iNpcH);
			}
			if (cDir == 0) {
				
			}
			else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				}
				else {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
				}
				m_pNpcList[iNpcH]->m_sX   = dX;
				m_pNpcList[iNpcH]->m_sY   = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			}
		}
	}
	else 
	{
		// 다음 이동 방향을 구한다.
		if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
			cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
		}
		else {
			cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError,m_pNpcList[iNpcH]->m_sAreaSize,iNpcH);
		}	
		if (cDir == 0) {
			if (iDice(1,10) == 3) CalcNextWayPointDestination(iNpcH);
		}
		else {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];

			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			}
			else {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
			}
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{
 register int ix, iy, iPKCount;
 register short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide;
 int   iInv, iSearchType;
 
	sTargetOwner = NULL;
	cTargetType  = NULL;
	sDistance    = 100;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;

	iSearchType = NULL;
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 51: iSearchType = 1; break;
	}
	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != NULL) {
			if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break;
		
			iPKCount = 0;
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == NULL) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}
				else {
					// v2.95 10/05/06 00:34 Si el personaje es neutral los npcs no le pegan.
					if ((m_pClientList[sOwner]->m_iAdminUserLevel > 0) || (m_pClientList[sOwner]->m_cSide == DEF_NETURAL)) goto SKIP_SEARCH;
					switch (iSearchType) {
					case 1: goto SKIP_SEARCH; break;
					case NULL: break;
					}

					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == NULL) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}
				else {
					switch (iSearchType) {
					case 1:
						switch (m_pNpcList[sOwner]->m_sType) {
						case 36:
						case 37:
						case 38:
						case 39:
						case 40:
						case 41: break;

						default:
							goto SKIP_SEARCH;
							break;
						}
						break;
					case NULL: 
						break;
					}
					
					dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];

					if (m_pNpcList[iNpcH]->m_sType == 21) {
						if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
							sOwner     = NULL;
							cOwnerType = NULL;
						}
					}
				}
				break;
			}
			
			if (m_pNpcList[iNpcH]->m_cSide < 10) {
				if (cTargetSide == 0) {
					if (iPKCount == 0) goto SKIP_SEARCH;
				}
				else {
					if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
				}
			}
			else {
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}

			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);

			if (sTempDistance <	sDistance) {
				sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
			}
SKIP_SEARCH:;
		}
	}

	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}


void CGame::NpcBehavior_Attack(int iNpcH)
{
 int   iMagicType;
 short sX, sY, dX, dY;
 char  cDir;
 DWORD dwTime = timeGetTime();
 BOOL bFly = FALSE;

	if (m_pNpcList[iNpcH] == NULL) return;
 	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 1:
	case 2:
	case 3:
	case 4:
		return;

	case 5:
		if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
	}
	
	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	// 연속 공격 카운트 초기화 
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0) 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

	// 턴 카운트 증가. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
		// 20회 이상 공격동작을 수행하면 다시 이동모드로 들어간다. 단 영구 공격 모드가 아니라면 
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;

		// 여기서 표효동작이나 여유동작을 취하기 위한 메시지를 발송할 수도 있다.
		return;
	}

	// 위치를 구한다.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// 목표물이 사라졌다. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// 목표물이 사라졌다. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}

	// 목표물 주위에 적이 많으면 도망친다. 단 건축물(5)는 예외
	if ( (iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) && 
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {
		
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// 에너지가 낮고 Bravery가 낮으면 도망친다. 단 건축물(5)는 예외
	if ( (m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1,m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// 목표물의 상태를 판단한다. 
	cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
	if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) {
		if (cDir == 0) return;
		// 방향을 바꾸고 공격동작 
		m_pNpcList[iNpcH]->m_cDir = cDir;				  

		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
			// 전쟁용 건물인 경우 
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 36: // Crossbow Guard Tower: 활 공격 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2); // 활
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
				break;

			case 37: // Cannon Guard Tower: 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			}
		}
	
		else {

			// 일반 NPC인 경우
			if (m_pNpcList[iNpcH]->m_cMagicLevel == 11) {// v2.20 2002-12-20 Ice-Golem의 공격 형태
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 75);
			} 

			else 
			{
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1); // 공격에 대한 효과를 계산한다. 
			}
		}
		// 연속 공격 카운트 증가.
		m_pNpcList[iNpcH]->m_iAttackCount++;

		// 공격 지능 타입에 따른 이후 행동. 고정 공격 모드에는 해당되지 않는다.  
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK:
				// 공격 -> 후퇴 -> 공격 -> 후퇴 -> ...
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;

			case DEF_ATTACKAI_TWOBYONEATTACK:
				// 공격 -> 공격 -> 후퇴 -> 공격 -> 공격 -> 후퇴 -> ...
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			}
		}
	}
	else {
		// 떨어져 있다.  
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
		// 마법 능력이 있어야 하고 사정거리 내여야 한다.
		if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) { // 각 써클별로 마법 사용이 가능한지 판단후 처리. 
			case 1:
				if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;
			
			case 2:
				if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;
			
			case 3: // Orc Mage
				if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // Fire-Ball
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // Energy-Bolt
				break;
			
			case 4: // ????
				if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30; // Fire-Strike
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37; // Lightning-Arrow
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // Fire-Ball
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // Energy-Bolt
				break;
			
			case 5: // Hellbound, Cyclops, Cannibal-Plant, Rudolph
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30; // Fire-Strike
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37; // Lightning-Arrow
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // Fire-Ball
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // Energy-Bolt
				break;

			case 6: // Liche, Tentocle
				if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51; // Lightning-Bolt
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30; // Fire-Strike
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37; // Lightning-Arrow
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20; // Fire-Ball
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10; // Energy-Bolt
				break;
			
			case 7: // Demon, Gagoyle, Hellclaw, Barlog, Fire-Wyvern, MasterMage-Orc, LWB-Aresden, LWB-Elvine, GHK, GHKABS, TK, BG
				if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 3)) 
					iMagicType = 70; // Bloody-Shock-Wave
				else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 61; // Mass-Fire-Strike
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60; // Energy-Strike
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51; // Lightning-Bolt
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning
				break;
			
			case 8: // Unicorn, Centaurus, Giant-Lizard, 
				if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 35; // Paralyze
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60; // Energy-Strike
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51; // Lightning-Bolt
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43; // Lightning
				break;

			case 9: // Tiger-Worm
				if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 74; // Lightning-Strike
				break;
			
			case 10: // Frost, Nizie
				if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 57; // Ice-Strike
				break;
			
			case 11: // Ice-Golem
					goto NBA_CHASE;
				break;
			
			// v2.23
			case 12: // 09/05/06 22:51 Wyvern
				if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2))
					iMagicType = 91; // Blizzard
				else if (m_pMagicConfigList[63]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
					iMagicType = 63; // Mass-Child-Wind
				break;
				
			// v3.2
			case 13: // Abaddon
				if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 96; // Earth Shock Wave
				else if (m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 81; // Meteor Strike
				break;
			}

			if (iMagicType != -1) {
				
				// 몬스터의 AI가 2이상이고 마법 공격 상대가 마법 보호가 걸려 있다면 공격하지 않는다. 
				if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// 마법 보호가 걸려있음 공격하지 않으며 추격하거나 이동모드로 전환, 새로운 목표물을 검색
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// 패럴마법인데 목표물이 이미 패럴상태라면 마법 사용 안함.
						if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// 마법 보호가 걸려있음 공격하지 않으며 추격하지 않고 이동모드로 전환, 새로운 목표물을 검색
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// 패럴마법인데 목표물이 이미 패럴상태라면 마법 사용 안함.
						if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
					}
				}
				
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// 광범위 마법 사용이 금지된 경우 (MagicLevel이 음수인 경우)
		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 43;
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 37;
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 0;

			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// v1.41 마법 능력이 없지만 원거리 공격이 가능하다면 
		if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) && 
			(abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {
						
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			// 방향을 바꾸고 공격동작 
			m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				// 전쟁용 건물이다. 화살 혹은 포를 쏜다.
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 36: // Crossbow Guard Tower
				case 89: // Ancient Gran Canion
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;

				case 37: // Cannon Guard Tower: 매스 파이어 스트라이크 공격
				case 87: // Cross Torret
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				}
			}
			else {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 51: // v2.05 Catapult: 매스 파이어 스트라이크 공격 
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;

				case 54: // Dark Elf: 활 공격을 한다.
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); // 2: 활공격 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;
				case 63: //Frost
				case 53: //Beholder
				case 79: //Nizie
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
NBA_BREAK1:;
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: 필살기
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
							
				default:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: 필살기 
					// 공격에 대한 효과를 계산한다. 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
				}
			}
			// 연속 공격 카운트 증가.
			m_pNpcList[iNpcH]->m_iAttackCount++;
			
			// 공격 지능 타입에 따른 이후 행동. 고정 공격 모드에는 해당되지 않는다.  
			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
				case DEF_ATTACKAI_EXCHANGEATTACK:
					// 공격 -> 후퇴 -> 공격 -> 후퇴 -> ...
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					break;
			
				case DEF_ATTACKAI_TWOBYONEATTACK:
					// 공격 -> 공격 -> 후퇴 -> 공격 -> 공격 -> 후퇴 -> ...
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					}
					break;
				}
			}
			return;
		}

		// 마법을 사용하지 않았다면 추격한다.
NBA_CHASE:;		

		if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;

		// 연속 공격 카운트 초기화 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

		{
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			}
			else {
				cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize, iNpcH);
			}
			if (cDir == 0) return;
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			}
			else {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
			}	
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}

void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
 register int i;
 DWORD dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		// Crusade 만약 지휘관이 사망한 경우 지휘관 산하 NPC들은 소환몹 모드로 전환되어 일정시간 
		// 이후에 자동 폭파된다. 몹이 넘쳐나는 것을 막기 위함.
		if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
			(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {
			
			if (m_pNpcList[i]->m_cActionLimit == 0) {
				// 이동 가능한 NPC만 소환 모드로 전환
				m_pNpcList[i]->m_bIsSummoned = TRUE;
				m_pNpcList[i]->m_dwSummonedTime = dwTime;
			}
		}
		
		if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) && 
			(m_pNpcList[i]->m_cTargetType == cTargetType)) {
			
			switch (iCode) {
			case DEF_MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility == 1) {
				}
				else {
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;

			default:
				m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
			}
		}
	}
}


int CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, BOOL bNearAttack, BOOL bIsDash, BOOL bArrowDirection)
{
 int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
 char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect;
 short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
 DWORD  dwTime = timeGetTime();
 WORD   wWeaponType;
 double dTmp1, dTmp2, dTmp3;
 BOOL   bKilled = FALSE;
 BOOL   bNormalMissileAttack = FALSE;
 BOOL   bIsAttackerBerserk;
 int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp,iTemp2;
 int    iAttackerHP, iMoveDamage, iRepDamage;
 char   cAttackerSA;
 int    iAttackerSAvalue, iHitPoint;
 char   cDamageMoveDir;
 int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
 int	iSkillLV,iCropLimit;
	iExp = 0;
	iPartyID = 0;

	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cAttackerSA      = NULL;
	iAttackerSAvalue = NULL;
	wWeaponType      = NULL;

	// 공격한 자의 Attack Point와 HitRatio를 얻는다.
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sAttackerH] == NULL) return 0;
        if ((((bHeldenianFight == FALSE)&&(m_bIsHeldenianMode == TRUE))||((m_bHeldSafe == TRUE)&&(m_bIsHeldenianMode == FALSE))) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) return 0; 
        if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] == NULL) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) && (m_bIsHeldenianMode == TRUE)) return 0; 
   	    if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0 && m_pClientList[sAttackerH]->m_iAdminUserLevel < 3) return 0;
		if ((memcmp(m_pClientList[sAttackerH]->m_cCharName, "Premios", 10) == 0) || (memcmp(m_pClientList[sAttackerH]->m_cCharName, "Apuestas", 10) == 0)) return 0;
		// 공격위치가 공격 불가능 맵이라면 공격 불가능 
		if (m_pMapList[ m_pClientList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return 0;
			
		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 다른 Player를 공격하지 않는다. 전면전시 제외)
		if ( m_bIsCrusadeMode == FALSE &&
			(m_pClientList[sAttackerH]->m_bIsHunter == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) return 0;

		// 투명 모드였다면 공격시에 해제된다.
		if ( (m_pClientList[sAttackerH]->m_iStatus & 0x10) != 0 ) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, FALSE);
			
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[ sAttackerH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}
		
		// 전투모드가 아닌 상태라면 공격의 의미가 없다.
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

		iAP_SM = 0;
		iAP_L  = 0;
		// 공격굴림
		
		// 플레이어가 소지한 무기 종류를 분석한다.
		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);

		// 공격자의 사이드
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		if (wWeaponType == 0) {
			// 맨손이다.
			iAP_SM = iAP_L    = iDice(1, (m_pClientList[sAttackerH]->m_iStr / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L  <= 0) iAP_L  = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
			// v2.17 2002-7-2 성후니 변경 주먹버그 수정을 위해 
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5 ;

		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			// 칼, 매이스 종류
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			// 보너스 가산 
			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
		
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			
			// Str 보너스 데미지를 가산한다. +0.5f는 반올림
			dTmp1 = (double)iAP_SM;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;
			
			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;
			
			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
			//
		}
		else if (wWeaponType >= 40) {
			// 활 종류
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			// 보너스 가산 
			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
			
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = TRUE;
			
			// Str 보너스 가산 
			iAP_SM += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			iAP_L  += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			//
		}

		iAttackerHitRatio += 50;
		if (iAP_SM <= 0) iAP_SM = 1;
		if (iAP_L  <= 0) iAP_L  = 1;

		// v1.41 Custom-Made 장착으로 인한 공격무기 아이템의 효과가 있다면 처리 
		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			// 최저 대미지 보정 
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			// 최대 대미지 보정
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}
		// v3.8 Damage Bonus
		if ((strcmp(m_pClientList[sAttackerH]->m_cMapName, "middleland") == 0) || (strcmp(m_pClientList[sAttackerH]->m_cMapName, "2ndmiddle") == 0)|| (strcmp(m_pClientList[sAttackerH]->m_cMapName, "icebound") == 0))
		{
    	iAP_SM += iAP_SM/5;
    	iAP_L += iAP_SM/5;
		}
		// v2.23 18/02/06 17:38 
		if (m_pClientList[sAttackerH]->m_cHeroBonus == 1) {
			iAttackerHitRatio += 100;
			iAP_SM += 15;
			iAP_L += 15;
		}
		
		// v2.95 02/06/06 14:20 KlonessWand(MS.10) y (MS.20) 
		sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sWeaponIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 863) ||
			(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 864)) {
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 8) iRepDamage = 8;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
		}	
		
		// v2.95 07/05/06 16:07 Bonus de la DarkExecutor durante la noche 
		sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
		if ((sWeaponIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 847) && // Dark Executor
			(m_cDayOrNight == 2)) { // Noche
				iAP_SM += 7;
				iAP_L += 7;
			}
		// v2.95 07/05/06 16:36 Bonus de la LightingBlade durante el dia 
		if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 848) && // Lighting Blade
			(m_cDayOrNight == 1)) { // Dia
				iAP_SM += 7;
				iAP_L += 7;
			}

	// MORLA 2.9 - Damage en Deathmach para el war
			if  (memcmp(m_pClientList[sAttackerH]->m_cMapName, "deathmach", 9) == 0)
			{
				iAP_SM += 25;
				iAP_L += 25;
			}

			//bonus pnecks by necrus
		// v2.95 07/05/06 17:12 Bonus de las armas Kloness con los enemigos que tienen menos rep
		if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 849) || // KlonessEsterk
			(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 850) || // KlonessBlade
			(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 851) || // KlonessAxe
			(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4997)|| // extreme kwand
			(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4991)||// extreme kblade
			(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 966)) { // legendary wand
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 12) iRepDamage = 12;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
		}
	

		sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
		if ((sWeaponIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
			}
		}
				
		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);
		
		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0)
			 bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		// v1.2 여기서 필살기에 따른 대미지 가중을 결정한다.
		if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
			
			// 기본적으로 파워가 레벨%만큼 증가한다.
			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_SM += iTemp;
			
			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_L += iTemp;

			// v2.16 2002-5-27 무기 종류에 따른 대미지 추가  해머의 경우 필살기 사용시 보너스 명중률 적용 
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 6:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio  += 30 ; break;	// 활 공격 +10%
			case 7:  iAP_SM *= 2; iAP_L *= 2; break; // 단검 공격 +200%
			case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio += 30 ; break;	// 긴칼 공격 +10%
			case 10:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ;                           break;   // 도끼 공격 +20%
			case 14:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ; iAttackerHitRatio += 20 ; break;   // 해머 공격 +20%
			case 21:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5); iAttackerHitRatio +=  50 ; break;   // 지팡이 공격 +20%
			
			default: break;		// 기타 공격
			}
						
			// v1.3 필살기의 경우 기본적으로 명중값이 100 올라간다.
			iAttackerHitRatio += 100;
			// v1.41 필살기의 명중값을 조정한다.
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}

		// v2.12 대쉬 공격에 보너스 명중률 적용 
		if (bIsDash == TRUE) {
			// 무기 종류에 따른 대미지 추가 

			iAttackerHitRatio += 20;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); break;	// 긴칼 공격 +10%
			case 10: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;    // 도끼 공격 +20%
			case 14: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;    // 해머 공격 +20%
			default: break;		// 기타 공격
			}
		}

		// v1.41
		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
		// v1.42 추가 Attack Rating 
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

		//v1.43
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sAttackerH] == NULL) return 0;
		// 공격위치가 공격 불가능 맵이라면 공격 불가능 
		if (m_pMapList[ m_pNpcList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return 0;
		
		// 투명 모드였다면 공격시에 해제된다.
		if ( (m_pNpcList[sAttackerH]->m_iStatus & 0x10) != 0 ) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, FALSE);
			
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[ sAttackerH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}
	
		// 공격자의 사이드
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;

		iAP_SM = 0;
		iAP_L  = 0;
		
		// Crusade
		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0) 
			iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);
		
		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;
		
		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);
		
		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0)
			 bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		// v1.41
		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;

		// v1.411
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		//v1.43
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	// 공격당한 대상의 방어률을 얻는다.
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 존재하지 않는 캐릭터는 공격할 수 없다. 
		if (m_pClientList[sTargetH] == NULL) return 0;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return 0;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return 0; 

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 공격 당하지 않는다. 전면전시 제외)
		if ((m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && 
			(m_pClientList[sTargetH]->m_bIsHunter == TRUE ) && 
			(cAttackerType == DEF_OWNERTYPE_PLAYER) ) return 0;

#ifdef DEF_ALLPLAYERPROTECT
		// v2.19 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 현재 초보 미들은 마을과 같은 룰이 적용되며 다른편도 공격이 가능하지 않는다.
		if(cAttackerType == DEF_OWNERTYPE_PLAYER)
		{
			if( m_pClientList[sTargetH]->m_iIsOnTown == DEF_NEVERNONPK )
			{
				if (m_pClientList[sTargetH]->m_iPKCount == 0)  return 0;
			}
			else
			{
				if ((m_bIsCrusadeMode == FALSE) &&			
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide ) &&
					(m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;
			}
		}
#endif 

#ifdef DEF_SAMESIDETOWNPROTECT
		// v2.172 같은편끼리는 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 중립도 공격 않되게 
		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;
#endif 		
#ifdef DEF_BEGINNERTOWNPROTECT
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE)
			&& (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;
#endif
		// 공격자의 좌표가 일치하지 않아도 무의미하다. 
		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;
		
		// v1.4 운영자에게는 공격이 통하지 않는다. 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;

		if ((memcmp(m_pClientList[sTargetH]->m_cCharName, "Premios", 10) == 0) || (memcmp(m_pClientList[sTargetH]->m_cCharName, "Apuestas", 10) == 0)) return 0;

		// v1.41 공격자가 중립이면 대인 공격이 불가능하다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
		
		// 01-12-17 같은 파티원이면 공격 불가 
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		
		// 만약 공격자가 플레이어이고 공격자가 안전 공격 모드라면 공격의 의미가 없다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE)) { 
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				// 공격력 절반 
				iAP_SM = iAP_SM / 2;
				iAP_L  = iAP_L / 2;
			}
			else {
				// 안전 공격모드로 같은편을 공격했을때. 만약 사투장 내라면 길드가 다른 경우 대미지를 주게된다.
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						// 공격력 절반 
						iAP_SM = iAP_SM / 2;
						iAP_L  = iAP_L / 2;
					}
				}
				else return 0;
			}
		}

		// v1.42 추가 방어값 
		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;

		//v1.43
		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		// 존재하지 않는 캐릭터는 공격할 수 없다. 
		if (m_pNpcList[sTargetH] == NULL) return 0;
		// 죽은자에 대한 공격은 무의미하다.
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;
		// 공격자의 좌표가 일치하지 않아도 무의미하다. 
		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;
		
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		// v1.3 공격자가 플레이어라면 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			
			// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 아군이나 중립의 공격에 대미지를 입지 않는다.
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			case 39:
			case 87:
			case 89:
			case 92:
				if (m_bIsRushNetMode == TRUE)
					if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			}
			
			// 만약 플레이어의 공격 무기가 곡괭이고 NPC가 건물 건설중이라면 iBuildCount를 줄인다.
			if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				
				// 운영자도 아니고 건설자도 아닌데 곡괭이질을 하면 소용없다.
				if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;
								
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1: // 완성되었다.
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

						// v2.19 2002-12-4 건설할때 오르는 건설 포인트는 낮춘다.
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 36: iConstructionPoint = 700; iWarContribution = 700; break;	// 애로우 가드 타워 
						case 37: iConstructionPoint = 700; iWarContribution = 700; break;	// 캐논 가드 타워
						case 38: iConstructionPoint = 500; iWarContribution = 500; break;	// 마나 콜렉터
						case 39: iConstructionPoint = 500; iWarContribution = 500; break;	// 디텍터
						}
										
						m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
							m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

						//testcode
						wsprintf(G_cTxt, "Construction Complete! WarContribution: +%d", iWarContribution);
						PutLogList(G_cTxt);

						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
						break;

					case 5: // 두번째 업그레이드 
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					case 10: // 처음 업그레이드
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					}
					break;
				}
				
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}

			//v2.19 2002-12-16 농사 스킬 관련
			// 만약 플레이어의 공격 무기가 호미(27)면 iBuildCount를 줄인다. 또한 npc가 Crops형태이어야 한다.
			if ((wWeaponType == 27) && (m_pNpcList[sTargetH]->m_iNpcCrops != 0) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				
				iSkillLV = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				iCropLimit = m_pNpcList[sTargetH]->m_iCropsSkillLV;
				
				if(20 > iSkillLV) return 0;  //v2.19 2002-12-16 스킬레벨 20부터 가능..

				if(m_pClientList[sAttackerH]->m_iLevel <  20 ) return 0 ; //v2.20 2002-12-20 농사 스킬 레벨 20부터 가능
				
				
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 64:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1: // 없어졌다.
	
						m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 3;						
//						m_pNpcList[sTargetH]->m_sAppr2 = (char)0;

						if(iSkillLV <= iCropLimit + 10)
						//	CalculateSSN_SkillIndex(sAttackerH, 2, 1);

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

						//농작물을 떨어트린다.
						if(bProbabilityTable(iSkillLV,iCropLimit,2) > 0)
						{
							bCropsItemDrop(sAttackerH,sTargetH,TRUE);
						}
						DeleteNpc(sTargetH);

						break;
					case 8: // 두번째 업그레이드
						m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 3;
//						m_pNpcList[sTargetH]->m_sAppr2 = (char)3;

						if(iSkillLV <= iCropLimit + 10)
							//CalculateSSN_SkillIndex(sAttackerH, 2, 1);

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

						//농작물을 떨어트린다.
						if(bProbabilityTable(iSkillLV,iCropLimit,2) > 0)
						{
							if(iSkillLV <= iCropLimit + 10)
								//CalculateSSN_SkillIndex(sAttackerH, 2, 1);
							bCropsItemDrop(sAttackerH,sTargetH);
						}
						break;

					case 18: // 첫번째 업그레이드 
					    m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 2;
//						m_pNpcList[sTargetH]->m_sAppr2 = (char)2;

						if(iSkillLV <= iCropLimit + 10)
							//CalculateSSN_SkillIndex(sAttackerH, 2, 1);
						
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						
						//농작물을 떨어트린다.
						if(bProbabilityTable(iSkillLV,iCropLimit,2) > 0)
						{
							if(iSkillLV <= iCropLimit + 10)
								//CalculateSSN_SkillIndex(sAttackerH, 2, 1);
							bCropsItemDrop(sAttackerH,sTargetH);
						}
						break;
					}
					break;
				}
				
				if(m_pNpcList[sTargetH] == NULL)
				{
					return 0;
				}

				if(bProbabilityTable(iSkillLV,iCropLimit,1) > 0 
					|| m_pNpcList[sTargetH]->m_iBuildCount == 1
					|| m_pNpcList[sTargetH]->m_iBuildCount == 8
					|| m_pNpcList[sTargetH]->m_iBuildCount == 18) {

					iTemp = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					
					if ((iTemp != -1) || (m_pClientList[sAttackerH]->m_pItemList[iTemp] != NULL)) {
						//호미 수명을 줄인다.
						if (m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)	
							m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
						
						if (m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
							// 수명이 다 되었으므로 장착을 해제한다.
							// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sAttackerH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
					}

					//성장 카운트...
					m_pNpcList[sTargetH]->m_iBuildCount--;
				}

				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}

				return 0;
			}
		}

		//v1.43
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	// 공격대상의 위치가 No-Attack-Area라면 플레이어간 공격은 절대 성공하지 못한다. 
	if ( (cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) {
		
		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;
		
		// 물리 보호 혹은 안전 영역이라면 공격 성공 못함 
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}
		
	// Dex에 의한 보너스 명중값 추가 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_iDex+m_pClientList[sAttackerH]->m_iAngelicDex) > 50) {
			iAttackerHitRatio += (m_pClientList[sAttackerH]->m_iDex+m_pClientList[sAttackerH]->m_iAngelicDex - 50); 	
		}
	}
	
	// 활 무기의 경우 날씨에 의한 명중률 변경. 5, 10, 25% 감소
	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 4);  break;
		}
	}
	// 명중값 오류 가능성 보정 
	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;    
			
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ];
		
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ]; 
		break;
	}

	// 공격 성공 여부와는 상관없이 활을 쐈다면 화살을 감소시킨다. 
	// 양손무기가 장착되어 있고 활이라면
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// BUG POINT! Item == NULL
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			//#ERROR POINT!
			if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ] == NULL) {
				// v1.4 에러 보정 코드 
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE;
				DeleteClient(sAttackerH, TRUE, TRUE);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					// 활에 할당된 화살이 없다.	공격이 성공하든 실패하든 아무런 효과를 보지 못한다.
					return 0;
				}
				else {
					// 화살 아이템 인덱스가 잘못되었다~! 오류상황 
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ] == NULL) 
						return 0;
					
					
					if (bArrowDirection == FALSE){	
					// 화살이 하나 줄었다.
					m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) {
						// 화살이 다 소모됐다. Count가 0이된 화살 아이템을 삭제한다.
					
						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE);
						// 다른 종류의 화살이 있다면 재 할당.
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						// 화살이 줄었음을 알려준다.
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, (char)FALSE, NULL);
						// 화살 무게를 줄인다. 
						// 소지품 총 중량 재 계산 
						iCalcTotalWeight(sAttackerH);
					}
				}
			}
				// 방어자가 미사일공격에 대한 보호가 된 상태라면 무조건 명중하지 않는다.
				if (cProtect == 1) return 0;
			}
			else {
				// 일반 무기를 사용한 공격이다. 마법 방패가 구현되어 있다면 방어값 증가시킨다. 
				// 칼, 도끼, 맨손 
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 40;  break; //  Magic Shield
				case 4: iTargetDefenseRatio += 100; break; //  Great Magic Shield
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		// NPC의 공격이다.
		switch (cProtect) {
		case 1: 
			switch (m_pNpcList[sAttackerH]->m_sType) {
			case 54: // 다크 엘프는 장거리 공격시에 활방이 적용 된다.
				if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0; 
			}
			break;
		case 3: iTargetDefenseRatio += 40;  break; //  Magic Shield
		case 4: iTargetDefenseRatio += 100; break; //  Great Magic Shield
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	//--------------
	// 만약 공격자가 목표의 등 뒤에서 공격했다면 방어률은 50%감소 	
	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	
	// 방어값 오류 가능성 보정   
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	// 최종 공격 명중률을 구한다. 
	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);

	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3); 

	// 최소 공격 명중률을 보장한다. 
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	// 최대 공격 명중률을 제한한다.
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

	// Berserk 공격이라면 타격치가 두배가 된다. 단 필살기는 두배가 되지 않는다.
	if ((bIsAttackerBerserk == TRUE) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L  = iAP_L  * 2;
	}

	// 플레이어라면 고정 대미지 추가 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L  += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	// v1.4 근접 공격에 의한 명중이라면 대미지를 감소시킨다. 
	
	if (bNearAttack == TRUE) {
		// 초기 설정은 50% 
		iAP_SM = iAP_SM / 2;
		iAP_L  = iAP_L / 2;
	}
	
	// v1.4 VIT에 따른 대미지 감소 
	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
		iAP_L  -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
	}

	// v1.4 대미지 값 최종 보정 Crusade
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L  <= 1) iAP_L  = 1;
	}
	else {
		// 몬스터의 공격인 경우 최저 대미지는 0: 더미의 공격때문이다.
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L  <= 0) iAP_L  = 0;
	}

	iResult = iDice(1, 100);
	//------------

  	if (iResult <= iDestHitRatio) {
		// 공격은 성공했다.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// 공격자가 플레이어라면 처리해야 할 것이 있다.
			
			// 1. 배가 너무 고프다거나 SP가 낮으면 1/10 실패 가능성이 있다.
			if ( ((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && 
				 (iDice(1,10) == 5) ) return FALSE;	
			
			// 2. 연타 카운트 증가
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;

			// 연타 카운트에 따른 보너스 대미지 증가 
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);
			
			//v1.42 연속 공격 대미지 곱하기?
			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != NULL))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L  += iComboBonus;

			// v1.42 희귀 공격 무기 아이템 효과 계산 
			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {	// 희귀 아이템 효과 종류: 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의
			case 0: break;
			case 1: // 필살의~
				if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
					iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					iAP_L  += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
				}
				break;

			case 2: // 중독의~
				cAttackerSA = 61; // cAttackerSA가 61이면 중독 정도가 지정된 것을 의미 
				iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue*5; 
				break;

			case 3: // 정의의~
				cAttackerSA = 62;
				break;
			}

			// v1.44 사투장 내이면 공격력 1.33배 
			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}

			// Crusade : 전면전 모드일때 군인 공격력 1.33배 
			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
			{
				// v2.15 저랩의 경우는 데미지가 증가한다. 2 배 
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) 
				{
					iAP_SM += iAP_SM ;
					iAP_L += iAP_L ;
				}
				// v2.15 저랩의 경우는 데미지가 증가한다. 1.7 배 
				else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
				{
					iAP_SM += (iAP_SM* 7)/10 ;
					iAP_L += (iAP_L* 7)/10 ;
				} else 
				{
					iAP_SM += iAP_SM/3; ;
					iAP_L += iAP_L/3 ;
				}
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			// 스킬의 사용상태를 모두 무효화 한다.
			ClearSkillUsingStatus(sTargetH);
					
			// 만약 공격받은 클라이언트가 DEF_RAGPROTECTIONTIME초동안 응답이 없었다면 보호를 받는다.
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) {
				// 공격 효과가 없다. 랙으로 인한 지연. 
				return 0;
			}
			else {
				// v1.42 
				switch (cAttackerSA) {
				case 62: // 정의의~
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						// 공격받은 캐릭터의 평판이 낮으므로 추가 타격치 계산 
						iTemp = abs(m_pClientList[sTargetH]->m_iRating) / 10;
						if (iTemp > 10) iTemp = 10;
						iAP_SM += iTemp;
					}
					break;
				}
				
				// 공격받은 플레이어의 충격 흡수률과 Parrying 성공여부를 계산한다. 
				iAP_Abs_Armor  = 0;
				iAP_Abs_Shield = 0;
			
				iTemp = iDice(1,10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1; // 50%는 몸통에 명중
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2; // 25%는 다리부위에 명중
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3; // 15%는 팔부위에 명중
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4; // 10%는 머리부위에 명중 

				switch (iHitPoint) {
				case 1:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 2:
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						 m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
							m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 3: 
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] > 0) {
						// 갑옷에 의한 충격 흡수률을 계산: 최대 80%까지 대미지를 막는다.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				}
				if (m_pClientList[sTargetH]->m_iAddAbsPD != 0) {
					
					dTmp1 = (double)iAP_SM;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsPD;
					dTmp3 = (dTmp2/100.0f)*dTmp1;
					iAP_SM = iAP_SM - ((int)dTmp3)/2;
			
					dTmp1 = (double)iAP_L;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsPD;
					dTmp3 = (dTmp2/100.0f)*dTmp1;
					iAP_L = iAP_L - ((int)dTmp3)/2;
				}

				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {
						//CalculateSSN_SkillIndex(sTargetH, 11, 1);

						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80) 
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Shield = (int)dTmp3;

						// v1.3 방패의 수명을 줄인다.
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
							// v1.432 중립인 경우 수명을 감소시키지 않는다.
							if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
								// 수명이 다 되었으므로 장착을 해제한다.
								// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								// 아이템을 장착 해제 시킨다.
								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
							}
						}
					}
				}
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)){
					iAP_SM = iAP_SM - ((iAP_Abs_Armor/2) + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;
				}
				else if(cAttackerType == DEF_OWNERTYPE_NPC) {
					iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;
				}

				//v1.432 특수 능력 1이 활성화 되어 있으면 대인 공격시에 대미지 
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
					case 0: break;
					case 1: // HP 50%씩 대미지를 입힌다. 만약 50%의 대미지가 원래 대미지보다 적다면 대미지는 그대로이다.
						iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
						if (iTemp > iAP_SM) iAP_SM = iTemp;
						if (iAP_SM <= 0) iAP_SM = 1;
						break;

					case 2: // 10초간 냉동 효과 
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (30*1000), 
								                sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
						break;

					case 3: // 10초간 마비 효과 
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 2;
							// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (10*1000), 
												sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 10, NULL, NULL);
	
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 10, NULL, NULL);
						}
						break;

					case 4: // 원샷 원킬
						iAP_SM = (m_pClientList[sTargetH]->m_iHP);
						break;

					case 5: // 입힌 대미지 만큼 공격자가 HP를 얻는다.
						m_pClientList[sAttackerH]->m_iHP += iAP_SM;
						if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						break;
					}
				}

				// 공격대상이 능력을 사용중이라면 방어효과가 있다.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
					case 50: // 공격 무기의 수명을 0으로 만든다.
						if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
							 sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
						if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						break;

					case 51: // 해당 부위 대미지 무효화
						if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
							iAP_SM = 0;
						break;

					case 52: // 모든 대미지 무효화
						iAP_SM = 0;
						break;
					}
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
					(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
					// 행운효과로 죽음을 모면한다.
					iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
				}

				// Hammer Stripping
				int iDownValue = 1 ;
				if ((cAttackerType	== DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH] != NULL) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)){

					switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
					case 14: 
						// v2.17 2002-7-21 배틀해머를 사용해야 30씩 단다.
						if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
						{
							//v2.20 2003-1-28 자이언트 배틀해머. 버그 수정.. 
							iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
							if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
							{
								if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761)
								{
									iDownValue = 30; // 해머: 한방에 30씩 준다.
								}
								else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762)
								{
									iDownValue = 45; // 해머: 한방에 35씩 준다.
								}
								else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843)
								{
									iDownValue = 35; // 해머: 한방에 30씩 준다.
								}
							}
						}
//							iDownValue = 30; // 해머: 한방에 30씩 준다.
//						else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  //v2.20 2002-12-18 자이언트 배틀해머. 
//							iDownValue = 35; // 해머: 한방에 35씩 준다.
						else
							iDownValue = 20; // 해머: 한방에 20씩 준다.
						break; 
						

					case 10: iDownValue = 3; break;  // 도끼: 한방에 3씩 준다.
					default: iDownValue = 1; break;  // 기타 무기
					}
					
				}

				int iHammerChance = 100 ; // v2.172
				switch (iHitPoint) {
				case 1:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if( iTemp == -1)
					{
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
					}
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
		if ((m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan >= 50000)) {
			m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							ReleaseItemHandler(sTargetH, iTemp, TRUE);
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761) // Battle Hammer
									{
										iHammerChance = iHammerChance / 2;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762) // Giant Battle Hammer
									{
										iHammerChance = (5 * iHammerChance) / 6;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843) // Barbarian Hammer
									{
										iHammerChance = (5 * iHammerChance) / 8;
									}
								}
							}
							else 
								iHammerChance = iHammerChance / 4 ;
							
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // MerienPlateMailM
								case 622: // MerienPlateMailW
								iHammerChance = 0;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {
								ReleaseItemHandler(sTargetH, iTemp, TRUE);
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}
						}
					}
					break;

				case 2:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
		if ((m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan >= 50000)) {
			m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							ReleaseItemHandler(sTargetH, iTemp, TRUE);
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761) // Battle Hammer
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762) // Giant Battle Hammer
									{
										iHammerChance = (5 * iHammerChance) / 6 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843) // Barbarian Hammer
									{
										iHammerChance = (5 * iHammerChance) / 8;
									}
								}
							}
							else 
								iHammerChance = iHammerChance / 4 ;

							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621:
								case 622:
								iHammerChance = 0;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {
								ReleaseItemHandler(sTargetH, iTemp, TRUE);
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}

						}
					}

					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
		if ((m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan >= 50000)) {
			m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761) // Battle Hammer
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762) // Giant Battle Hammer
									{
										iHammerChance = (5 * iHammerChance) / 6 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843) // Barbarian Hammer
									{
										iHammerChance = (5 * iHammerChance) / 8;
									}
								}
							}
							else 
								iHammerChance = iHammerChance / 4 ;

							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}


							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {

								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								
							}
						}
					}
					break;

				case 3:
					// 팔갑옷 
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
						// v1.432 중립인 경우 수명이 줄지 않음
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
		if ((m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan >= 50000)) {
			m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							// 해머에 의해 공격을 받았다면 확률에 의해 갑옷이 벗겨질 수 있다.
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  2000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							// v2.17 2002-7-21 배틀해머를 사용해야 잘 벗겨진다.
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761) // Battle Hammer
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762) // Giant Battle Hammer
									{
										iHammerChance = (5 * iHammerChance) / 6 ;  //v2.20 2002-12-18 자이언트 배틀해머.
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843) // Barbarian Hammer
									{
										iHammerChance = (5 * iHammerChance) / 8;
									}
								}
							}
							else 
								iHammerChance = iHammerChance / 4 ;

							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {


								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}
						}
					}
					break;

				case 4:
					// 머리 갑옷
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
						// v1.432 중립인 경우 수명이 줄지 않음
						if ((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue; // v2.16
							
		if ((m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan >= 50000)) {
			m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// 아이템을 장착 해제 시킨다.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
						}
						else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) { // v2.172
							// 해머에 의해 공격을 받았다면 확률에 의해 갑옷이 벗겨질 수 있다.
							if ( m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan <  3000 )
								iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							else 
								iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
							
							// v2.17 2002-7-21 배틀해머를 사용해야 잘 벗겨진다.
							if(31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))
							{
								iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
								if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) 
								{
									if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761) // Battle Hammer
									{
										iHammerChance = iHammerChance / 2 ;
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762) // Giant Battle Hammer
									{
										iHammerChance = (5 * iHammerChance) / 6 ;  //v2.20 2002-12-18 자이언트 배틀해머.
									}
									else if(m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843) // Barbarian Hammer
									{
										iHammerChance = (5 * iHammerChance) / 8;
									}
								}
							}
//								iHammerChance = iHammerChance / 2 ;
//							else if(32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))  
//								iHammerChance = (5 * iHammerChance) / 8 ;  //v2.20 2002-12-18 자이언트 배틀해머.
							else 
								iHammerChance = iHammerChance / 4 ;

							// v2.19 2002-11-17 메리엔시리즈는 해머의 공격에 벗겨지지 않는다.
							switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
								case 621: // 메리엔-플레이트메일M
								case 622: // 메리엔-플레이트메일W
								iHammerChance = 0 ;
								break;
							}

							if (iHammerChance >  m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {

								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
								// 클라이언트에게 알려준다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							}
						}
					}
					break;
				}

				// v1.411 목표물이 마법 보호중이었고 공격자가 마법 방어를 무효화 시키는 공격 능력이 있다면 
				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ], NULL, NULL);
					switch(m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					}
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);					  
				}

				// v1.411 목표물이 중독되지 않았고 공격자가 중독 능력이 있다면 
				if ( (m_pClientList[sTargetH]->m_bIsPoisoned == FALSE) && 
					 ((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61)) ) {
					// 독성저항을 계산한다.
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == FALSE) {
						// 중독되었다.
						m_pClientList[sTargetH]->m_bIsPoisoned  = TRUE;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue; // cAttackerSA가 61이면 중독 정도가 지정된 것을 의미 
						
						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						// 중독되었음을 알린다. 
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, NULL, NULL);
						SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE); // v2.23
#ifdef DEF_TAIWANLOG
						_bItemLog(DEF_ITEMLOG_POISONED,sTargetH,(char *) NULL,NULL) ;
#endif
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (cAttackerType == DEF_OWNERTYPE_PLAYER)
				{	if( (m_pClientList[sAttackerH]->m_dwShowDMG == TRUE) && (m_pClientList[sAttackerH] != NULL) )
					{	char cDamageMod[30];
						ZeroMemory(cDamageMod, sizeof(cDamageMod));
						wsprintf(cDamageMod ,"You did %d damage", iAP_SM);
						ShowClientMsg(sAttackerH,cDamageMod);
				}	}
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);	
					bKilled     = TRUE;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
				}
				else {
					if (iAP_SM > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1/100.0f)*dTmp2;

							iTemp = (2*(m_pClientList[sTargetH]->m_iMag+m_pClientList[sTargetH]->m_iAngelicMag)) + (2*m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iInt+m_pClientList[sTargetH]->m_iAngelicInt)/2);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}

						// v2.04 타격을 받았는데 필살 충전의 특성치가 있었다면 
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							// 확률 계산에 따라서 필살기가 충전된다.
							if (iDice(1,50) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) { //aumentado el tiempo de recharge
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 5);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
								// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
							}
						}

						// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
												
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
							 sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
						else sAttackerWeapon = 1;
						
						// v1.44 사투장이면 대미지 60이상일때 밀린다.
						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
							 iMoveDamage = 60;
						else iMoveDamage = 40;

						if (iAP_SM >= iMoveDamage) {
							//대미지가 40이상이면 맞은 타격으로 물러난다.
							//방향을 계산한다.
							
							if (sTgtX == sAtkX) {
								if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else if (sTgtY > sAtkY) cDamageMoveDir = 4;
								else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}
							else if (sTgtX < sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 7;
								else if (sTgtY > sAtkY) cDamageMoveDir = 6;
								else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
							}

							// v1.44 밀려날때 대미지를 입력한다.
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;
						
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, NULL);
						}
						else {
CAE_SKIPDAMAGEMOVE:;
							int iProb;
							// 충격을 받았다면 충격동작 전송: 단 무기별로 충격 동작 회피가 된다.
							// v2.16 2002-5-27 성후니 추가 해머 공격 
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
								case 6 : iProb = 3500; break;		// 활쏘기
								case 8 : iProb = 1000; break;		// 긴칼 공격 
								case 9 : iProb = 2900; break;       // 펜싱 공격
								case 10: iProb = 2500; break;		// 도끼 공격
								case 14: iProb = 2000; break;		// 해머 공격
								case 21: iProb = 2000; break;		// 지팡이 공격
								default: iProb = 1; break;			// 기타 공격
								}
							}
							else iProb = 1;
												
							if (iDice(1,10000) >= iProb) 
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, NULL);		
						}

						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
							// Hold-Person 되어 있었던 상태라면 풀린다. 단 패럴라이즈 된것은 풀리지 않는다. 	
							// 1: Hold-Person 
							// 2: Paralize
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}

						// 맞았으므로 필살기 카운트 증가 
						m_pClientList[sTargetH]->m_iSuperAttackCount++;
						if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) { 
							
							m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
							// 필살기는 최대 Level/10 개 까지 축적된다.
							iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 5);
							if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
							
							// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
						}
					}
				}
			}
			break;

		case DEF_OWNERTYPE_NPC:
			// 죽은 NPC에 대한 공격은 무의미.
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return 0;
			
			if (m_bIsCrusadeMode == TRUE) {
				// 크루세이드 모드에서 같은편이 공격할 수 없는 유니트들 
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 40:
					case 41:
					case 43:
					case 44:
					case 45:
					case 46:
					case 47: 
					case 51:
						return 0;

					default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 41:
						if (cAttackerSide != 0) {
							// 그랜드 매직 제네레이터가 적의 공격을 받으면 발사 속도가 지연된다.
							m_pNpcList[sTargetH]->m_iV1 += iAP_L;
							if (m_pNpcList[sTargetH]->m_iV1 > 500) {
								// 대미지를 1000 받으면 마나스톡 양이 1 내려간다.
								m_pNpcList[sTargetH]->m_iV1 = 0;
								m_pNpcList[sTargetH]->m_iManaStock--;
								if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
								//testcode
								wsprintf(G_cTxt, "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
								PutLogList(G_cTxt);
							}
						}
						break;
					}
				}
			}
					
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 1:
			case 2:
			case 6:return 0;break;
			}

			if (m_pNpcList[sTargetH]->m_cSize == 0)	
				 iDamage = iAP_SM;
			else iDamage = iAP_L;
			
			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage))/100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
			}

			if((31 == m_pNpcList[sTargetH]->m_sType) &&  //v2.19 2002-12-18졸라 이상하닷 수정 필요
			(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)
			&& (m_pClientList[sAttackerH]->m_iSpecialAbilityType == 7) ) // 데몬 슬레이어 
			{
				iDamage = iDamage + iDice(3,2);
			}

			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
							
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);					  
			}

			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0:
			case 3:
			case 5: 
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				if (cAttackerType == DEF_OWNERTYPE_PLAYER)
				{	if ( (m_pClientList[sAttackerH]->m_dwShowDMG == TRUE) && (m_pNpcList[sTargetH] != NULL) && (m_pClientList[sAttackerH] != NULL) )
					{	char cDamageMod[30];
						ZeroMemory(cDamageMod, sizeof(cDamageMod));
						wsprintf(cDamageMod ,"You did %d damage", iDamage);
						ShowClientMsg(sAttackerH, cDamageMod);
				}	}
				break;
			}
			
			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				
				bKilled = TRUE;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;				
			}
			else {
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;


				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode == TRUE) goto CAE_SKIPCOUNTERATTACK;
				if ((m_pNpcList[sTargetH]->m_bIsSummoned == TRUE) && 
					(m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;
				
				if (iDice(1,3) == 2) {
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
								tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
								tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;
						}
						// 현재 목표물과의 거리 
						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
				
						tX = tY = 0;
						switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sAttackerH] != NULL) {
								tX = m_pClientList[sAttackerH]->m_sX;
								tY = m_pClientList[sAttackerH]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH] != NULL) {
								tX = m_pNpcList[sAttackerH]->m_sX;
								tY = m_pNpcList[sAttackerH]->m_sY;
							}
							break;
						}

						// 공격받은 목표물과의 거리 
						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
				
						if (iDst2 <= iDst1) {
							// 공격한 대상이 현재 목표로 하고 있는 대상보다 가까이에 있다. 목표물 변경 
							m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
					}
				}
			
CAE_SKIPCOUNTERATTACK:;
				
				// Damage를 입은 충격으로 인한 지연효과. 일반 유니트의 경우에만 적용됨.
				if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;
				
				// 충격을 받았다면 충격동작 전송
				if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;
				
				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
					// ActionLimit가 4면 맞았을때 반대방향으로 이동하는 오브젝트이다.
					// 이동할 방향을 계산한다.
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// 다시 한번 방향을 랜덤하게 구한다.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// 예전 위치에서 지운다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// 새 위치에 표시한다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// 이벤트 알린다.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
										
					// 한번 더 간다.
					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// 다시 한번 방향을 랜덤하게 구한다.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// 예전 위치에서 지운다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// 새 위치에 표시한다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// 이벤트 알린다.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
					
					// 목적지에 도착했는지 검사한다.
					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExpDice/3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
							iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							//v1.42 경험치 증가 
							if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							// Crusade
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							//m_pClientList[sAttackerH]->m_iExpStock += iExp;
							GetExp(sAttackerH, iExp);

							// NPC 오브젝트 삭제
							DeleteNpc(sTargetH);
							return FALSE;
						}
					}

CAE_SKIPDAMAGEMOVE2:;
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);
				}
				// 여기서 표효 동작같은것을 위한 메시지 발송.
				
				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
					// Hold-Person 되어 있었던 상태라면 그대로 풀린다. 
					// 1: Hold-Person 
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 2) {
					// 마비된 몬스터의 HPdice가 높다면 패럴이 풀릴 가능성이 있다. 
					// 2: Paralize
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}
			
				// NPC에 대한 공격이 성공했으므로 공격자가 플레이어라면 입힌 대미지 만큼의 경험치를 공격자에게 준다. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// NPC가 플레이어의 공격에 죽었다면 Exp를 올린다. 
					// 단 소환몹인 경우 경험치를 올리지 않는다.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}

					//v1.42 경험치 증가 
					if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
						dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1/100.0f)*dTmp2;
						iExp += (int)dTmp3;
					}

					if (m_bIsCrusadeMode == TRUE) iExp = iExp/3;

					// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
					if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 55:
						case 56:
							iExp = 0 ;
						break ;
						default: break;
						}
					}

				}
			}
			break;
		}

//CAE_SKIPCOUNTERATTACK:;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// 공격이 성공했으므로 공격자가 소지한 공격무기의 수명을 감소시킨다. 
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				 sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			
			if (sWeaponIndex != -1) {
				// 먼저 무기를 사용함으로써 증가하는 SSN을 계산한다.
				if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) &&
					 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231) ) {
					// 픽액스를 들고 있다면 광물에 대한 공격이 아니면 스킬이 올라서는 안된다.
					if (bKilled == FALSE)
						 CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
					else {
						if (m_pClientList[sAttackerH]->m_iHP <= 3) // 체력이 거의 없었다면 2배 보너스 
							 CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice)*2);
						else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
					}
				}
				
				if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) && 
					 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) {
					// 최대 수명이 0이면 사용해도 수명이 줄지 않는다.
					// 검류 무기의 경우 날씨에 의한 수명증가가 빨라진다.
					iWepLifeOff = 1;
					if ((wWeaponType >= 1) && (wWeaponType < 40)) {
						switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
						case 0:	break;
						case 1:	if (iDice(1,3) == 1) iWepLifeOff++; break;
						case 2:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,2); break;
						case 3:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,3); break;
						}
					}

					// 수명을 감소시킨다. 단 중립이면 감소하지 않는다.
					if (m_pClientList[sAttackerH]->m_cSide != 0) {
						if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff) 
							m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;
					}

					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
						// 아이템의 수명이 다 되었다.
						// 아이템이 망가졌다는 메시지 <- 이걸 받으면 장착화면에서 해제시켜야 한다.
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
						// 아이템을 장착 해제 시킨다.
						ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);  // <- 이 함수는 서버에서의 효과만 처리 
					}
				}
			}
			else {
				if (wWeaponType == 0) {
					// 맨손공격이 명중했다. Wrestling SSN 증가 
					//CalculateSSN_SkillIndex(sAttackerH, 5, 1);
				}
			}
		}
	}
	else {
		// 공격은 실패. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// 공격자가 플레이어라면 처리해야 할 것이 있다.
			// 1. 연타 카운트 클리어
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
		}
	}

	return iExp;
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage, BOOL bHeld)
{
 short  sAttackerWeapon;
 int    * ip, i, iQuestIndex, iExp, iConstructionPoint, iWarContribution;
 double dTmp1, dTmp2, dTmp3;
 char   * cp, cData[120], cQuestRemain;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;
	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);
	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC); 
	m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
	m_pNpcList[iNpcH]->m_cTargetType  = NULL;
	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
	{	if ( (m_bStones) && (memcmp(m_pClientList[sAttackerH]->m_cMapName, "fightzone1", 10) == 0) &&
			 (m_pNpcList[iNpcH]->m_sType == 42) )
		{	m_pClientList[sAttackerH]->m_iRating += 50;
			m_pClientList[sAttackerH]->m_iContribution += 50;
			SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_STONEWINNER, NULL, NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL, NULL);		
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{	if (m_pClientList[i] != NULL)
					SendNotifyMsg(sAttackerH, i, DEF_NOTIFY_STONEKILLED, m_pNpcList[iNpcH]->m_sType, NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL, NULL);
			}
			StoneWinnerGift(sAttackerH, iNpcH);
			StarterEnderStonesEvents(3);
	}	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;

	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	}
	else {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
	}

	
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	if (bHeld == TRUE){
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);
	}
	if ( (m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && 
		 (m_pClientList[sAttackerH] != NULL) ) {
		// NPC가 플레이어의 공격에 죽었다면 ExpStock을 올린다. 
		// 단 소환몹인 경우 경험치를 올리지 않는다.	 나머지 경험치를 올린다.
		iExp = (m_pNpcList[iNpcH]->m_iExpDice/3);
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

		//v1.42 경험치 증가 
		if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
			dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double)iExp;
			dTmp3 = (dTmp1/100.0f)*dTmp2;
			iExp += (int)dTmp3;
		}
		
		// v3.2
		if (m_pNpcList[iNpcH]->m_sType == 81) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL) {		
				SendNotifyMsg(sAttackerH, i, DEF_NOTIFY_ABADDONKILLED, NULL, NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL, NULL);		
				}
			}
		}

		// 크루세이드 모드일때 몬스터를 죽여서 얻을 수 있는 경험치는 1/4
		// v2.17 2002-7-21 초보존과 농경지에서는 경험치를 그대로 얻을 수 있다. 
		if (m_bIsCrusadeMode == TRUE) {
			if (  (strcmp(m_pClientList[sAttackerH]->m_cMapName, "default") != 0)  
				/*|| (strcmp(m_pClientList[sAttackerH]->m_cMapName, "arefarm") != 0)
				|| (strcmp(m_pClientList[sAttackerH]->m_cMapName, "elvfarm") != 0)*/ )
				if (iExp > 10) iExp = iExp/4;
		}

		//m_pClientList[sAttackerH]->m_iExpStock += iExp;
		// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
		if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 55:
			case 56:
				iExp = 0 ;
			break ;
			default: break;
			}
		}

		GetExp(sAttackerH, iExp);

		// Quest 여부를 판단한다.
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != NULL) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT:
					if ( (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) &&
						 (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType) ) {
						// 조건에 합당하다. 카운트 증가후 판단.
						m_pClientList[sAttackerH]->m_iCurQuestCount++;
						cQuestRemain = (m_pQuestConfigList[m_pClientList[sAttackerH]->m_iQuest]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
						_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
				}
			}
		}
	}

	// v1.41 특수몬스터가 죽었을 경우의 처리 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 32:
			// Si matan a un unicorn le resta 5 puntos de rep al character
			m_pClientList[sAttackerH]->m_iRating -= 5;
			if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = 0;
			if (m_pClientList[sAttackerH]->m_iRating >  10000) m_pClientList[sAttackerH]->m_iRating = 0;
			break;
		case 99:
			// Si matan a un unicorn le resta 5 puntos de rep al character
			m_pClientList[sAttackerH]->m_iRating += 5;
			if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = 0;
			if (m_pClientList[sAttackerH]->m_iRating >  10000) m_pClientList[sAttackerH]->m_iRating = 0;
			break;

		case 33:

			break;
		}
	}

	// Crusade
	iConstructionPoint = 0;
	switch (m_pNpcList[iNpcH]->m_sType) {
	// 크루세이드용 유니트들이다. 건설 포인트, 보너스 경험치 계산
	case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 6:  iConstructionPoint = 50; iWarContribution = 100; break;	// 머서너리
	case 36: iConstructionPoint = 700; iWarContribution = 4000; break;	// 애로우 가드 타워 
	case 37: iConstructionPoint = 700; iWarContribution = 4000; break;	// 캐논 가드 타워
	case 38: iConstructionPoint = 500; iWarContribution = 2000; break;	// 마나 콜렉터
	case 39: iConstructionPoint = 500; iWarContribution = 2000; break;	// 디텍터
	case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;	// 에너지 실드 제네레이터
	case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;	// 그랜드 매직 제네레이터
	case 43: iConstructionPoint =  500; iWarContribution = 1000; break;	// 라이트 워 비틀
	case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;	// 고즈 핸드 나이트
	case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;	// 고즈 핸드 기병
	case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;	// 템플 나이트
	case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;	// 배틀 골렘
	case 51: iConstructionPoint = 800; iWarContribution = 1500; break;	// 캐터팔트

	case 64:	//v2.19 2002-12-16 농사 스킬 관련
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum();
		break;
	}
	
	// Crusade
	if (iConstructionPoint != NULL) {
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
				// 사이드가 달라야만 건설 포인트가 계산된다.
				m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

				if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
				if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				//testcode
				wsprintf(G_cTxt, "Enemy Npc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			else {
				// 같은편 NPC를 죽이면 전쟁 공헌도가 2배로 떨어진다.
				/*
				m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
				if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
					m_pClientList[sAttackerH]->m_iWarContribution = 0;

				//testcode
				wsprintf(G_cTxt, "Friendly Npc Killed by player! WarContribution: -%d", iWarContribution);
				PutLogList(G_cTxt);
				*/

				// 2002-09-05 #2 전쟁 공헌도 로그 남기기 (같은편 NPC를 죽일때)
				m_pClientList[sAttackerH]->m_iWarContribution = 0;

				wsprintf(G_cTxt, "WarContribution: Friendly Npc Killed by player(%s)! ", m_pClientList[sAttackerH]->m_cAccountName);
				PutLogEventFileList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) {
				if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
					// 전쟁용 구조물 혹은 유니트가 적 NPC를 죽였다. 바로 통보한다.
					// 현재 서버에 지휘관이 있다면 곧바로 통보. 없으면 다른 서버로 알려줌.
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						
						m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						//testcode
						wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
						PutLogList(G_cTxt);
						// 지휘관에게 바로 통보.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
						goto NKH_GOTOPOINT1;
					}
				
					// 현재 서버에 없다. 다른 서버의 지휘관에게 알려야 한다.
					ZeroMemory(cData, sizeof(cData));
					cp = (char *)cData;
					*cp = GSM_CONSTRUCTIONPOINT;
					cp++;
					ip = (int*)cp;
					*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
					cp += 4;
					ip = (int*)cp;
					*ip = iConstructionPoint;
					cp += 4;
					bStockMsgToGateServer(cData, 9);
				}
			}
			break;
		}
	}
if ( (m_bIsHeldenianMode == TRUE) && (m_cHeldenianModeType == 1) 
&& (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) ) 
{ if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89)) 
{ 

if (m_pNpcList[iNpcH]->m_cSide == 1) 
{ m_iHeldenianAresdenLeftTower--; 
wsprintf(G_cTxt, "Aresden Tower Broken, Left TOWER %d", m_iHeldenianAresdenLeftTower); 
PutLogList(G_cTxt); 
bUpdateHeldenianStatus(-1); 
} 

else if (m_pNpcList[iNpcH]->m_cSide == 2) 
{ m_iHeldenianElvineLeftTower--; 
wsprintf(G_cTxt, "Elvine Tower Broken, Left TOWER %d", m_iHeldenianElvineLeftTower); 
PutLogList(G_cTxt); 
bUpdateHeldenianStatus(-1); 
} 
if ((m_iHeldenianElvineLeftTower == 0) || (m_iHeldenianAresdenLeftTower == 0)) { 
GlobalEndHeldenianMode(); 

} 
}
}
NKH_GOTOPOINT1:;

	// v1.411 만약 Explosive한 몬스터가 죽은 거라면 Explosive
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}
	else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}
	
	// InferniaA
	if ((m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) &&
			(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 1) &&
			(memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "inferniaA", 9) == 0)) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsInferniaAGate = TRUE;
	}
	
	// InferniaB
	if ((m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) &&
			(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 1) &&
			(memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "inferniaB", 9) == 0)) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsInferniaBGate = TRUE;
	}
	
	// Procella
	if ((m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) &&
			(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 1) &&
			(memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "procella", 8) == 0)) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsProcellaGate = TRUE;
	}
	
	// Abaddon
	if ((m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) && (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == 2)) {
		bApocalypseMobGenerator(m_pNpcList[iNpcH]->m_cMapIndex);
	}
	
	int iMapIndex;
	if (m_pNpcList[iNpcH]->m_bIsBossMob == TRUE) {
		iMapIndex = NULL;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (iMapIndex >= 0) && (iMapIndex < DEF_MAXMAPS) && (m_pMapList[iMapIndex] != NULL) && (m_pMapList[iMapIndex]->m_bIsRecallImpossible == TRUE)) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 200;
				m_pClientList[i]->m_bIsImpossibleZone = TRUE;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_RECALLTIMELEFT,  m_pClientList[i]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		}
	}

	if (m_bIsRushNetMode == TRUE)
	{
		if (m_pNpcList[iNpcH]->m_sType == 92)
		{		
			if (m_pNpcList[iNpcH]->m_cSide == 1)
				LocalEndRushNetMode(1);
			else if (m_pNpcList[iNpcH]->m_cSide == 2)
				LocalEndRushNetMode(2);
		}
		int Structures;
		Structures = 0;
		if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89) || (m_pNpcList[iNpcH]->m_sType == 39)) {
			if (m_pNpcList[iNpcH]->m_cSide == 1)
			{
				m_iHeldenianAresdenLeftTower--;
				if (m_iHeldenianAresdenLeftTower == 0)
					Structures = 1;
			}
			else if (m_pNpcList[iNpcH]->m_cSide == 2)
			{
				m_iHeldenianElvineLeftTower--;
				if (m_iHeldenianElvineLeftTower == 0)
					Structures = 2;
			}
			UpdateRushNet(Structures);
		}
	}	
	
}


void CGame::NpcBehavior_Dead(int iNpcH)			   
{
 DWORD dwTime;

	if (m_pNpcList[iNpcH] == NULL) return; 

	dwTime = timeGetTime();
	// 턴 카운트 증가.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		// 먼저 턴 카운트 클리어.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
	}
	// 
	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
 register int ix, iy, iDangerValue;
 short sOwner, sDOType;
 char  cOwnerType;
 DWORD dwRegisterTime;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
	for (iy = dY - 2; iy <= dY + 2; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);	
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject( ix, iy, &sDOType, &dwRegisterTime );
		
		if (sDOType == 1) iDangerValue++;

		switch (cOwnerType) {
		case NULL:
			break;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		}
	}

	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
 char cDir;
 short sX, sY, dX, dY;
 short sTarget;
 char  cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	// 턴 카운트 증가. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	// 공격 인공지능에 대한 효과계산.
	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case DEF_ATTACKAI_EXCHANGEATTACK: // 공격 -> 후퇴 -> ... 
	case DEF_ATTACKAI_TWOBYONEATTACK: // 공격 -> 공격 -> 후퇴 -> ...
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
			// 다시 공격 모드로 전환.
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;
	
	default:
		if (iDice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		// 10번의 턴만 도망한 후 다시 이동모드로 변환.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); // ! 에너지 부족으로 도망쳤을때 성공적으로 도망쳤으므로 에너지 증가.
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	// 도망치는데 위협이 되는 가까운 목표물을 검색한다.
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	// 목표물과 자신의 위치를 구한다. 반대방향으로 도망치기 위함.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case DEF_OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
		cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	}
	else {
		cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize, iNpcH);
	}
	if (cDir == 0) {
		// 이동할 수 없다. 
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		// 예전 위치에서 지운다. 
		if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		}
		else {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
		}
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
	}
}


void CGame::MsgProcess()
{
 char   * pData, cFrom, cKey;
 DWORD    dwMsgSize, * dwpMsgID;
 WORD   * wpMsgType, * wp;
 int      i, iClientH;
 char   m_msgBuff[1000];



	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = TRUE;
		m_dwExitProcessTime  = timeGetTime();
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
		if (m_iMiddlelandMapIndex > 0) {
			SaveOccupyFlagData();
		}
		
		return;
	}
		
	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {
		
		//v1.31 처리하고 있는 메시지 갯수를 카운트한다.
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
		case DEF_MSGFROM_GATESERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_PARTYOPERATION:

				PartyOperationResultHandler(pData);
				break;
			
			case MSGID_SERVERSTOCKMSG:
				
				ServerStockMsgHandler(pData);
				break;
									
			case MSGID_SENDSERVERSHUTDOWNMSG:
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				switch (*wp) {
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
					break;
				
				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
					break;
				}

				// WLS로 셧다운한다는 메시지. 이 메시지가 전달되면 해당 WLS 전체의 새 사용자에 대한 접속이 거부된다. 이 게임서버만 받지 않는것이 아니다.
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;
			
			case MSGID_GAMESERVERSHUTDOWNED:
				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
				if (m_iMiddlelandMapIndex > 0) {
					SaveOccupyFlagData();
				}
				break;
			
			case MSGID_TOTALGAMESERVERCLIENTS:
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					
				//	PutLogList("(!) Game Server registration to Gate Server - Success!");
					m_bIsGateSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					
			//		PutLogList("(!) Game Server registration to Gate Server - Fail!");
			//		PutLogList(" ");
			//		PutLogList("(!!!) STOPPED!");
					break;
				}
				
			
				break;
			}
			break;
		
		case DEF_MSGFROM_CLIENT:
			dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
			switch (*dwpMsgID) {
				
			case DEF_REQUEST_RESURRECTPLAYER_YES:
				
				RequestResurrectPlayer(iClientH, TRUE);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, FALSE);
				break;
						
			case DEF_REQUEST_ANGEL: 
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;

			case DEF_STATUS_AFK: 
				SetAfkFlag(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case DEF_REQUEST_DESTINY:
				PlayerOrder_RequestDestiny(iClientH, pData);
				break;

			case DEF_REQUEST_COMMAND_001:
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
				break;

			case DEF_REQUEST_COMMAND_002:
				GetCrits(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				RequestNoticementHandler(iClientH, pData);
				break;
			
			case MSGID_BWM_COMMAND_SHUTUP:
				_BWM_Command_Shutup(pData);
				break;
			
			case MSGID_BWM_INIT:
				_BWM_Init(iClientH, pData);
				break;

			case MSGID_REQUEST_SETITEMPOS:
				_SetItemPos(iClientH, pData);
				break;
			
			case MSGID_ADMINUSER:
				RequestAdminUserMode(iClientH, pData);
				break;
			
			case MSGID_REQUEST_FULLOBJECTDATA:
				RequestFullObjectData(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;
			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_INITPLAYER:
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;
			
			case MSGID_ONLYCLIENT:
				break;
			
			case MSGID_REQUEST_INITDATA:
				RequestInitDataHandler(iClientH, pData, cKey);
				break;
			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;
			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;
			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				break;
			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				MsgChatHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;
				
			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIANTELEPORT:
				RequestHeldenianTeleport(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_NPCSPEAKTELEPORT:
				RequestNpcSpeakTeleport(iClientH, pData, dwMsgSize);
				break;
		





			case MSGID_REQUEST_HELDENIANNPC:
				RequestHeldenianScroll(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_TELEPORT_LIST:
				RequestTeleportListHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CHARGED_TELEPORT:
				RequestChargedTeleportHandler(iClientH, pData, dwMsgSize);
				break;
           //Title por E.K Code
		/*	char  *cp, cTmpName[21];
			WORD  * wp;
			int i;
			case MSGID_SEND_TITLEPOREK:
				cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, cp);
				cp += 20;
				for(i = 0; i < DEF_MAXCLIENTS; i++)
				{
					if ((m_pClientList[i] != NULL) && (memcmp (m_pClientList[i]->m_cCharName, cNick, strlen (cNick)) == 0))
					{
						if(m_pClientList[i]->m_iEnemyKillCount >= 100 && m_pClientList[i]->m_iEnemyKillCount <= 200)
						{	
							SendNotifyMsg(NULL, iClientH, MSGID_SEND_TITLEPOREKRANK, 1, NULL, NULL, NULL);
						}
						if(m_pClientList[i]->m_iEnemyKillCount >= 201 && m_pClientList[i]->m_iEnemyKillCount <= 400)
						{	
							SendNotifyMsg(NULL, iClientH, MSGID_SEND_TITLEPOREKRANK, 2, NULL, NULL, NULL);
						}
						if(m_pClientList[i]->m_iEnemyKillCount >= 401 && m_pClientList[i]->m_iEnemyKillCount <= 800)
						{	
							SendNotifyMsg(NULL, iClientH, MSGID_SEND_TITLEPOREKRANK, 3, NULL, NULL, NULL);
						}
						if(m_pClientList[i]->m_iEnemyKillCount >= 801 && m_pClientList[i]->m_iEnemyKillCount <= 1600)
						{	
							SendNotifyMsg(NULL, iClientH, MSGID_SEND_TITLEPOREKRANK, 4, NULL, NULL, NULL);
						}
						if(m_pClientList[i]->m_iEnemyKillCount >= 1601)
						{	
							SendNotifyMsg(NULL, iClientH, MSGID_SEND_TITLEPOREKRANK, 5, NULL, NULL, NULL);
						}
					}
				}
				break;*/

			case REQUEST_TOPMEMORY_EK: 
				this->HandleRequestMemoryTopEK(iClientH);
				break;

			default:
				wsprintf(m_msgBuff,"Unknown message received! (0x%.8X) Delete Client",*dwpMsgID);
				PutLogList(m_msgBuff);
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}	
			break;

		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				// 계정의 패스워드를 비교 
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				break;
			
			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				// 캐릭터의 데이터가 저장되었음을 알리는 메시지 
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_GUILDNOTIFY:
				// 다른 게임서버에서 발생한 길드 이벤트에 대한 통보(길드원 가입, 길드원 탈퇴, 길드 해산 등)
				GuildNotifyHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_DISBANDGUILD:
				// 길드 해산요구에 대한 응답 
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				// 캐릭터의 길드생성 요구에 대한 응답. 
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
				//	PutLogList("(!) Game Server registration to Log Server - Success!");
					m_bIsLogSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
				//	PutLogList("(!) Game Server registration to Log Server - Fail!");
					break;
				}
		
				if (m_bIsBuildItemAvailable == FALSE) {
					// 만약 빌드아이템 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}

				if (m_bIsItemAvailable == FALSE) {
					// 만약 아이템 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}
				
				if (m_bIsNpcAvailable == FALSE) {
					// 만약 아이템 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == FALSE) {
					// 만약 MAGIC 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == FALSE) {
					// 만약 SKILL 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == FALSE) {
					// 만약 SKILL 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPortionAvailable == FALSE) {
					// 만약 Portion 정의 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! POTION configuration error.");
				}

#ifdef DEF_DEFENCEHACKING
				// 2002-12-8 World server 보안 설정을 위해 
				if (m_bIsWLServerAvailable == FALSE) {
					// 만약 WLSERVER 화일에서 에러가 있었다면 게임서버 등록에 상관없이 동작 불가능.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! WLSERVER configuration error.");
				}

#endif 

		
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				// 플레이어 데이터가 도착했다. 
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				// Build Item contents
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_ITEMCONFIGURATIONCONTENTS:
				// 로그서버로부터 아이템 컨피규레이션 데이터가 도착했다.
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				// NPC 컨피규레이션 데이터가 도착했다. 
				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_MAGICCONFIGURATIONCONTENTS:
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_PORTIONCONFIGURATIONCONTENTS:
				PutLogList("(!) POTION configuration contents received. Now decoding...");
				m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

#ifdef DEF_DEFENCEHACKING
			// 2002-12-8 World server 보안 설정을 위해 
			case MSGID_WLSERVERFILECONTENTS:
				PutLogList("(!) WLSERVER configuration contents received. Now decoding...");
				m_bIsWLServerAvailable = _bDecodeWLServerConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

#endif 

			case MSGID_DUPITEMIDFILECONTENTS:
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			// v2.15  2002-5-21
			case MSGID_WORLDCONFIGCONTENTS:
				PutLogList("(!) WorldConfig file contents received. Now decoding...");
				_bDecodeWorldConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			// v2.17 2002-8-7 // 2002-09-06 #1
			case MSGID_NPCITEMCONFIGCONTENTS:
				PutLogList("(!) NpcItemConfig file contents received. Now decoding...");
				_bDecodeNpcItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			// 2002-12-6  Teleport 기능 추가
			case MSGID_TELEPORTLISTCONTENTS:
				PutLogList("(!) TeleportListConfig file contents received. Now decoding...");
		    	_bDecodeTeleportListConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
			}
			break;
		}
	}
}


BOOL CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{

	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;
	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;
	return TRUE;
}


BOOL CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{

	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

	return TRUE;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
 WORD * wp, wCommand;
 short * sp, sX, sY; 
 int   * ip, iV1, iV2, iV3, iV4;
 char  * cp, cDir, * pString;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;
 
	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;
	
	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;
	
	
	switch (wCommand) {
	// 2002-11-14 사냥꾼 모드 추가
	case DEF_COMMONTYPE_REQUEST_HUNTMODE:
		RequestHuntmode(iClientH);
		break;

	// v2.171 2002-6-14
	case DEF_COMMONTYPE_REQGUILDNAME:
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_UPGRADEITEM:
		RequestItemUpgradeHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQTPDG: // MORLA 2.3 - TP Deathmach Game
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQGUILDNAME");
		if (m_pClientList[iClientH]->m_iLevel > 79) {
			if (DeathMatch == TRUE)
			{
				RequestTeleportHandler(iClientH, "2   ", "deathmach", -1, -1);
				RefreshDeathmach(iClientH); // Morla 2.3 - actualiza el deathmach
				m_pClientList[iClientH]->m_iDGKills = 0;
				m_pClientList[iClientH]->m_iDGDeaths = 0;
			}
			else
			{
				ShowClientMsg(iClientH, "Deathmatch est desactivado.");
				ShowClientMsg(iClientH, "Inicia sorpresivamente");
			}
		}
		else ShowClientMsg(iClientH, "Necesitas Level mayor a 80.");
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		// iV1의 값이 가입 신청 허가 여부이다.
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;
		
	case DEF_COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;
	
	case DEF_COMMONTYPE_GUILDTELEPORT:
		RequestGuildTeleportHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_SUMMONWARUNIT:
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQUEST_HELP:
		RequestHelpHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		CancelQuestHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		ActivateSpecialAbilityHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		JoinPartyHandler(iClientH, iV1, pString);
		break;
	
	//case DEF_COMMONTYPE_REQUEST_CREATENEWPARTY:
	//	CreateNewPartyHandler(iClientH);
	//	break;
	
	case DEF_COMMONTYPE_GETMAGICABILITY:
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		BuildItemHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_QUESTACCEPTED:
		QuestAcceptedHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		CancelExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		ConfirmExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		SetExchangeItem(iClientH, iV1, iV2);
		break;

	//NetPanel -Trade EK
    case DEF_COMMONTYPE_REQ_GETTRADEEKITEMS:
		GetTradeEkItemsHandler(iClientH, iV1, pString);
        break;

	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		GetHeroMantleHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQ_GETDK:
		GetDkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		NpcTalkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_CREATEPOTION:
		ReqCreatePortionHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		ReqGetFishThisTimeHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEM:
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_USESKILL:
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQ_USEITEM:
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;
	
	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		// v2.17 2002-7-31 케릭터 사망시 떨어트린 모든 아이템을 로그에 남기기 위해 
		DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
		break;
	
	case DEF_COMMONTYPE_EQUIPITEM:
		// 여기서는 특성치 변화만을 다룬다.
		bEquipItemHandler(iClientH, iV1);
		// 바뀐 외형에 대한 정보를 여기서 전송한다.
		// .....
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		// 아이템 구입 요구. 사실 아이템은 장소에 상관없이 어디서라도 구입할 수 있다.
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_PURCHASEITEM2:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_PURCHASEITEM");
		// 아이템 구입 요구. 사실 아이템은 장소에 상관없이 어디서라도 구입할 수 있다.
		RequestPurchaseItemHandler2(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		// 마법을 배운다 
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		// 아이템을 다른 캐릭터에게 전달한다.
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		JoinGuildApproveHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_JOINGUILDREJECT:
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		// 클라이언트가 장착된 아이템을 해제했다.
		ReleaseItemHandler(iClientH, iV1, TRUE);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		// v2.17 2002-7-24  탭키를 이용한 속도 못하게 수정
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		ToggleSafeAttackModeHandler(iClientH);
		break;

	// v1.4311-3 추가 입장권 받기  case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		GetFightzoneTicketHandler(iClientH);
		break;

	case DEF_COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break;

	//ZeroEoyPnk - Repair All
	case DEF_COMMONTYPE_REPAIR_ALL:
		int i;
		for (i = 0; i < 50; i++)
			ReqRepairItemCofirmHandler(iClientH, i, NULL);
		break;

	//ZeroEoyPnk - NewMessage
	case DEF_RESQUEST_PARTYHP:
		RefreshPartyStatus(iClientH);
		RefreshPartyCoords(iClientH);
		break;

	case DEF_RESQUEST_PLAYERREP:
		SendNotifyMsg(NULL, iClientH, DEF_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
		break;
	}
}

// v2.17 2002-7-31 케릭터 사망시 떨어트린 모든 아이템을 로그에 남기기 위해 
void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, BOOL bByPlayer)
{
 class CItem * pItem;	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;  //DEBUG
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((iAmount != -1) && (iAmount < 0)) return;
   	if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 3)) return;
	if  (memcmp(m_pClientList[iClientH]->m_cMapName, "deathmach", 9) == 0) return;
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		   (iAmount == -1) ) 
		 iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;	
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;
	
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		   (((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0) ) {
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			delete pItem;
			return;
		}
		else {
			if (iAmount <= 0) {
				delete pItem;
				return;
			}
			pItem->m_dwCount = (DWORD)iAmount;
		}
		if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
			delete pItem;
			return;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
		                                                         m_pClientList[iClientH]->m_sY, pItem);
		if ( bByPlayer == TRUE )
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
		else 
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem, TRUE);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
	}
	else {	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
		if ( m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
			delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		}
		else {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
 																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			if ( bByPlayer == TRUE )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], TRUE);
		
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	iCalcTotalWeight(iClientH);
}

int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
 char  cRemainItemColor, cData[100];
 int   iRet, iEraseReq;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// 스킬의 사용상태를 모두 무효화 한다.
	ClearSkillUsingStatus(iClientH);

	// 죽은 위치에 있었다면 지운다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// 다시 위치 시킨다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
	if (pItem != NULL) {
		// 플레이어가 아이템을 획득하였다. 
		
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			// 아이템을 획득했다.

			// v1.41 희귀 아이템이라면 로그를 남긴다. 
			_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;
			
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			 
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor; // v1.4
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;
			
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			
			*cp = (char)pItem->m_sItemSpecEffectValue3;
			cp++;
			/*
			*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
			cp++;
			*/

			if (iEraseReq == 1) delete pItem;

			// 아이템을 줍고난 후 남은 아이템을 다른 클라이언트에게 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				                        sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			// 아이템 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
						
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		else 
		{
			// 공간이 부족하거나 한계중량을 초과했다. 아이템을 얻을 수 없다.
			
			// 가져왔던 아이템을 원상회복시킨다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);
			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
	}

	// 클라이언트가 MSGID_RESPONSE_MOTION메시지를 받아야만 계속 명령을 전송할 수 있다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

BOOL CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	
	// 집을 아이템 중량계산  
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// 수량개념이 있는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// 수량 개념이 없는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	
	// 소비성 아이템을 이미 소지하고 있다면 수량만 증가시킨다. 
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
			 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {
			// 같은 이름을 찾았다. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
			//delete pItem;
			*pDelReq = 1;
			
			// 소지품 총 중량 재 계산 
			iCalcTotalWeight(iClientH);
			
			return TRUE;
		}
	}
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemList[i] = pItem;
		// v1.3 아이템의 위치는 무조건 100, 100
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

		*pDelReq = 0;

		// 만약 화살류 아이템이라면 화살을 할당한다. 
		if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);
		
		return TRUE;
	}

	// 더이상 아이템을 집을 공간이 없다.
	return FALSE;
}


BOOL CGame::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify)
{
 char  cEquipPos, cHeroChecker;
 short sTemp, sSpeed;
 int   iTemp;
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;
	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL)  &&
	    (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
			break;
		case 4:
		case 5:
		case 6:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
			break;
		}
	}
	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)*100) return FALSE;
	//
	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	//
	if ( (bAllVsAll) && ((cEquipPos == DEF_EQUIPPOS_BODY)     ||
						 (cEquipPos == DEF_EQUIPPOS_LEGGINGS) ||
						 (cEquipPos == DEF_EQUIPPOS_ARMS)     ||
						 (cEquipPos == DEF_EQUIPPOS_HEAD)     ||
						 (cEquipPos == DEF_EQUIPPOS_BACK)) ) return FALSE;

	if ((m_cPvpEvent==TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone1") == 0))
	{
		if (((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS)||(cEquipPos == DEF_EQUIPPOS_PANTS) || (cEquipPos == DEF_EQUIPPOS_HEAD) || (cEquipPos == DEF_EQUIPPOS_ARMS)|| (cEquipPos == DEF_EQUIPPOS_BACK)||(cEquipPos == DEF_EQUIPPOS_LHAND))&&(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute !=0))
		{
			m_pClientList[iClientH]->m_iHP = 0;
			m_pClientList[iClientH]->m_bIsKilled = TRUE;

			RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 1, NULL, NULL);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		}
		if(cEquipPos == DEF_EQUIPPOS_NECK)
		{
			m_pClientList[iClientH]->m_iHP = 0;
			m_pClientList[iClientH]->m_bIsKilled = TRUE;
			RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 1, NULL, NULL);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		}
	}
	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) || (cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: // Str
			if ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 11: // Dex
			if ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 12: // Vit
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 13: // Int
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 14: // Mag
			if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		}
	}
	
	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		// Stormbringer
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
			if((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) < 65){
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex , TRUE);
				return FALSE;
			}
		}
	}

	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
			// Barbarian Wand
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3177) {
				if((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) < 199){
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] , TRUE);
					return FALSE;
				}
			}
		}

		
	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		// Resurrection wand(MS.10) or Resurrection wand(MS.20)
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
			if(((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt)) > 99 && ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag)) > 99 &&  m_pClientList[iClientH]->m_iSpecialAbilityTime < 1) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
			}
		}
	}

	// 만약 장착한 아이템이 특수 능력을 가지고 있는데 이미 특수능력이 설정되어 있으면 이전에 장착한 아이템을 해제.
	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {
		
		if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
			// 이미 특수능력이 설정되어 있다. 이전에 장착되어 있는 아이템 착용 해제:
			// 단, 착용 부위가 같다면 해제 메시지 보내지 않는다.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
				// 해당 착용 부위의 아이템효과를 제거.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
			}
		}
	}
	
	// 장착할 수 없는 아이템을 장착시도했을 경우 무시 
	if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		// 양손을 사용하는 무기가 장착되어 있다면  
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			// 오른손, 왼손에 아이템이 있다면 모두 장착 해제 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], FALSE);
		}
	}
	else {
		// 양손 아이템이 장착되어 있다면 해제시킨다.
		if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
			// 무기나 방패류라면 양손무기를 해제 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], FALSE);
		}
		
		// 장착위치에 아이템이 이미 있으면 삭제.
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}
	
	if(cEquipPos == DEF_EQUIPPOS_FULLBODY)	{
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ], TRUE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ], FALSE);
			
		}
	}
	else
	{
		// 일체형 아이템이 장착되어 있다면 해제시킨다.
		if ((cEquipPos == DEF_EQUIPPOS_HEAD) 
			|| (cEquipPos == DEF_EQUIPPOS_BODY)
			|| (cEquipPos == DEF_EQUIPPOS_ARMS)
			|| (cEquipPos == DEF_EQUIPPOS_LEGGINGS)
			|| (cEquipPos == DEF_EQUIPPOS_PANTS)
			|| (cEquipPos == DEF_EQUIPPOS_BACK)) {
			// 일체형 아이템 부분에 일체형 아이템을 해제 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_FULLBODY ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_FULLBODY ], FALSE);
		}
		
		// 장착위치에 아이템이 이미 있으면 삭제.
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);

	}
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;
	
	// @@@@ 장착상태가 변경된 것과 관련하여 Appr변수를 조정한 후 통보한다.
	// 아이템의 장착위치에 맞게 Appr변수를 조정한다.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// 오른손에 장착하는 아이템. 무기류이다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// 무기 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0x0FFFFFFF; // 무기 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		
		// 무기 속도를 나타내는 Status의 비트를 설정한다.
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		// Str에 따라 무기 속도를 줄인다. 

		// v2.15 활버그 수정을 위해 루틴추가 
		m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;

		
#ifdef DEF_WEAPONSPEEDLIMIT
		// v2.16 2002-5-27 
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) {
		//case 6:  if (sSpeed < 1) sSpeed = 1; break; // 활
		//case 7:  if (sSpeed < 0) sSpeed = 0; break; // 짧은칼
		//case 8:  if (sSpeed < 2) sSpeed = 2; break; // 긴칼
		//case 9:  if (sSpeed < 1) sSpeed = 1; break; // 펜싱
		//case 10: if (sSpeed < 3) sSpeed = 1; break; // 도끼 
		case 14: if (sSpeed < 1) sSpeed = 1; break; // 해머 
		default: if (sSpeed < 0) sSpeed = 0; break; // 기타 
		}
#else
		sSpeed -= ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (sSpeed < 0) sSpeed = 0;
#endif
		iTemp = iTemp | sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		// v2.15 연타 카운트 클리어
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_LHAND:
		// 왼손에 장착하는 아이템. 방패류이다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// 무기 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		
		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xF0FFFFFF; // 방패 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// 양손타입이지만 사실 오른손에 장착된다. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// 무기 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		
		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0x0FFFFFFF; // 무기 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// 무기 속도를 나타내는 Status의 비트를 설정한다.
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);


		// v2.15 활버그 수정을 위해 루틴추가 
		m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;
		// Str에 따라 무기 속도를 줄인다. 

#ifdef DEF_WEAPONSPEEDLIMIT
		// v2.16 2002-5-27 
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) {
		//case 6:  if (sSpeed < 1) sSpeed = 1; break; // 활
		//case 7:  if (sSpeed < 0) sSpeed = 0; break; // 짧은칼
		//case 8:  if (sSpeed < 2) sSpeed = 2; break; // 긴칼
		//case 9:  if (sSpeed < 1) sSpeed = 1; break; // 펜싱
		//case 10: if (sSpeed < 3) sSpeed = 1; break; // 도끼 
		case 14: if (sSpeed < 1) sSpeed = 1; break; // 해머 
		default: if (sSpeed < 0) sSpeed = 0; break; // 기타 
		}
#else
		sSpeed -= ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (sSpeed < 0) sSpeed = 0;
#endif

		iTemp = iTemp | sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		// v2.15 연타 카운트 클리어
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// 겉옷 특성치 비트를 클리어.

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
			// 외형값이 100 이하. 정상적인 값 
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr 값을 세팅. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
		}
		else {
			// 외형값이 100 이상이면 확장 플래그를 사용한다. 
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr 값을 세팅. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
			// 겉옷 확장 특성치 비트를 세트.
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp | 0x080;	
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
		}

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFF0FFFFF; // 겉옷(갑옷) 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// 망토 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFF0FFFF; // 망토 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// 속옷 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFF0FFF; // 속옷 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// 바지 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFF0FF; // 바지 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// 부츠 특성치 비트를 클리어.    111111111111
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFFF0F; // 부츠 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// 투구 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFFFFFF0; // 투구 색 비트를 클리어.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_FULLBODY: //v2.19 2002-12-7 산타복 관련 	
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// 겉옷 특성치 비트를 클리어.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr 값을 세팅. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 컬러값 세팅 
		iTemp = iTemp & 0xFFF0FFFF; // 색 비트를 클리어.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}

	//v1.432 특수 능력이 부여된 아이템이라면 플래그 설정 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// 공격 특수 능력 비트 클리어
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;     // 1111111111110011   
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 1: // 공격시 50% HP 감소
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	// 0100
			break;

		case 2: // 냉동 효과 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	// 1100
			break;

		case 3: // 마비 효과 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	// 1000
			break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// 방어구 특수 능력 비트 클리어
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC; // 1111111111111100
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 50: // v2.15 2002-5-15 고광현수정
		case 51:
		case 52: // 녹색
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;	// 10
			break;

		default: // GM임을 나타낼 수 있는 효과.
#ifndef DEF_KOREA
			// 진호씨에게 물어볼것 
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 1 ) break ;
#endif
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;	 // 01
			break;
		}
	}
	
	// v2.23 22/04/06 15:24 HeroBonus 
	cHeroChecker = CheckHeroItemEquipHandler(iClientH);
	if (cHeroChecker != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroBonus = cHeroChecker;

	// 외형이 바뀐것을 알린다.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// @@@@ 또한 캐릭터의 특성치 변화를 계산한다. 
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);

	return TRUE;
}

// 2002-12-11 중국 관련 해킹 방지 루틴 추가
void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
 int i, iRet, iShortCutIndex;
 char  * cp, cData[100];
 DWORD * dwp, dwTime;
 WORD * wp;
 short * sp;
 BOOL bFlag;
 char  cKey ;

	cKey = (char)(rand() % 255) +1; // v1.4

	ZeroMemory(cData, sizeof(cData));
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = TRUE;
	iShortCutIndex = 0;
	while (bFlag == TRUE) {
		// DEF_MAXCLIENTS 까지 루프를 돌지 않기 위한 방법. 클라이언트 숏컷 리스트에서 0이 나오면 끝이다.
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;

		if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {
			if ( (m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				 (m_pClientList[i]->m_sX >= sX - 10) &&
				 (m_pClientList[i]->m_sX <= sX + 10) &&
				 (m_pClientList[i]->m_sY >= sY - 8 ) &&
				 (m_pClientList[i]->m_sY <= sY + 8 ) ) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18, cKey);
			}
		}
	}
}

int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 short   sOwnerH;
 char    cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// 죽은척하기 중 일어나는데 위에 물체가 있으면 접속을 종료시킨다.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);		
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	// 스킬의 사용상태를 모두 무효화 한다. //!!!!
	ClearSkillUsingStatus(iClientH);

	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// 방향을 바꾼다.
	m_pClientList[iClientH]->m_cDir = cDir;
	
	// 죽은 위치에 있었다면 지운다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// 다시 위치 시킨다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	
	// 클라이언트가 MSGID_RESPONSE_MOTION메시지를 받아야만 계속 명령을 전송할 수 있다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// 쨌짹 쩌짯쨔철쨌쨘 짹챈쨉책 쨩첵쩌쨘 쩔채쨩쩔징 쨈챘 쨈채쨉짜째징 쨉쨉첩쨈. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// 쨍짠 징쨈 짭쨋처쩐챨짰쨍짝 짙쨈쨈.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
		(m_pClientList[i]->m_iLevel >= 99) && (m_pClientList[i]->m_iCharisma >= 20)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// 짭쨋처쩐챨짰 짹챈쨉책 쨩첵쩌쨘 쩔채짹쨍째징 쩌쨘째첩쩔쨈쨈. 
			wResult = DEF_MSGTYPE_CONFIRM;
			// 짹챈쨉책 쨍짠쨘 쨔 첬책쨉쩐챤 쨍쨔쨌 쨌짤짤쨍짝 0쨍쨌 쨔짼찾 짱쩔짯 쨈.
			m_pClientList[i]->m_iGuildRank = 0;	// 짹챈쨉책 쨌짤짤쨈 0. 짹챈쨉책쨍쨋쩍쨘 
			wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// 짭쨋처쩐챨짰 짹챈쨉책 쨩첵쩌쨘 쩔채짹쨍째징 쩍쩔쨈쨈.
			// 쨈챌 짭쨋처쩐챨짰 짹챈쨉책쨍짠쨩 짹창짯쨈 "NONE".
			wResult = DEF_MSGTYPE_REJECT;
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;  
			m_pClientList[i]->m_iGuildGUID = -1;
			SetItemCount(i, "Gold", dwGetItemCount(i, "Gold") + dwCreateGuildGoldCost);
			iCalcTotalWeight(i);
			wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CREATENEWGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// 짹챈쨉책 쨩첵쩌쨘 쩔채짹쨍 쨈채 쨍쩍철쨍짝 짭쨋처쩐챨짰쩔징째 체쩌
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 쨍쩍철쨍짝 쨘쨍쨀쩐쨋짠 쩔징쨌짱째징 쨔쨩첵쨈쨍챕 짝째쨈.
			DeleteClient(i, TRUE, TRUE);
			return;
		}

		return;
	}

	// 쨍짠 징쨈 짭쨋처쩐챨짰쨍짝 짙쨩 쩌철 쩐첩쨈.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}
void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
char * cp, cGuildName[21], cTxt[120], cData[100];
DWORD * dwp, dwGoldCount;
WORD  * wp;
int     iRet;
SYSTEMTIME SysTime;
char cGoldValueInfo[100];

if (m_pClientList[iClientH] == NULL) return;
if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
if (m_bIsCrusadeMode == TRUE) return;

cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

cp += 10;
cp += 10;
cp += 10;

ZeroMemory(cGuildName, sizeof(cGuildName));
memcpy(cGuildName, cp, 20);
cp += 20;
dwGoldCount = dwGetItemCount(iClientH, "Gold");
if (m_pClientList[iClientH]->m_iGuildRank != -1) {

 wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
 PutLogList(cTxt);
}
else {
 
 if ( (m_pClientList[iClientH]->m_iLevel < 100) || (dwGetItemCount(iClientH, "Gold") < DEF_GUILDCOST) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
   (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
   
   (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0) ) { // v1.4
  // CCACACACCC ACCC ACACAC. CAAArCA?AA? AAACAAR AACACC CACA?AA? ACAAACAAR ACAC?CC ACAC ACAC  
  ZeroMemory(cData, sizeof(cData));

  dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
  *dwp = MSGID_RESPONSE_CREATENEWGUILD;
  wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
  *wp  = DEF_MSGTYPE_REJECT;

  // ACAC? ACAAr ACAA CCAC AC?ACCCAA CAACCCACCAAA?AC CCAC
  iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
  switch (iRet) {
  case DEF_XSOCKEVENT_QUENEFULL:
  case DEF_XSOCKEVENT_SOCKETERROR:
  case DEF_XSOCKEVENT_CRITICALERROR:
  case DEF_XSOCKEVENT_SOCKETCLOSED:
   // AC?ACCCAA ArAAAAA AA?AAAA? ACACCCACAC CAACCCAC.
   DeleteClient(iClientH, TRUE, TRUE);
   return;
  }
 }
// here the hg watch does u have 1000000 gold
else if(dwGoldCount < DEF_GUILDCOST){ 
  
  ZeroMemory(cData, sizeof(cData));

  dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
  *dwp = MSGID_RESPONSE_CREATENEWGUILD;
  wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
  *wp  = DEF_MSGTYPE_REJECT;

  // ACAC? ACAAr ACAA CCAC AC?ACCCAA CAACCCACCAAA?AC CCAC
  iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
  switch (iRet) {
  case DEF_XSOCKEVENT_QUENEFULL:
  case DEF_XSOCKEVENT_SOCKETERROR:
  case DEF_XSOCKEVENT_CRITICALERROR:
  case DEF_XSOCKEVENT_SOCKETCLOSED:
   // AC?ACCCAA ArAAAAA AA?AAAA? ACACCCACAC CAACCCAC.
   DeleteClient(iClientH, TRUE, TRUE);
   return;
  }
			if(dwGetItemCount(iClientH, "Gold") < DEF_GUILDCOST){
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; // -1쨍챕 쨔쩐첩쨈.
				cp++;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				
				ZeroMemory(cGoldValueInfo, sizeof(cGoldValueInfo));
				wsprintf(cGoldValueInfo, " The price for creating a guild is %lu gold.", dwCreateGuildGoldCost);
				ShowClientMsg(iClientH, cGoldValueInfo);
			}
		}
		else {
	   		SetItemCount(iClientH, "Gold", dwGetItemCount(iClientH, "Gold") - DEF_GUILDCOST);
			iCalcTotalWeight(iClientH);
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
			
			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		// 길드마스터가 아니거나 길드의 이름이 다르므로 길드해산의 권한이 없다.
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
	bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);

	
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// 로그 서버로부터 길드 해산 요청에 대한 응답데이터가 도착했다. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// 이름이 일치하는 클라이언트를 찾는다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// 클라이언트의 길드 해산 요구가 성공하였다. 
			wResult = DEF_MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			
			// 접속중인 길드원들에게 길드가 해산되었음을 알리는 메시지를 전송한다. 
			SendGuildMsg(i,	DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
			
			// 길드이름 클리어
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;		// 길드 랭크는 -1. 길드원이 아니다. 
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// 클라이언트의 길드 해산 요구가 실패하였다.
			wResult = DEF_MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_DISBANDGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// 길드 해산 요구 응답 메시지를 클라이언트에게 전송
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
		return;
	}

	// 이름이 일치하는 클라이언트를 찾을 수 없다.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwGoldCount, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq, iGoldWeight;
 int   iCost,iCost2, iDiscountRatio, iDiscountCost;
 double dTmp1, dTmp2, dTmp3;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	// 만약 아이템을 구입하고자 하는 곳이 자신의 마을이 아니라면 구입할 수 없다. 
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.

	// 2002-11-15 사고 팔수 있는 곳인지 체크하는 변수 추가
	// if (m_pClientList[iClientH]->m_cSide != DEF_NETURAL && m_pClientList[iClientH]->m_bIsOnShop == FALSE ) {
	if ( m_pClientList[iClientH]->m_bIsOnShop == FALSE ) {
		return;
	}
	
	// 아이템을 구입한다. 
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));

// v2.14 영문 아이템 이름을 위해 

	if (memcmp(pItemName, DEF_ITEMNAME_10ARROWS, 8) == 0) {
		strcpy(cItemName, DEF_ITEMNAME_ARROW);
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, DEF_ITEMNAME_100ARROWS, 9) == 0) {
		strcpy(cItemName, DEF_ITEMNAME_ARROW);
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}
		
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {

			// 구입하고자 하는 아이템이 아이템 리스트상에 없다. 구입이 불가능하다.
			delete pItem;
		}
		else {
			
			if (pItem->m_bIsForSale == FALSE) {
				// 판매되는 아이템이 아니다. 살 수 없다.

				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;

			// v2.14 상점 아이템에도 고유 코드 입력 
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			
#ifdef DEF_LOGTIME
			pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
			// 마지막 숫자는 아이템 생성 월, 일	
			SYSTEMTIME SysTime;
			char cTemp[20] ;

			GetLocalTime(&SysTime); //
			ZeroMemory(cTemp, sizeof(cTemp));
//			wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
			wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif				
			//v2.19 2002-11-14 물가 가격 계산 부분 전면전 이긴쪽은 쫌 싸다... -_-.
#ifdef DEF_V219  
			if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			{
				iCost =(int)((float)(pItem->m_wPrice) * 0.9f + 0.5f) ;
				// 가격을 계산한다.
				iCost = iCost * pItem->m_dwCount;
				iCost2 = pItem->m_wPrice * pItem->m_dwCount;
			}
			else
			{
				// 가격을 계산한다.
				iCost2 = iCost = pItem->m_wPrice * pItem->m_dwCount;
			}

			//2009-04-19
			char cLost = 0; 
			if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
			{
				switch(m_sLastHeldenianWinner){
				case 1:
					cLost = 2;
					break;
				case 2:
					cLost = 1;
					break;
				}
				if(cLost == m_pClientList[iClientH]->m_cSide){
					iCost =(int)((float)(pItem->m_wPrice) * 2.0f) ;
					iCost = iCost * pItem->m_dwCount;
					iCost2 = pItem->m_wPrice * pItem->m_dwCount;
				}
			}


#endif

			// 플레이어가 소지한 Gold가 아이템을 사기에 충분한지 검사한다.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			// Charisma에 따른 할인률을 계산한다. 
			// v2.14 카리스마가 10인경우 아이템을 할인 하지 않음 
			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -10)/ 4) ;
			
			// Charisma에 따른 할인률을 계산한다. 
		//	iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
		//	if (iDiscountRatio == 0) iDiscountRatio = 1;
			
			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
				
#ifdef DEF_V219  
			//물건가격의 절반이상은 절대 안싸진다.(물가+카리스마 적용을 하더라도...)
			if ((iCost - iDiscountCost) <= (iCost2/2)) {
				iDiscountCost = iCost - (iCost2/2) + 1; 
			}
#else
			if (iDiscountCost >= (iCost/2)) iDiscountCost = (iCost/2)-1;
#endif

			if ( dwGoldCount < (DWORD)(iCost - iDiscountCost) ) {
				// 플레이어가 갖고있는 Gold가 아이템 가격에 비해 적다. 살수 없음.

				delete pItem;
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; // -1이면 의미없다.
				cp++;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 에러 방지용 코드
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// 아이템 샀다는 메시지를 전송한다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMPURCHASED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1개 획득했다.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;
				
				wp  = (WORD *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;
				
				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}
				
				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
	
				// Gold의 수량을 감소시킨다. 반드시 여기서 세팅해야 순서가 바뀌지 않는다.
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);

				//v1.4 마을의 자금에 더한다. 
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;
				
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);

					return;
				}
			}
			else 
			{
				// 공간이 부족해 아이템을 얻을 수 없다.
				delete pItem;

				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
	} 
}


// MORLA 2.4 - Trade Items

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2, char cValueA)
{
 char cData[1000];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 int   * ip, iRet, i;
// int iLogServerPort;
	if (m_pClientList[iToH] == NULL) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);
	switch (wMsgType) {
	case DEF_NOTIFY_ALLVSALLWINNER:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	case DEF_NOTIFY_STONEKILLED:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;
	case DEF_NOTIFY_STONEWINNER:
		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iContribution;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;
	case DEF_NOTIFY_STONESON:
	case DEF_NOTIFY_STONESOFF:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_ALLVSALLON:
		ip = (int *)cp;
		*ip = sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	case DEF_NOTIFY_ALLVSALLOFF:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_CIVILCHANGED:
		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
	break;

	case DEF_NOTIFY_STATUS_FIXED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		cp += 14;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;
	//npc hp bar by necru
	case DEF_NOTIFY_NPCBAR:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_NPCBAR2:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_DESTINY:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;


	//2009-03-18
	case DEF_NOTIFY_CITYWARBEGIN:
	case DEF_NOTIFY_CITYWARDATE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_CITYWAREND:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	case DEF_NOTIFY_HELDENIANCOUNT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		cp += 14;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);

		break;
	
	case DEF_NOTIFY_QUESTCOUNTER:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_HELDENIANPRICES:
		*cp = (char)sV1;
		cp++;
		*cp = (char)sV2;
		cp++;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	case DEF_NOTIFY_HELDENIANVICTORY: // Case BEB of switch 00454077
		sp = (short *)cp;
		*cp = (char)sV1;
		cp += 2;
        
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	// 2002-11-14 사냥꾼 모드 추가
	case DEF_NOTIFY_RESPONSE_HUNTMODE:
		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	// v2.171 2002-6-14
	case DEF_NOTIFY_REQGUILDNAMEANSWER:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;
		
		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
	
	case DEF_NOTIFY_PARTY:
		switch (sV1) {
		case 4:
		case 6:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp, pString, 10);
			cp += 10;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + 10);
			break;
		
		case 5:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			memcpy(cp, pString, sV3*11);
			cp += sV3*11;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + sV3*11);
			break;
		
		default:
			wp  = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;
			wp  = (WORD *)cp;
			*wp = (WORD)sV4;
			cp += 2;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
			break;
		}
		break;

	case DEF_NOTIFY_GRANDMAGICRESULT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		// v2.15 전면전시 건물의 HP를 보여주기 위해 추가. 

//		sp = (short *)cp;
//		*sp = (short)sV9;
//		cp += 2;

		// 건물 숫자가 0 인경우를 대비한 루틴 
		if (sV9 > 0)  {
			memcpy(cp,pString2, (sV9+1)*2) ;
			cp += (sV9+1)*2;
		}
		else 
		{
			sp = (short *)cp;
			*sp = (short)0;
			cp += 2;
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24 + (sV9+1)*2 );
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
		
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
		
	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
		
	case DEF_NOTIFY_CANNOTCONSTRUCT:
	case DEF_NOTIFY_METEORSTRIKECOMING:
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_OBSERVERMODE:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;

	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
		// v2.16 2002-5-21 고광현 수정 
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 20);
		break; 

	case DEF_NOTIFY_ITEMUPGRADEFAIL:
		// v2.17 2002-7-21 
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;		

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);

		break ;

	case DEF_NOTIFY_UPGRADEHEROCAPE: // v2.24 11/04/06 21:26 
	case DEF_NOTIFY_GIZONITEMCANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		*cp = (char)sV2;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		*cp = (char)sV6;
		cp++;

		*cp = (char)sV7;
		cp++;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV8;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;
		

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 41);
		break;
		
	case DEF_NOTIFY_ENERGYSPHERECREATED:
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	case DEF_NOTIFY_0BE5:
	case DEF_NOTIFY_NOMOREAGRICULTURE:	   //? 농작물 제한
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT: //? 스킬 제한	
	case DEF_NOTIFY_AGRICULTURENOAREA:     //? 농작물을 지을수 있는 공간이 아니다.
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
			
	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		*cp = cValueA;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 58);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		*cp = cValueA;
		cp++;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 58);
		break;
	
	case DEF_NOTIFY_NOTFLAGSPOT:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS*4);
		break;
	
	case DEF_NOTIFY_CONTRIBUTION:
	case DEF_NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	case DEF_NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:
			// NPC의 정보를 얻어온다.
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;
			
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (DWORD *)cp; // v1.4
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case DEF_NOTIFY_TOP15:
			// MORLA 2.10 - Top 15 en deathmach
			ip  = (int *)cp;
			*ip = (int)sV1;
			cp += 4;
			
			ip  = (int *)cp;
			*ip = (int)sV2;
			cp += 4;

			ip  = (int *)cp;
			*ip = (int)sV3;
			cp += 4;

			memcpy(cp, pString, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

		case DEF_NOTIFY_DGKILL:
			// MORLA 2.2 - Actualiza el Top del Deathmach Game
			ip  = (int *)cp;
			*ip = (int)sV1;
			cp += 4;
			
			ip  = (int *)cp;
			*ip = (int)sV2;
			cp += 4;

			ip  = (int *)cp;
			*ip = (int)sV3;
			cp += 4;

			memcpy(cp, pString, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;
	case DEF_NOTIFY_CRAFTING_FAIL:	
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CRAFTING_SUCCESS:	
	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
		// 일치하는 포션 조합이 없다.
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
// v2.19 2002-12-3  몹이벤트 위치를 클라이언트에게 보내준다.
	case DEF_NOTIFY_MONSTEREVENT_POSITION:
		*cp = (char)sV3;
		cp++;

		sp = (short*)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short*)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
		break;

		
	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_HAPPYHOURSTAR: // MORLA 2.3 - HAPPY HOUR ON
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

	case DEF_NOTIFY_HAPPYHOUREND: // MORLA 2.3 - HAPPY HOUR OFF
		    iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

	//FurDay by prlucas
	case DEF_NOTIFY_FURYDAYSTAR: // MORLA 2.3 - HAPPY HOUR ON
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

	case DEF_NOTIFY_FURYDAYEND: // MORLA 2.3 - HAPPY HOUR OFF
		    iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

	case DEF_NOTIFY_TOBERECALLED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

		case DEF_NOTIFY_DOUBLEKILL: // MORLA 2.3 - Double Kill
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_MONSTERKILL: // MORLA 2.3 - Double Kill
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_KILLSPRING: // MORLA 2.3 - Double Kill
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HOLYSHIT: // MORLA 2.3 - Double Kill
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_DEATHMACHSTAR: // MORLA 2.3 - DEATHMACH ON
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_DEATHMACHEND: // MORLA 2.3 - DEATHMACH OFF
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;
	
	case DEF_NOTIFY_PLAYERONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		if (pString != NULL) {
				memcpy(cp, pString2, 14);
				cp += 14;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
		break;

	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		memcpy(cp, "             ", 10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
		break;
	
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;
	
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

		break;
	
	case DEF_NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;  // 보여주는 종류 
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;  // 맵 번호 (0 aresden, 1 elvine, 3 middleland...)
		*wp = (WORD)sV2;
		cp += 2;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp;  // 기술 사용 결과 
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:

		wp  = (WORD *)cp;    
		*wp = (WORD)(m_iTotalGameServerClients+m_iAddUser); 
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp;  // 마법 효과 종류 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // 마법 효과 효력  
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp  = (DWORD *)cp;  // 마법 효과 효력  
		*dwp = (DWORD)sV3;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	
	case DEF_NOTIFY_CANNOTITEMTOBANK:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;
	
		// World Server의 주소를 알려준다.
		memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;

#ifdef DEF_DEFENCEHACKING
		ip = (int *)cp;
		*ip = m_iWorldLogServerPort;
		cp += 4;

#else 
       	ip = (int *)cp;
		*ip = m_iExtHGServerPort;
		cp += 4;

#endif 


		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;

	case DEF_NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp;  // 아이템 인덱스 번호 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // 아이템의 현재 수량 
		*dwp = (DWORD)sV2;
		cp += 4;
				
		*cp = (char)sV3;
		cp++;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;
		
	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_AUTOSSORDER:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_PKPENALTY:
		// PK 페널티를 먹었다.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iStr;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iDex;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iInt;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMag;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
		// 체험판 사용자는 더이상 레벨을 올릴 수 없음을 알린다.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_ITEMRELEASED:
	case DEF_NOTIFY_ITEMLIFESPANEND:
		// 전투중 무기, 혹은 방어구 아이템의 수명이 다해 망가졌음을 알린다. 
		sp  = (short *)cp;
		*sp = (short)sV1;	// 장착 위치 
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;	// 아이템 번호  
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_KILLED:
		// 사망 통보 : 죽인 캐릭터 이름도 함께 보내준다. 
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;
	
	case DEF_NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP; // v2.04 0926 HP의 뒤에 MP를 같이 알려준다. 마나변환의 특성치 때문 
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		RefreshPartyStatus(iToH);
		break;

	case DEF_NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CHARISMA:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

		//MOG Fixes
	case DEF_NOTIFY_STATECHANGE_FAILED:		// 2003-04-14 지존 포인트를 레벨 수정에 실패..korean buttplugs
	case DEF_NOTIFY_SETTING_FAILED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	case DEF_NOTIFY_SPELL_SKILL:
	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14 지존 포인트를 레벨 수정에 성공.. wtf korean junk
		{
			int i;

			for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cMagicMastery[i];
				cp++;
			}

			for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cSkillMastery[i];
				cp++;
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		}
		break;

	case DEF_NOTIFY_SETTING_SUCCESS:
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;
		
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:			
    case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:		
    case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
		
		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;
	  
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	// v1.4311-3 추가 클라이언트에게 사투장 예약이 취소되었다고 알림 ..
	case DEF_NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 

	// v1.4311-3 추가 길드 마스터가 아닌경우 .
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// v1.4311-3 추가 자신의 길드원이  아닌경우 
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
		
	// v3.2
	case DEF_NOTIFY_APOCGATECLOSE:
	case DEF_NOTIFY_APOCGATEOPEN:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;

		memcpy(cp,pString,10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;
		
	// v3.2
	case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
	case DEF_NOTIFY_APOCGATESTARTMSG:
	case DEF_NOTIFY_APOCGATEENDMSG:
	case DEF_NOTIFY_NORECALL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
		
	// v3.2
	case DEF_NOTIFY_ABADDONKILLED:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_RECALLTIMELEFT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	// v3.2	
	case DEF_NOTIFY_MONSTERCOUNT:
	case DEF_NOTIFY_SLATE_STATUS:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
		

	case DEF_NOTIFY_RESURRECTPLAYER:
	case DEF_NOTIFY_HELDENIANEND:
	case DEF_NOTIFY_HELDENIANTELEPORT:
	case DEF_NOTIFY_0BE8:
	case DEF_NOTIFY_SLATE_EXP:
	case DEF_NOTIFY_SLATE_MANA:
	case DEF_NOTIFY_SLATE_INVINCIBLE:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
		
	case DEF_NOTIFY_SLATE_CREATEFAIL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
    case DEF_NOTIFY_HELDENIANSTART:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;
	case DEF_NOTIFY_SLATE_CREATESUCCESS:
		dwp  = (DWORD *)cp;
		*dwp = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	// ZeroEoyPnk - NewMessage

	//New Party Status - ZeroEoyPnk
	case DEF_SEND_PARTYHP:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		
		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV5;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_SEND_PARTYCOORDS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip  = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		if (pString != NULL) memcpy(cp, pString, 12);
		cp += 12;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
		break;


	case DEF_NOTIFY_RUSH:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;


	case DEF_SEND_HPRELIQUIA:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_REPONSE_PLAYERREP:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_ADMINCOMMAND:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		// 처리 도중 오류가 발생하는 것을 막기 위해 지우지 않는다. Time Out으로 삭제될 것임. 
		//DeleteClient(iToH, TRUE, TRUE);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
 register int i;
 BOOL bIsExist = FALSE;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 가입요구가 성공하였다.
	
	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		// v1.4 소속 마을이 달라도 무시된다.
		if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide ) return;
		
		// 길드의 이름을 복사하고 수치를 초기화해 준다.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);
		
		// 길드 GUID복사한다.
		m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

		// 길드의 생성위치를 초기화한다.
		ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
		strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

		m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRank의 시작은 DEF_GUILDSTARTRANK
		
		// 가입 신청자에게 가입이 성공했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_JOINGUILD,i,(char *)NULL,NULL) ;
#endif

		// 특성이 바뀌므로 외양을 새로 보낸다. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);

		
		// 다른 길드원들에게 새 길드원이 있음을 알린다.
		SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

		// 길드정보화일에 새 길드원의 이름을 기록한다.
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
		return;
	}

	// 가입을 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 가입 요구가 실패 하였다.

	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// 가입 신청자에게 가입이 실패했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// 가입을 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 탈퇴요구가 성공하였다.

	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// 길드 정보 화일에서 탈퇴한 길드원의 이름을 삭제한다.
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		
#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
#endif

		// 다른 길드원들에게 길드원의 탈퇴를 알린다.
		SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
				
	
		// 길드의 이름을 초기화해 준다.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, "NONE");
		m_pClientList[i]->m_iGuildRank = -1; 
		m_pClientList[i]->m_iGuildGUID = -1;

		// 탈퇴 신청자에게 탈퇴 성공했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
		
		// 특성이 바뀌므로 외양을 새로 보낸다. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
		return;
	}

	//  탈퇴를 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pName을 갖는 클라이언트의 iClientH 길드에 대한 탈퇴 요구가 실패 하였다.

	// pName의 이름을 갖는 클라이언트 구조체를 검색한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// 가입 신청자에게 탈퇴가 실패했음을 알리는 메시지를 보내준다.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// 탈퇴를 신청한 클라이언트를 찾을수 없다.(접속이 그사이 끊겼다던지) 무효임 
}


DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{
 register int i;
 char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;
	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
	}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
 register int i;
 char cTmpName[21];
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

		// 카운트가 0이면 모두 소모된 것이므로 리스트에서 삭제한다.
		if (dwCount == 0) {
			ItemDepleteHandler(iClientH, i, FALSE);
		}
		else {
			// 아이템의 수량이 변경되었음을 알린다. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
		}
		
		return wWeight;
	}

	return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;
	
	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	// 카운트가 0이면 모두 소모된 것이므로 리스트에서 삭제한다.
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, FALSE);
	}
	else {
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
	}
		
	return wWeight;	
}
   

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
 char  * cp, cAttackerName[21], cData[120], cEKMsg[255];
 short sAttackerWeapon;
 int   * ip, i, iExH;
 BOOL  bIsSAattacked = FALSE;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) {
		m_pClientList[iClientH]->m_dwFightzoneDeadTime = timeGetTime();
		wsprintf(G_cTxt, "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogList(G_cTxt);
	}

	m_pClientList[iClientH]->m_bIsKilled = TRUE;
	m_pClientList[iClientH]->m_iHP = 0;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
	{	ZeroMemory(cEKMsg, sizeof(cEKMsg));
		switch (iDice(1,3))
		{	case 1:
			wsprintf(cEKMsg, "%s Annikilated %s", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iClientH]->m_cCharName);
			break;
			case 2:
			wsprintf(cEKMsg, "%s killed %s", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iClientH]->m_cCharName);
			break;
			default:
			wsprintf(cEKMsg, "%s killed %s", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iClientH]->m_cCharName);
			break;
		}
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		{	if ((m_pClientList[i] != NULL))
			{	SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cEKMsg);
			}
		}
	}

	/*if (cAttackerType == DEF_OWNERTYPE_PLAYER)
	{	if ((bAllVsAll) && (strcmp(m_pClientList[iClientH]->m_cMapName, "fightzone1") == 0))
		{	iTotalAVACurrentKills++;
			if ((iTotalAVAUsers - iTotalAVACurrentKills) == 1)
				CheckAllVsAllWinner();
	}	}*/

	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != NULL)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != NULL)
#ifdef DEF_LOCALNPCNAME
			wsprintf(cAttackerName,"NPCNPCNPC@%d",m_pNpcList[iAttackerH]->m_sType);
#else 
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
#endif
		break ;
	default:
		break;
	}

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1; 
	
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL); 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return; 
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) && (m_bIsHeldenianMode == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) { 
		if (m_pClientList[iClientH]->m_cSide == 1) { 
			m_iHeldenianAresdenDead++; 
		} 
		else if (m_pClientList[iClientH]->m_cSide == 2) { 
			m_iHeldenianElvineDead++; 
		} 
		bUpdateHeldenianStatus(-1); 
	}

	if ((m_bCityWar == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) 
	{ 
		if (m_pClientList[iClientH]->m_cSide == 1) { 
			m_iCityWarAresdenDead++; 
		} 
		else if (m_pClientList[iClientH]->m_cSide == 2) { 
			m_iCityWarElvineDead++; 
		} 
		UpdateCityWarStatus(); 
	} 

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		topdeathmach(iAttackerH, iClientH);

		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = TRUE;
			break;
		}
		
		if (iAttackerH == iClientH) return;
		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
			if (m_pClientList[iClientH]->m_iPKCount == 0) ApplyPKpenalty(iAttackerH, iClientH);
			else {	PK_KillRewardHandler(iAttackerH, iClientH);
		}
		} 
		else {
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
					}
				}
				else {
					if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {	PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {	EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {	if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
					}
				}
				else {
					if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
			}
			else {
				if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
				}
				else {
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked,TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked,TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked,TRUE);
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC,(int) -1,iClientH,cAttackerName) ;

		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked,TRUE);  //v2.19 2002-12-14 몬스터에게 죽었을때아이템(소환몹 제외)
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked , TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked , TRUE);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked , TRUE);
		}
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) {
						
			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
					(m_pClientList[i]->m_iCrusadeDuty == 3)) {
					m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

					if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

					wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
					PutLogList(G_cTxt);
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					return;
				}
				
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER,(int) -1,iClientH,NULL) ;
	}
}



BOOL CGame::bAddMagicAngelInt(int iClientH)
{	for(int i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if((m_pClientList[iClientH]->m_cMagicMastery[i] == 2) && (m_pMagicConfigList[i]->m_sIntLimit <= ((m_pClientList[iClientH]->m_iInt)+(m_pClientList[iClientH]->m_iAngelicInt))))
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
		}
	}

	return TRUE;
}

BOOL CGame::bCheckAngelInt(int iClientH)
{

	for(int i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if(m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->m_iInt)
		{
			if(m_pClientList[iClientH]->m_cMagicMastery[i] == 1)
				m_pClientList[iClientH]->m_cMagicMastery[i] = 2;	//= 0;
			else 
				m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
		}

	}

	return TRUE;
}
void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice)
{
 char cEquipPos, cHeroChecker;
 short sTemp;
 int   iTemp;
	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;
	cHeroChecker = CheckHeroItemEquipHandler(iClientH);
	if (cHeroChecker != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroBonus = 0;
	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		if(m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL){
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
			}
		}
	} else if (cEquipPos == DEF_EQUIPPOS_LFINGER) {
		if(m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL){
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 910) {
		bCheckAngelInt(iClientH);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
		}
		else if((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 908)||(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 909)||(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 911)) 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
		}
	}
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0x0FFFFFFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xF0FFFFFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0x0FFFFFFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;	
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFF0FFFFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFF0FFFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFF0FFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFF0FF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFF0F;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_FULLBODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;
		iTemp = m_pClientList[iClientH]->m_iApprColor;
		iTemp = iTemp & 0xFFF0FFFF;
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
 	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
	}
	
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}
	
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;
	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}


BOOL CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// NPC 이름
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
					memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
					
					if ((m_pNpcConfigList[iNpcConfigListIndex]->m_sType == 81)||(m_pNpcConfigList[iNpcConfigListIndex]->m_sType == 66)||(m_pNpcConfigList[iNpcConfigListIndex]->m_sType == 73)) m_pNpcConfigList[iNpcConfigListIndex]->m_sAreaSize = 3;
					
					cReadModeB = 3;
					break;
				case 3:
					// m_iHitDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_iDefenseRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_iHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_iMinBravery
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_iExpDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDice = atoi(token);
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDice = (m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDice)*1; // aca
					cReadModeB = 8;
					break;

				case 8:
					// m_cAttackDiceThrow
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_cAttackDiceRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_cSize
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 12;
					break;
				
				case 12:
					// ActionLimit 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// Action Time
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// ResistMagic
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// cMagicLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// cGenDayWeekLimit  // 특정 요일에만 생성되는 몬스터여부 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// cChatMsgPresence
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);
					
					if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {
						// 연결된 채팅 메시지가 존재한다. 내용을 읽어 저장한다. 


					}
					cReadModeB = 18;
					break;

				case 18:
					// m_cTargetSearchRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);
										
					cReadModeB = 19;
					break;		

				case 19:
					// Npc 재 생성까지의 시간
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);
										
					cReadModeB = 20;
					break;

				case 20:
					// Attribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);
										
					cReadModeB = 21;
					break;

				case 21:
					// Absorb Magic Damage
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// Maximum Mana Point
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// MagicHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);
									
					cReadModeB = 24;
					break;

				case 24:
					// AttackRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					iNpcConfigListIndex++;
					break;
				}
				break;

			case 2:
				m_iPlayerMaxLevel = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}

			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

BOOL CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{
 register int i, iTemp;
 char cTmpName[21];
 int  sTemp;
 double dV1, dV2, dV3;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++) 
	if (m_pNpcConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
			ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
			memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);
			
			pNpc->m_sType  = m_pNpcConfigList[i]->m_sType;
			
			// HitDice에 따라 공식이 다르다. 몹간의 차별을 두기 위함.
			if (m_pNpcConfigList[i]->m_iHitDice <= 5)
				 pNpc->m_iHP  = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
			else pNpc->m_iHP  = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
			// v1.4 확인코드
			if (pNpc->m_iHP == 0) pNpc->m_iHP = 1; 

			pNpc->m_iExp             = iDice(m_pNpcConfigList[i]->m_iExpDice, 4) + m_pNpcConfigList[i]->m_iExpDice;
			//
			pNpc->m_iHitDice         = m_pNpcConfigList[i]->m_iHitDice;   
			pNpc->m_iExpDice         = m_pNpcConfigList[i]->m_iExpDice;   
			pNpc->m_iDefenseRatio    = m_pNpcConfigList[i]->m_iDefenseRatio;
			pNpc->m_iHitRatio        = m_pNpcConfigList[i]->m_iHitRatio;
			pNpc->m_iMinBravery      = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
			pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
			pNpc->m_cSize            = m_pNpcConfigList[i]->m_cSize;
			pNpc->m_cSide            = m_pNpcConfigList[i]->m_cSide;
			pNpc->m_cActionLimit     = m_pNpcConfigList[i]->m_cActionLimit;
			pNpc->m_dwActionTime     = m_pNpcConfigList[i]->m_dwActionTime;
			pNpc->m_dwRegenTime      = m_pNpcConfigList[i]->m_dwRegenTime;
			pNpc->m_cResistMagic     = m_pNpcConfigList[i]->m_cResistMagic;
			pNpc->m_cMagicLevel      = m_pNpcConfigList[i]->m_cMagicLevel;
			pNpc->m_iMaxMana         = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
			pNpc->m_iMana            = m_pNpcConfigList[i]->m_iMaxMana;
			pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
			pNpc->m_cDayOfWeekLimit  = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
			pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
			pNpc->m_sAreaSize		   = m_pNpcConfigList[i]->m_sAreaSize;

			switch (sClass) {
			case 43:
			case 44:
			case 45:
			case 46:
			case 47: // 전쟁용 유닛의 경우 무조건 공격만 하는 전략을 구사.
			case 51:
				pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
				break;

			case 53: // 비홀더의 경우 무조건 투명 탐지 기능이 있다.
				cSA = 1;
				break;

			default: 
				pNpc->m_iAttackStrategy = iDice(1,10);
				break;
			}
	
			pNpc->m_iAILevel		   = iDice(1,3);
			pNpc->m_iAbsDamage         = m_pNpcConfigList[i]->m_iAbsDamage;
			pNpc->m_iMagicHitRatio     = m_pNpcConfigList[i]->m_iMagicHitRatio;
			pNpc->m_iAttackRange       = m_pNpcConfigList[i]->m_iAttackRange;
			pNpc->m_cSpecialAbility    = cSA;
			pNpc->m_iBuildCount		   = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttribute		   = m_pNpcConfigList[i]->m_cAttribute;

			// v1.411 NPC의 특수 효과 계산. 경험치 가중 
			switch (pNpc->m_cSpecialAbility) {
			case 1:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 2:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 30.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			
			case 3: // Absorbing Physical Damage
				if (pNpc->m_iAbsDamage > 0) {
					// 기본적으로 마법 대미지 절감 능력이 있는 경우 물리 대미지 절감은 적용되지 않는다. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage -= iTemp;
					if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)abs(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 4: // Absorbing Magical Damage
				if (pNpc->m_iAbsDamage < 0) {
					// 기본적으로 물리 대미지 절감 능력이 있는 경우 마법 대미지 절감은 적용되지 않는다. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage += iTemp;
					if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 5:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 15.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 6:
			case 7:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 20.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 8:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			}

			// v1.411 위치 옮김 
			pNpc->m_iNoDieRemainExp  = (pNpc->m_iExp) - (pNpc->m_iExp/3);

			// v1.411 NPC의 특수 능력 삽입 
			// v2.23 sTemp es un int!! ojo con esta variable no confundirla con short..
			pNpc->m_iStatus	= pNpc->m_iStatus & 0xFFFFF0FF;
			sTemp           = cSA;
			sTemp           = sTemp << 8;
			pNpc->m_iStatus = pNpc->m_iStatus | sTemp;
	
			// v1.41 NPC의 Class삽입.
			pNpc->m_iStatus			   = pNpc->m_iStatus & 0xFFFFFFF0;
			pNpc->m_iStatus            = pNpc->m_iStatus | (sClass);
	
			return TRUE;
		}
	}

	// NPC리스트를 모두 검색했음에도 발견되지 않았다. 
	return FALSE;
}

int CGame::iDice(int iThrow, int iRange)
{
 register int i, iRet;

	if (iRange <= 0) return 0;

	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		
		iRet += (rand() % iRange) + 1;
	}

	return iRet;
}

void CGame::OnStartGameSignal()
{
 int i;
	
	// 맵 이벤트 화일을 읽어 각각의 맵에 할당된 NPC들을 세팅한다.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) 
		_bReadMapInfoFiles(i);
	// 초기 설치 건물 정보 읽는다.
	bReadCrusadeStructureConfigFile("..\\Configs\\Crusade.cfg");
	bReadDupeConfigFile("..\\..\\DupItemIDS.cfg");
	bReadHeldenianStructureConfigFile("Heldenian.cfg");
	bReadRushStructureConfigFile("..\\Configs\\Rush.cfg");
	// 폭격 포인트 정보를 바탕으로 맵 인덱스를 링크시킨다.
	_LinkStrikePointMapIndex();
	//2009-03-18
	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadScheduleConfigFile("..\\Configs\\WarSchedule.cfg");
	PutLogList("(!) Iniciando Servidor");
	PutLogList("(!) Cargando ultimos contenidos");
	PutLogList("(!) Activando Helbreath Return");
	PutLogList("(!) Server Online"); 
		
#ifdef DEF_RADMIN
	bSendMsgToLS(MSGID_HGUP, NULL, NULL); 
#endif
	m_pGold = new class CItem;
	_bInitItemAttr(m_pGold, "Gold");

	ServerActivated = TRUE;

}

BOOL CGame::bReadScheduleConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		PutLogList("(!) Cannot open Schedule file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Schedule file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule crusade total war.");
						m_bIsCrusadeWarStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 2:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule apocalypse.");
						m_bIsApocalypseStarter = TRUE;
					}
					cReadModeA = 0;
					break;
				case 3:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule heldenian.");
						m_bIsHeldenianStarter = TRUE;
					}
					cReadModeA = 0;
					break;
				case 4:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many crusade war schedule!"); 
							return TRUE;
						}
						m_stCrusadeWarSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stCrusadeWarSchedule[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stCrusadeWarSchedule[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				case 5:
					switch (cReadModeB) {
					case 1:
						m_stApocalypseSchedule.iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseSchedule.iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseSchedule.iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					//2009-03-18
				case 6:
					switch (cReadModeB) {
					case 1:
						m_stCityWarSchedule.iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stCityWarSchedule.iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stCityWarSchedule.iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
				case 7:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule Citywar.");
						m_bCityWarStarter = TRUE;
					}
					cReadModeA = 0;
					break;
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-server-name", 19) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-server-name", 22) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
				if (memcmp(token, "heldenian-server-name", 21) == 0) {
					cReadModeA = 3;
					cReadModeB = 1;
				}
				if (memcmp(token, "crusade-schedule", 16) == 0) {
					cReadModeA = 4;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule", 19) == 0) {
					cReadModeA = 5;
					cReadModeB = 1;
				}
				if (memcmp(token, "citywar-schedule", 16) == 0) {
					cReadModeA = 6;
					cReadModeB = 1;
				}
				if (memcmp(token, "citywar-server-name", 19) == 0) {
					cReadModeA = 7;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete []cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{
 int ix, iy, iExp;
 short sOwnerH;
 char cOwnerType;

	// ### ERROR POINT! 임시로 막아 논다.
	return;

	if (m_pClientList[sAttackerH] == NULL) return;

	switch (cVictimType) {

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iVictimH] == NULL) return;

		for (ix = m_pNpcList[iVictimH]->m_sX-2; ix <= m_pNpcList[iVictimH]->m_sX+2; ix++)
		for (iy = m_pNpcList[iVictimH]->m_sY-2; iy <= m_pNpcList[iVictimH]->m_sY+2; iy++) {
			
			m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
			 	 (memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
				 (m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel) ) {
				 // 길드원과의 협동전투에서 경험치를 얻기 위해서는 몬스터를 죽인 길드원의 레벨보다 낮은 길드원이어야 한다.
				 // 1D3의 값이 2일때 몬스터 경험치의 3분의 1을 얻는다. 
				if (iDice(1,3) == 2) {
					iExp = (m_pNpcList[iVictimH]->m_iExpDice / 3);
	//   v2.181 2002-10-24 지존인 경우 경험치 적게 먹는 버그 수정 
	//				if (m_pClientList[sAttackerH]->m_iLevel >= m_iPlayerMaxLevel) iExp = 0;

					if (iExp > 0) {
						
						m_pClientList[sOwnerH]->m_iExp += iExp;
						if (bCheckLimitedUser(sOwnerH) == FALSE) {
							// 체험판 사용자 제한에 걸리지 않았다. 경험치가 올랐다는 통보를 한다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}
						// 레벨이 올랐는지를 검사한다.
						bCheckLevelUp(sOwnerH);
					}
				}
			}
		}												     
		break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
 register int iMaxHP, iTemp, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 죽은척하기 기술 사용중에는 체력 오르지 않음.

	//iMaxHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iStr/2); // V1.4
	iMaxHP = iGetMaxHP(iClientH);

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {
		
		// HP 차는 최소값을 보장.
		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));
		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);

		// v1.4 HP차는 양을 재조정한다. 
		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
			iTemp = iTemp - (iTemp/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		// v2.20 2002-12-28 3주년 기념반지 버그 수정 
		iTotal +=  m_pClientList[iClientH]->m_iHPStatic_stock;
		
		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iHP += iTotal; // Hit Point는 17초마다 1D(Vit) + HPstock씩 올라간다.
		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;
		if (m_pClientList[iClientH]->m_iHP <= 0)     m_pClientList[iClientH]->m_iHP = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}
	// HP가 올랐던 말건 간에 0으로 클리어.
	m_pClientList[iClientH]->m_iHPstock = 0;
}

void CGame::TimeManaPointsUp(int iClientH)
{
 register int iMaxMP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 죽은척하기 기술 사용중에는 마나 오르지 않음.

	iMaxMP = (2*(m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag)) + (2*m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt)/2); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag)); // Mana Point는 20초마다 1D(Magic)씩 올라간다.
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;
		
		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}


void CGame::TimeStaminarPointsUp(int iClientH)
{
 register int iMaxSP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 죽은척하기 기술 사용중에는 스테미너 오르지 않음.

	iMaxSP = (2*(m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)) + (2*m_pClientList[iClientH]->m_iLevel);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {
		
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit/3)); // Staminar Point는 10초마다 1D(Vit/3)씩 올라간다.
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		// v2.03 레벨 60 이하는 정기적으로 스테미나가 많이 찬다.
		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if ( m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}  else if ( m_pClientList[iClientH]->m_iLevel <= 60) { 
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::DelayEventProcess()
{

}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
 char cData[500];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 register int i, iRet;
	
	// 같은 길드원들에게만 보내는 메시지들
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ( (m_pClientList[i] != NULL) && 
		 (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) {

		// ### BUG POINT 위치가 잘못되어 포인터 연산이 잘못되었다. 
		ZeroMemory(cData, sizeof(cData));

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wNotifyMsgType;
	
		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		// 같은 길드 이름을 갖고 있는 클라이언트를 찾았다.
		switch (wNotifyMsgType) {
		case DEF_NOTIFY_GUILDDISBANDED:
			if (i == iClientH) break; // <-- 길드 마스터 자신에게는 메시지를 보내지 않는다.
			// 길드 해산 통보에 해당 클라이언트의 길드 랭크를 클리어한다. 
			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 36);
			// 해당 클라이언트의 길드내용을 클리어한다. @@@@@@@
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_NOTIFY_EVENTMSGSTRING:
			// 길드원들에게 전달되는 이벤트 메시지 스트링 
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_NEWGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;

		case DEF_NOTIFY_DISMISSGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;
		}
	
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
	}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{
 // 다른 게임서버로부터 길드 이벤트가 도착했다. 
 char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	// 아직 구현되지 않았다. 
}



void CGame::ToggleCombatModeHandler(int iClientH)
{
 short sAppr2;
 char cData[9];
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	// 죽은척하기나 죽은 상태에서는 변환할 수 없다.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;
	
	ZeroMemory(cData, sizeof(cData));

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; // v2.172
	

	if (sAppr2 == 0) {
		// 비전투 모드였다. 전투모드로 바꾼다.
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		// 전투 모드였다. 비전투모드로 바꾼다.
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}
	
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	
}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pGateSock == NULL) return;

	iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		PutLogList("(!!!) Gate-socket connected!");
		SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// 게이트서버로의 연결이 이루어 졌으므로 게임서버 등록 메시지를 전송한다.
		// v1.41 gate-socket을 재연결할 때 카운팅 하는 변수. 서버 작동 도중 gate-socket이 소켓에러로 끊기면 곧바로 재접속을 
		// 시도하며 이 값이 일정치 이상이 되면 연결 실패로 간주되어 자동 서버 셧다운 모드(4)로 들어간다. 
		m_iGateSockConnRetryTimes = 0;
		break;
	/*case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// 게이트서버로의 연결이 이루어 졌으므로 게임서버 등록 메시지를 전송한다.
		PutLogList("(!!!) Gate-socket connected!");
		SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		// v1.41 gate-socket을 재연결할 때 카운팅 하는 변수. 서버 작동 도중 gate-socket이 소켓에러로 끊기면 곧바로 재접속을 
		// 시도하며 이 값이 일정치 이상이 되면 연결 실패로 간주되어 자동 서버 셧다운 모드(4)로 들어간다. 
		m_iGateSockConnRetryTimes = 0;
		break;*/
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// 메시지가 수신되었다.
		OnGateRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("Socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// 확인코드가 일치하지 않는다.
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// 수신해야 할 메시지 크기가 버퍼보다 크다.	종료해야만 한다.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// 소켓에 에러가 났다.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 소켓이 닫혔다.
		delete m_pGateSock;
		m_pGateSock = NULL;
		PutLogList("(!!!) Gate-socket connection lost!");
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server로의 재연결 시도 
		// v2.17 2002-8-5 메모리 누수 추적중 
		if (m_bOnExitProcess == FALSE) {
			m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
			m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
			// v1.41 연결 시간 체크용 
			m_iGateSockConnRetryTimes = 1;

			wsprintf(G_cTxt, "(!!!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
			PutLogList(G_cTxt);
		}

		
		// 게이트 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by gate-server connection Lost)!!!");
		}
		
		break;
	}
}

void CGame::OnGateRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// 메시지 큐에 이상이 생겼다. 치명적인 에러.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::SendMsgToGateServer(DWORD dwMsg, int iClientH, char * pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i;
 char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], * cp;

	if (m_pGateSock == NULL) {
		PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,  sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	switch (dwMsg) {
	case MSGID_PARTYOPERATION: // v2.06 12-03 게이트 서버로의 파티 관련 연산 요청
		iRet = m_pGateSock->iSendMsg(pData, 50);
		break;
	
	case MSGID_SERVERSTOCKMSG:
		iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
		break;
	
	case MSGID_ITEMLOG:
		// 아이템 전달 로그다. 사용하지 않음.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;

		iRet = m_pGateSock->iSendMsg(cData, 53);
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		// 게이트 서버에게 게임서버 등록을 요청한다.
	//	wsprintf(cTxt, "(!) Try to register game server(%s) - GateServer", m_cServerName);
	//	PutLogList(cTxt);
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));

		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		dwp = (DWORD *)cp;
		*dwp = (DWORD)GetCurrentProcessId();	 // 프로세스 핸들을 기록한다.
		cp += 4;

		// v2.17 2002-6-3 고광현 수정
		// Build Date를 삽입
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)DEF_BUILDDATE;
		cp += 4;

		iRet = m_pGateSock->iSendMsg(cData, 39 + m_iTotalMaps*11 + 4);
		break;

	case MSGID_GAMESERVERALIVE:
		// 정기적으로 게임 서버의 정보를 전송 
		// 만약 로그 서버와의 소켓 연결이 끊어졌다면 메시지를 보내지 않아 서버에 이상이 생겼음을 알리게 유도한다.
		if (m_bIsLogSockAvailable == FALSE) return;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		
		iRet = m_pGateSock->iSendMsg(cData, 8);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 게이트 서버로 메시지를 보낼때 에러가 발생했다.
		PutLogList("(***) Socket to Gate-Server crashed! Critical error!");
		delete m_pGateSock;
		m_pGateSock = NULL;
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server로의 재연결 시도: 서버를 셧다운 하는 것이 아니다. 
		// 2002-8-5 메모리 누수 추적중 
		// v2.17 2002-8-5 메모리 누수 추적중 
		if (m_bOnExitProcess == FALSE) {

			m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
			m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
			// v1.41 연결 시간 체크용 
			m_iGateSockConnRetryTimes = 1;	

			wsprintf(G_cTxt, "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
			PutLogList(G_cTxt);
		}

		/*
		// 게이트 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by gate-server connection Lost)!!!");
		}
		*/
		return;
	}
}

int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	// 죄표가 일치하지 않는 명령은 무시한다. Reject메시지를 받기 이전에 전송된 메시지들이다.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
		
	// 스킬의 사용상태를 모두 무효화 한다.
	ClearSkillUsingStatus(iClientH);

	// 죽은 위치에 있었다면 지운다. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// 다시 위치 시킨다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	// 투명 모드였다면 마법 Casting시에 해제된다.
	if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	// 클라이언트가 MSGID_RESPONSE_MOTION메시지를 받아야만 계속 명령을 전송할 수 있다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}


int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};


void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)
{
 short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic;
 char   * cp, cData[120], cDir, cOwnerType, cName[11], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor, cScanMessage[256];
 double dV1, dV2, dV3, dV4;
 int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
 int    tX, tY, iManaCost, iMagicAttr, iItemID;
 class  CItem * pItem;
 DWORD * dwp, dwTime = timeGetTime();
 WORD  * wp, wWeaponType;
 short sTemp;
#ifdef DEF_GUILDWARMODE
	switch (sType) {
	case 31:
	case 40:
	case 41:
	case 46:
	case 54:
	case 55:
	case 73:
		return;
	}
#endif

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;
	if (m_pMagicConfigList[sType]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)) return;
	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;
	
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	if ((bItemEffect == FALSE) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;
	if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) && (((bHeldenianFight == FALSE)&&(m_bIsHeldenianMode == TRUE))||((m_bHeldSafe == TRUE)&&(m_bIsHeldenianMode == FALSE))) && ((m_pMagicConfigList[sType]->m_sType == 1) || (m_pMagicConfigList[sType]->m_sType == 3) || (m_pMagicConfigList[sType]->m_sType == 12) || (m_pMagicConfigList[sType]->m_sType == 13) || (m_pMagicConfigList[sType]->m_sType == 14) || (m_pMagicConfigList[sType]->m_sType == 16) || (m_pMagicConfigList[sType]->m_sType == 17) || (m_pMagicConfigList[sType]->m_sType == 19) || (m_pMagicConfigList[sType]->m_sType == 21) || (m_pMagicConfigList[sType]->m_sType == 22) || (m_pMagicConfigList[sType]->m_sType == 23) || (m_pMagicConfigList[sType]->m_sType == 25) || (m_pMagicConfigList[sType]->m_sType == 26) || (m_pMagicConfigList[sType]->m_sType == 27) || (m_pMagicConfigList[sType]->m_sType == 28) || (m_pMagicConfigList[sType]->m_sType == 29) || (m_pMagicConfigList[sType]->m_sType == 30) || (m_pMagicConfigList[sType]->m_sType == 31) || (m_pMagicConfigList[sType]->m_sType == 32))) return;

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);		
		if ((wWeaponType >= 34) && (wWeaponType <= 39)) {

		}
		else return;
	}

	if (m_pClientList[iClientH]->m_bInhibition == TRUE) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;
	}
	// 플레이어의 다른손에 아무것도 없는지 확인한다. 
	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ]   != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1)) return;


	// v1.42 비정상적으로 연속된 마법 메시지는 무시한다.
	if ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 100) return; 
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;


	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		 dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];
	
	// 아이템으로 인한 마법효과라면 성공률 100%
	if (bItemEffect == TRUE) dV1 = (double)100.0f;

	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];

	dV1 = dV2 * dV3;
	iResult = (int)dV1;
		
	// Int에 따른 추가 마법 성공률 계산 
	if (m_pClientList[iClientH]->m_iInt > 50)
		iResult += (m_pClientList[iClientH]->m_iInt - 50)/2;
		
	// v1.3 쓰고자 하는 마법의 써클과 플레이어의 레벨 관계에 따라 성공률이 가감된다. 
	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			// 자신의 레벨보다 큰 마법을 쓴다. 차이만큼 성공률을 감소시킨다.
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			// 자신의 레벨보다 낮은 마법을 쓴다. 차이만큼 성공률을 증가시킨다.
			iResult += 5*abs(sMagicCircle - sLevelMagic); // v1.4
		}
	}

	// 날씨에 의한 마법 성공률 조정. 
	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break; // 비가 올 경우 성공률 4, 8, 20% 감소 
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	// 특수 아이템에 의한 마법 성공률 조정
	// v2.15 마법 성공률 관련 조정 
	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}
		
	// 수치 조정.
	if (iResult <= 0) iResult = 1;

	// 날씨에 의한 마법 공격력 조정 
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
		
	// 마법의 소비 마나값 계산 
	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) && 
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)) {
		// 안전모드의 경우 마나 소비량 40%증가. 단 사투장에서는 해당없음
		iManaCost += (iManaCost / 2) - (iManaCost / 10);
	}

	if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
		// 마나 절감 값이 양수면 그 만큼 마나소비가 줄어든다.
		dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)iManaCost;
		dV1 = dV2 * dV3; // 이 값이 절약되는 값 
		dV2 = dV3 - dV1; 
		iManaCost = (int)dV2;
		// 최소 1은 필요하다. 
		if (iManaCost <= 0) iManaCost = 1;
	}

	if (iResult < 100) {
		// 주사위를 굴린 값이 iResult보다 같거나 작으면 성공 
		iDiceRes = iDice(1,100);
		if (iResult < iDiceRes) {
			// 마법 실패! Damage가 0이라면 마법 실패를 의미한다.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;
		}
	}
	// iResult가 100보다 크면 무조건 성공, 그러나 배가 너무 고프다거나 SP가 낮으면 1/10 실패 가능성이 있다.
	if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1,1000) <= 100)) {
		// 마법 실패! Damage가 0이라면 마법 실패를 의미한다.
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;	
	}
	 
	// Mana가 부족해도 실패. 
	if (m_pClientList[iClientH]->m_iMP < iManaCost) {
		// 원래는 클라이언트에서 걸러지나 해킹을 대비하기 위함. 
		return;
	}

	// 명중률을 계산해서 iResult에다 넣어준다. 
	iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
	// Mag이 50보다 크면 보너스 명중률
	if ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += (m_pClientList[iClientH]->m_iMag - 50); 	
	
	// 쓰고자 하는 마법의 써클과 플레이어의 레벨 관계에 따라 명중률이 가감된다. 
	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			// 자신의 레벨보다 큰 마법을 쓴다. 차이만큼 명중률을 감소시킨다. 비례하여 감소시킨다.
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			// 자신의 레벨보다 낮은 마법을 쓴다. 차이만큼 명중률을 증가시킨다.
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}

	// v2.05 m_iAddAR 추가됨
	iResult += m_pClientList[iClientH]->m_iAddAR;

	// 수치 조정.
	if (iResult <= 0) iResult = 1;
	// 만약 9써클 이상이면 마법 방어로 막을 수 없다.
	if (sType >= 80) iResult += 10000;

	// 공격 마법을 사용할 위치가 No-Attack-Area라고해도 실패 
	if (m_pMagicConfigList[sType]->m_cCategory == 1) {
		// 마법 보호 혹은 안전 영역이라면 공격 성공 못함 
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}
	
	// v1.41 마법 속성
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	// v2.17 2002-8-6 투명 모드였다면 마법 Casting시에 해제된다. (인비마법 핵을 방지하기 위해)
	if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}
		//npc hp bar by necru
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							break;

						case DEF_OWNERTYPE_NPC:
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCBAR, (m_pNpcList[sOwnerH]->m_iHP*100)/(m_pNpcList[sOwnerH]->m_iHitDice * 6 + m_pNpcList[sOwnerH]->m_iHitDice), m_pNpcList[sOwnerH]->m_iMana, NULL, NULL);
								if (m_pNpcList[sOwnerH]->m_iMana != 0)
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCBAR2, (m_pNpcList[sOwnerH]->m_iMana*100)/m_pNpcList[sOwnerH]->m_iMaxMana, NULL, NULL, NULL);
								else 
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCBAR2, 0, NULL, NULL, NULL);
							break;
						}	

	// 2002-11-14 사냥꾼 모드 추가 ( 사냥꾼은 다른 마을 사람과 몬스터에게 일반/보호 마법을 걸 수 없다. 전면전시 제외 )
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	
	if ((m_bIsCrusadeMode == FALSE) && (cOwnerType == DEF_OWNERTYPE_PLAYER) )
	{
		// 사냥꾼에게는 편이 다르면 
		if (((m_pClientList[iClientH]->m_bIsHunter == TRUE) ||
			(m_pClientList[sOwnerH]->m_bIsHunter == TRUE)) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide))
		 goto MAGIC_NOEFFECT;

		if ((m_pClientList[iClientH]->m_bIsHunter == TRUE) && (m_pClientList[sOwnerH]->m_bIsHunter == FALSE))
		{	switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_SPDOWN_AREA:
			case DEF_MAGICTYPE_SUMMON:
			case DEF_MAGICTYPE_PROTECT:
			case DEF_MAGICTYPE_HOLDOBJECT:
			case DEF_MAGICTYPE_INVISIBILITY: 
			case DEF_MAGICTYPE_BERSERK:
			case DEF_MAGICTYPE_POISON:
			case DEF_MAGICTYPE_HPUP_SPOT:
				 goto MAGIC_NOEFFECT;
			}
		}
	}



	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// 즉시 효과를 보는 마법 
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_POLYMORPH:
			// 변신 마법. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// 원래 타입을 저장해 놓는다.
					m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
					// 바뀐 외형을 통보해 준다.
					m_pClientList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// 원래 타입을 저장해 놓는다.
					m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
					// 바뀐 외형을 통보해 준다.
					m_pNpcList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;
				}

				// 변신 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_SPOT_SPDOWN:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}
			}
			break;
		case DEF_MAGICTYPE_SCAN:
			ZeroMemory(cScanMessage, sizeof(cScanMessage));
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) goto MAGIC_NOEFFECT;
					wsprintf(cScanMessage, " Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
					ShowClientMsg(iClientH, cScanMessage);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					wsprintf(cScanMessage, " NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
					ShowClientMsg(iClientH, cScanMessage);
					break;
				}
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, 10);
			}
			break;
		case DEF_MAGICTYPE_CANCELLATION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)/* && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)*/) {

						// Removes Invisibility Flag 0x0010
						if (m_pClientList[sOwnerH]->m_iStatus & 0x10){
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
							SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
						}

						// Removes Illusion Flag 0x01000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x01000000){ 
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
							SetIllusionFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 3, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
						}

						// Removes Defense Shield Flag 0x02000000
						// Removes Great Defense Shield Flag 0x02000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x02000000){
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetDefenseShieldFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 3, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;

						}
						// Remove Paralize and Hold Person
						/*if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0){
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1)
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
							else SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
						}*/
						
						// Removes Ice Flag 0x40
						if (m_pClientList[sOwnerH]->m_iStatus & 0x40){
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);
							SetIceFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = NULL;
						}

						// Removes Absolute Magic Protection Flag 0x04000000	
						// Removes Protection From Magic Flag 0x04000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x04000000){
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetMagicProtectionFlag(sOwnerH, cOwnerType, FALSE);
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 2, NULL, NULL);
							else SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 5, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						}

						// Removes Protection From Arrow Flag 0x08000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x08000000){
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetProtectionFromArrowFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 1, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;

						}

						// Removes Illusion Movement Flag 0x00200000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x00200000){ 
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
							SetIllusionMovementFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 4, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
						}

						// Removes Berserk Flag 0x0020
						if (m_pClientList[sOwnerH]->m_iStatus & 0x20){
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
							SetBerserkFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_BERSERK, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = NULL;
						}
						
						//Remove Inhibition
						if (m_pClientList[sOwnerH]->m_bInhibition == TRUE) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INHIBITION] = NULL;
							m_pClientList[sOwnerH]->m_bInhibition = FALSE;
						}
					
						// Update Client
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
					break;
				case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
					// 첨쩌짹 쨩처쩔징 쨈 쨍챰짜쨍짝 쨍챨쨉 쩐처쨍짰쨍챌 째첩째쨈.
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;
									}
									//
								}
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;
										}
										//
									}
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;
									}
									//
								}

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;
											}
											//
										}
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;
										}
										//
									}

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
												// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
												switch (cOwnerType) {
													case DEF_OWNERTYPE_PLAYER:
														if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
														if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
															Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
															Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														}
														break;

													case DEF_OWNERTYPE_NPC:
														if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
															Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
															Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														}
														break;
												}
												//
											}
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;
											}
											//
										}

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
													// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
													switch (cOwnerType) {
														case DEF_OWNERTYPE_PLAYER:
															if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
															if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
																Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
																Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
															}
															break;

														case DEF_OWNERTYPE_NPC:
															if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
																Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
																Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
															}
															break;
													}
													//
												}
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					// 쨘짱 째첩째 쩔째첬 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// 쩍쨉쨉 첩쨉 쩌철 쨍쨈 .
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

												}
												break;
										}
										//
									}
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
							// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
									// 쩐처쩐챤쩌짯 쨉쩔 쨈쩐챤철쨈 쩔째첬
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// 쨍째 쨩챙쩐째챠 쩐처쩍 첬쩔징 쩍쨈쨍챕 쩐처쩐챤쨘쨈쨈.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

											}
											break;
									}
									//
								}
							}
							break;
		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// 일직선 상에 있는 목표를 모두 공격한다.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
			}
			break;

					// v2.16 2002-5-23 고광현 
		case DEF_MAGICTYPE_ICE_LINEAR:
			// 일직선 상에 있는 목표를 모두 얼리며 공격한다.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// 대상이 플레이어인 경우 알려준다.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;
							
						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
										sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
						}
						//
					}
				}
			}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
				// 얼어서 동작이 늦어지는 효과
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							// 대상이 플레이어인 경우 알려준다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
					}
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sOwnerH, cOwnerType, TRUE);
							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
						}
					}
					break;
				}
				//
			}
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;
						
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					//
				}
			}
			break;
			
		case DEF_MAGICTYPE_HPUP_SPOT:
			// 이 마법은 명중률과는 상관이 없다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;
	
		case DEF_MAGICTYPE_INHIBITION:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INHIBITION ] != 0) goto MAGIC_NOEFFECT;
					if (memcmp(m_pClientList[sOwnerH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;
					if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5) goto MAGIC_NOEFFECT;
						m_pClientList[sOwnerH]->m_bInhibition = TRUE;
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					
						if (cOwnerType == DEF_OWNERTYPE_PLAYER){
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INHIBITION, NULL, NULL, NULL);
						}
					break;
			}
			break;

		case DEF_MAGICTYPE_TREMOR: // v1.4 주변 공격 효과에 이어 잔류 효과가 있다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE){
					if (iDice(1,3) == 1)
					{   
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					}
					if (sType == 82)				
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, TRUE);
					else 
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					{
						if (iDice(1,3) == 1)
						{ 
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						}
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
			for (iy = dY - 1; iy <= dY + 1; iy++)
			for (ix = dX - 1; ix <= dX + 1; ix++) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp가 줄어든다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp가 상승한다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 마법 저항이 필요없다. 
			Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				// 마법저항이 필요 없다.
				Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_TELEPORT:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bAllVsAll) goto MAGIC_NOEFFECT;
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) {
					if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
						(m_pClientList[iClientH]->m_bIsKilled == FALSE) && (m_bIsApocalypseMode == TRUE)  && (m_pClientList[iClientH]->m_iHP > 0)) {
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NORECALL, NULL, NULL, NULL, NULL);
					}else {
					RequestTeleportHandler(iClientH, "1   ");
					}
	 			}
			
			   	break;
	 		}
			break;



		case DEF_MAGICTYPE_SUMMON:
			// 소환마법 

			// 사투장 내에서는 소환마법이 불가능.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) return;
			if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "deathmach", 9) == 0) return;
            if (m_bHeldSafe == TRUE) return;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 지정된 Owner가 Master가 된다. 
			// v2.19 2002-11-17 소환은 같은 편에게만 된다.
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide)) {
				// Master로 지정된 대상을 따라다니고 있는 객체 수를 계산한다. 
				iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

				// 소환마법을 Casting한 자의 Magery/20 만큼의 몬스터를 소환할 수 있다.
				if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4]/20)) break;
				
				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {
					// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
				}
				else {
					// NPC를 생성한다.
					ZeroMemory(cName, sizeof(cName));
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
					
					// Magery에 따라 소환되는 몬스터의 등급이 달라진다.
					ZeroMemory(cNpcName, sizeof(cNpcName));
					
					switch (iV1) {
					case NULL: // 일반적인 경우 
						iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);
						
						// v1.42 최저 몹 레벨을 입력 
						if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
							iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

						switch (iResult) {
						case 1: strcpy(cNpcName, "Slime"); break;
						case 2: strcpy(cNpcName, "Giant-Ant"); break;
						case 3: strcpy(cNpcName, "Amphis"); break;
						case 4: strcpy(cNpcName, "Orc"); break;
						case 5: strcpy(cNpcName, "Skeleton"); break;
						case 6:	strcpy(cNpcName, "Clay-Golem"); break;
						case 7:	strcpy(cNpcName, "Stone-Golem"); break;
						case 8: strcpy(cNpcName, "Orc-Mage"); break;
						case 9:	strcpy(cNpcName, "Hellbound"); break;
						case 10:strcpy(cNpcName, "Ettin"); break;
						}
						break;

					case 1:	strcpy(cNpcName, "Orc"); break;
					case 2: strcpy(cNpcName, "Skeleton"); break;
					case 3: strcpy(cNpcName, "Clay-Golem"); break;
					case 4: strcpy(cNpcName, "Stone-Golem"); break;
					case 5: strcpy(cNpcName, "Hellbound"); break;
					case 6: strcpy(cNpcName, "Ettin"); break;
					case 7: strcpy(cNpcName, "Troll"); break;
					case 8: strcpy(cNpcName, "Orge"); break;
					//Ovl Summons Heldenian
								case 9: 
									if ((m_pClientList[iClientH]->m_cSide == 1) && (bHeldenianFight == TRUE)) {
										strcpy(cNpcName, "Sor-Aresden");
									} else if ((m_pClientList[iClientH]->m_cSide == 2) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "Sor-Elvine");
									}
									
									break;
								case 10:
                                    if ((m_pClientList[iClientH]->m_cSide == 1) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "ATK-Aresden");
									} else if ((m_pClientList[iClientH]->m_cSide == 2) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "ATK-Elvine");
									}
									
									break;
								case 11:
									if ((m_pClientList[iClientH]->m_cSide == 1) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "Elf-Aresden");
									} else if ((m_pClientList[iClientH]->m_cSide == 2) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "Elf-Elvine");
									}
									
									break;
								case 12:
									if ((m_pClientList[iClientH]->m_cSide == 1) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "DSK-Aresden");
									} else if ((m_pClientList[iClientH]->m_cSide == 2) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "DSK-Elvine");
									}
									
									break;
								case 13:
									if ((m_pClientList[iClientH]->m_cSide == 1) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "HBT-Aresden");
									} else if ((m_pClientList[iClientH]->m_cSide == 2) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "HBT-Elvine");
									}
									
									break;
								case 14:
									if ((m_pClientList[iClientH]->m_cSide == 1) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "Bar-Aresden");
									} else if ((m_pClientList[iClientH]->m_cSide == 2) && (bHeldenianFight == TRUE)) {
									strcpy(cNpcName, "Bar-Elvine");
									}
									
									break;
						
					}

					if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE) == FALSE) {
						// 실패했으므로 예약된 NameValue를 해제시킨다.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						ZeroMemory(cName_Master, sizeof(cName_Master));
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
							break;
						case DEF_OWNERTYPE_NPC:
							memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
							break;
						}
						bSetNpcFollowMode(cName, cName_Master, cOwnerType);
#ifdef DEF_TAIWANLOG
						_bItemLog(DEF_ITEMLOG_SUMMONMONSTER,iClientH,cNpcName,NULL) ;
#endif
				   	}
				}
			}
			break;

		case DEF_MAGICTYPE_CREATE:
			// 무언가를 생성시키는 마법 

			// 위치할 수 없는 곳에는 생기지 않는다. 
			if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE )
				goto MAGIC_NOEFFECT;

			pItem = new class CItem;

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// Food를 생성해야 한다. 
				// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
				if (iDice(1,2) == 1)
					 iItemID = 99 ;
				else iItemID = 98 ;
				break;
			}
		   		
			_bInitItemAttr(pItem, iItemID);
		   	
// v2.15 마법으로 생긴 아이템에 고유번호 저장 
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			pItem->m_sTouchEffectValue3 = (short)timeGetTime();

			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

			// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
					
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                  dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
			break;				  
		case DEF_MAGICTYPE_PROTECT:
			// 보호 마법 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			// 보호 상태라는 것을 설정하기 전에 이미 해당 보호가 걸려있는지 확인하고 걸려있다면 마법은 무시된다. 
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
				// v1.4334 중립은 플레이어에게 마방을 못하게 수정
				if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

				m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				switch (m_pMagicConfigList[sType]->m_sValue4){
		    case 1:
				SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
				    break;
		    case 2:
			case 5:
				SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
				    break;
				
			case 3:
			case 4:
				  SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
					break;
							}
							break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
				// 정적 NPC들은 보호 마법 적용 안됨.				
				if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
			   	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				break;
			}

			// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
				                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

			// 효과가 생겼음을 알려준다.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// 오브젝트의 움직임을 봉쇄한다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
					// v1.4334 중립은 플레이어에게 패럴을 못하게 수정
					if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;
					// 2002-09-10 #2 안전지대(No-Attack-Area) 패럴 마법 안되게 함
					if (  cOwnerType == DEF_OWNERTYPE_PLAYER )  {
						
						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					}

					// 2002-09-10 #3 전면전시와 미들랜드에서를 제외하고 같은 편에게는 패럴 안됨
					if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
						m_bIsCrusadeMode == FALSE && m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide )
						goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 마법 레벨 6이상인 리치급 이상의 마법 몬스터에게는 마비 마법 통하지 않는다.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}

				// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;

		case DEF_MAGICTYPE_INVISIBILITY:
			if  (memcmp(m_pClientList[iClientH]->m_cMapName, "deathmach", 9) == 0) goto MAGIC_NOEFFECT; // MORLA 2.3 - No Droop en Deathmach Game
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;
					if (bAllVsAll) goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
										
					if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
						RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);	
					}
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case 2:
				// v1.4334 중립은 플레이어에게 인비 해제 못하게 
				if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;
				
				// dX, dY 반경 8 주변의 Invisibility 상태인 Object가 있으면 해제 시킨다.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// v2.19 2002-11-17 사낭꾼은 인비 해제 않되게 
							if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;

							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_CREATE_DYNAMIC:
			// Dynamic Object를 생성하고 효력이 지속되는 타입.

			// v2.1 마을 내에서는 필드 마법 금지(전면전시 제외)
			if (m_bIsCrusadeMode == FALSE) {
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
				// v2.14
			//	if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) return;
			//	if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) return;
			}

			switch (m_pMagicConfigList[sType]->m_sValue10) {
			case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // 독구름

			case DEF_DYNAMICOBJECT_FIRE:   // Fire 이다.
			case DEF_DYNAMICOBJECT_SPIKE:  // Spike
				
#ifdef DEF_TAIWANLOG 
				short sTemp_X, sTemp_Y ;
				// v2.15 마법을 사용한 위치를 표시하기 위한 변수
				sTemp_X = m_pClientList[iClientH]->m_sX ;
				sTemp_Y = m_pClientList[iClientH]->m_sY ;

				m_pClientList[iClientH]->m_sX = dX;
				m_pClientList[iClientH]->m_sY = dY;

				_bItemLog(DEF_ITEMLOG_SPELLFIELD,iClientH,m_pMagicConfigList[sType]->m_cName,NULL) ;

				m_pClientList[iClientH]->m_sX = sTemp_X;
				m_pClientList[iClientH]->m_sY = sTemp_Y;
#endif

				switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1: 
					// wall - type
					cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
					case 1:	rx = 1; ry = 0;   break;
					case 2: rx = 1; ry = 1;   break;
					case 3: rx = 0; ry = 1;   break;
					case 4: rx = -1; ry = 1;  break;
					case 5: rx = 1; ry = 0;   break;
					case 6: rx = -1; ry = -1; break;
					case 7: rx = 0; ry = -1;  break;
					case 8: rx = 1; ry = -1;  break;
					}
					
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
					
					bAnalyzeCriminalAction(iClientH, dX, dY);
					
					for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					BOOL bFlag = FALSE;
					int cx, cy;
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
											  ix, iy, m_pMagicConfigList[sType]->m_dwLastTime*1000, m_pMagicConfigList[sType]->m_sValue5);	

						// 만약 마을에서 필드를 깐 곳에 무고한 자가 있었다면 공격자는 가드의 공격을 받게 된다. 
						if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
							bFlag = TRUE;
							cx = ix;
							cy = iy;
						}
					}
					// 필드인 경우 경비를 1명만 소환하기 위함.
					if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
			  		break;
				}
				//
				break;

			case DEF_DYNAMICOBJECT_ICESTORM:
#ifdef DEF_TAIWANLOG 
				// v2.15 마법을 사용한 위치를 표시하기 위한 변수
				
				sTemp_X = m_pClientList[iClientH]->m_sX ;
				sTemp_Y = m_pClientList[iClientH]->m_sY ;

				m_pClientList[iClientH]->m_sX = dX;
				m_pClientList[iClientH]->m_sY = dY;

				_bItemLog(DEF_ITEMLOG_SPELLFIELD,iClientH,m_pMagicConfigList[sType]->m_cName,NULL) ;

				m_pClientList[iClientH]->m_sX = sTemp_X;
				m_pClientList[iClientH]->m_sY = sTemp_Y;

#endif

				// Ice-Storm Dynamic Object 
				iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
											  dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000,
											  m_pClientList[iClientH]->m_cSkillMastery[4]);	
				break;

			default:
				break;
			}
			break;

		case DEF_MAGICTYPE_POSSESSION:
			// 원거리에 떨어져 있는 물건을 집어오는 마법이다. 

			// v2.19 2002-11-17 포제션 마법은 주위에 사람이 있으면 효력이 없다. 
			if (_iCalcPlayerNum(m_pClientList[iClientH]->m_cMapIndex, dX, dY, 1) != 0) break ;
			
			pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
			if (pItem != NULL) {
				// 플레이어가 아이템을 획득하였다. 
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					// 아이템을 획득했다.

					// v1.411 로그 남긴다.
					_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
					
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					
					// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
					*cp = 1;
					cp++;
					
					memcpy(cp, pItem->m_cName, 20);
					cp += 20;
					
					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;
					
					*cp = pItem->m_cItemType;
					cp++;
					
					*cp = pItem->m_cEquipPos;
					cp++;
					
					*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
					cp++;
					
					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
					
					*cp = pItem->m_cGenderLimit;
					cp++;
					
					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
					
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;
					
					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;
					
					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;
					
					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					
					*cp = (char)pItem->m_sItemSpecEffectValue3;
					cp++;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;
					
					// 아이템을 줍고난 후 남은 아이템을 다른 클라이언트에게 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
						                        dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4
					
					// 아이템 정보 전송 
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
					
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
				else 
				{
					// 공간이 부족하거나 한계중량을 초과했다. 아이템을 얻을 수 없다.
					
					// 가져왔던 아이템을 원상회복시킨다. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);
					
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
					
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
			}
			//
		   	break;

		case DEF_MAGICTYPE_CONFUSE:
			// 혼란 마법이다. 
			if  (memcmp(m_pClientList[iClientH]->m_cMapName, "deathmach", 9) == 0) return;
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1: // confuse Language이다. 
			case 2: // Confusion, Mass Confusion 	
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// 자신도 피폭될 수 있으니 주의.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
						// 해당 위치에 캐릭터가 있다.
						if (m_pClientList[sOwnerH] == NULL) goto PMH_SKIP_CONFUSE; // v2.172
						if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto PMH_SKIP_CONFUSE; // v2.172 편이 같으면 혼란 마법 무효 
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							// 상대방이 마법 저항에 실패했다.
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //이미 다른 Confuse효과가 있다면 무시된다.
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
										        sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							// 마법에 걸렸음을 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						}
					}

PMH_SKIP_CONFUSE:; // v2.172
				}	
				break;

						case 3: // Ilusion, Mass-Ilusion
							if  (memcmp(m_pClientList[iClientH]->m_cMapName, "deathmach", 9) == 0) return;
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									// 짭쩐짭창쨔짬창탑 짯창쩌짯짯짬 짭 짭쩐짭쩌짬창쨔 짭짙쩌짭.
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										// 짯창짖쨈짬창쨔쨔 짭창탑짭쨔짭창р 짭쨘짬짝짯짯창탑째짧째창짭 짭쩐짬창쨔짚.
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											// 짭짬창짭짬째짤짭쨈 짬짠짬짼창짖 짭창짭짯창짖짯짭창р 짭창쨔짚짯짢짯창р짬창쨔짚.
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //짭쨈짬짱쨍 짬창쨔짚짬짜쨍 Confuse짯징짢짧쨀쩌짧째창짭 짭쩐짬창쨔짚짬짤쨈 짬짭쨈짭창쨔짬짬창쨔짚.
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 3:
													SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}

											// 짯징짢짧쨀쩌짧째창짭 짯창짖쨈짭짬 짬창짖 짬째짭짯창짖 짬창짬짭쨈 짭쨈짬짼짚짯쨍짬짜쩌 짬창짹짬징짯창짖짬창쨔짚.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											// 짬짠짬짼창짖짭창р 짧짹쨍짬쨍짭짭창탑 짭창짖짬짝째짬창쨔짚.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}	
								break;

						case 4: // Ilusion Movement
							if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "deathmach", 9) == 0) return;  //prohibir el mim en dm
							if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break;
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;
											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 4:
													SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}

											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}	
					}
					break;

		case DEF_MAGICTYPE_POISON:
			// 중독 마법. 먼저 마법 저항을 굴리고 다음으로 독성저항을 한번 더 굴린다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// v1.4334 중립은 플레이어에게 중독을 못하게 수정
			if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

			
			if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
				// 중독을 거는 마법 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					// v2.19 2002-11-17 사낭꾼은 중독 않되게 수정 
					if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;
					// v2.19 2002-11-17 중립은 중독 않되게 수정 
					if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

					// 범죄행위라면 
					bAnalyzeCriminalAction(iClientH, dX, dY);

					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						// 마법 저항에 실패했다. 독성저항을 계산한다.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
							// 중독되었다.
							m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
							SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
							m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
							m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
							// 중독되었음을 알린다. 
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
#ifdef DEF_TAIWANLOG
							_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
						}
					}
					break;
			
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						// 마법 저항에 실패했다. 독성저항을 계산한다.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
							// 중독되었다.
                        SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
						}
					}
					break;
				}
			}
			else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
				// 중독을 푸는 마법 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					
					if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
						// 중독된 상태였다면 중독을 푼다.
						m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
						// 중독이 풀렸음을 알린다. 
						SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
					break;
				}
			}
			break;

		case DEF_MAGICTYPE_BERSERK:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 버서커 모드로 전환된다.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
					// 정적 NPC들은 광분 안됨				
					if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
					// 2002-09-11 #3 적 몬스터는 광분되지 않음
					if ( m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide ) goto MAGIC_NOEFFECT;

					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;
			}
			break;

	/*	case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10*2);
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10*2);
					}
				}
			}
			break;*///armorbreak


							case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				 for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				  m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				  if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				   Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				   ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
				  }

				  m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				  if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				   (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					 Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					 ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}
				   }
				 }
				 break;
		case DEF_MAGICTYPE_ICE:

			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					// 대미지와 함께
					//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// v2.19 2002-11-17 사낭꾼은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;
						// v2.19 2002-11-17 중립은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL) goto MAGIC_NOEFFECT;

						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						
						//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과. 죽지 않았으면 적용 
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
					}
				}
			}
			break;

		default:
			break;
		}
	}
		else {
				if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION) {
					if (m_pClientList[iClientH] != NULL && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
						m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == FALSE) {
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
							if(m_pClientList[sOwnerH] != NULL){
							if ((m_pClientList[iClientH]->m_iAdminUserLevel < 1) &&
								(m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
								return;
							}
							if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != NULL &&
								m_pClientList[sOwnerH]->m_iHP <= 0){
								m_pClientList[sOwnerH]->m_bIsBeingResurrected = TRUE;
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
									if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
										m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = TRUE;
										m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
										m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
										m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

										sTemp = m_pClientList[iClientH]->m_sAppr4;
										sTemp = 0xFF0F & sTemp;
										sTemp = sTemp | 0x40;
										m_pClientList[iClientH]->m_sAppr4 = sTemp;
									}
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, 55, m_pMagicConfigList[sType]->m_dwDelayTime, NULL);
								SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							}
						}
					}
				}
			}

MAGIC_NOEFFECT:;
	if (m_pClientList[iClientH] == NULL) return;
	if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0)
	{	iManaCost = 0;
	}
	if(m_pClientList[iClientH]->m_iAdminUserLevel < 1)
	{	m_pClientList[iClientH]->m_iMP -= iManaCost; 
		if (m_pClientList[iClientH]->m_iMP < 0)
			m_pClientList[iClientH]->m_iMP = 0;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);

}


void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
 short  sOwnerH;
 char   cOwnerType;
 register int i, iErr, ix, iy, sX, sY, tX, tY, iResult, iWhetherBonus, iMagicAttr;
 DWORD  dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;
									   
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	
	// 공격위치가 공격 불가능 맵이라면 공격 불가능 
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	// 몬스터 별 마법 명중률 입력 
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
	
	// 날씨에 의한 마법 공격력 조정  
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);

	// v1.41 마법 속성 
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
	
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0){
		m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
		SetInvisibilityFlag(iNpcH, DEF_OWNERTYPE_NPC, FALSE);
	}

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// 즉시 효과를 보는 마법 
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 보이지 않는 상태로 만든다. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 캐릭터를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 NPC를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC);
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case 2:
				// dX, dY 반경 8 주변의 Invisibility 상태인 Object가 있으면 해제 시킨다.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// 오브젝트의 움직임을 봉쇄한다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; // v1.4 마법 레벨 6이상인 리치급 이상의 마법 몬스터에게는 마비 마법 통하지 않는다.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}
				
				// 봉쇄 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				
				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;
		
		
		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// 일직선 상에 있는 목표를 모두 공격한다.
			sX = m_pNpcList[iNpcH]->m_sX;
			sY = m_pNpcList[iNpcH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT:
			// 이 마법은 명중률과는 상관이 없다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;
		

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:

			// 직격은 계산하지 않는다.			
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

			   	}
			}
			break;
			
		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp가 줄어든다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp가 상승한다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 마법 저항이 필요없다. 
			Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				// 마법저항이 필요 없다.
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		// 2002-12-20 NpcMagicHander에 DEF_MAGICTYPE_ICE 추가 (Ice-Golem 용)
		case DEF_MAGICTYPE_ICE:

			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
	            if (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {					// 대미지와 함께
					//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					
					
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) continue; // goto NMH_NOEFFECT;
						// v2.19 2002-11-17 사낭꾼은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) continue; // goto NMH_NOEFFECT;
						// v2.19 2002-11-17 중립은 얼지 않게 수정 
						if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL) continue; // goto NMH_NOEFFECT;

						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if (m_pClientList[sOwnerH]->m_iHP > 0) {
						if (m_pNpcList[iNpcH]->m_sType == 65){
							Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						}
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
								}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) continue; // goto NMH_NOEFFECT;
						break;
					}
				} // if

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if ((bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult, m_pNpcList[iNpcH]->m_sType) == FALSE)&& (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
						
						//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, TRUE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과. 죽지 않았으면 적용 
						if (m_pClientList[sOwnerH]->m_iHP > 0)  {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
					}
				} // if
			} // for
			break;
		}
	}
	else {
		// Casting 후 딜레이가 걸리는 마법

	}

NMH_NOEFFECT:;

	// Mana를 감소시킨다.
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1이 Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0) 
		m_pNpcList[iNpcH]->m_iMana = 0;

	// 마법 효과를 다른 클라이언트에게 전송한다. 마법번호 + 100이 에펙트 번호 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
					            m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType+100), m_pNpcList[iNpcH]->m_sType);

}


void CGame::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{
 char  * pBuffer = NULL, cTempMapName[21];
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cDestMapName[11], cDir, cMapIndex , cPrice = 0;
 short * sp, sX, sY,aX,aY;
 int   * ip, i, iRet, iSize, iDestX, iDestY, iExH, iMapSide,iTmpMapSide, iGate = 0;
 BOOL    bRet, bIsLockedMapNotify;
 SYSTEMTIME SysTime;
short sSummonPoints;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;

	// v2.16 2002-6-2 상대방 마을에서는 리콜이 되지 않는다.
	// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "deathmach", 9) != 0)
	RefreshDeathmach(iClientH); // Morla 2.3 - actualiza el deathmach

	// 엘바인이면 
	if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE ) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) return ;

	// v2.16 2002-6-2 상대방 마을에서는 리콜이 되지 않는다.
	
	// 아레스덴이면 
	if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) 
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) return ;
	
	bIsLockedMapNotify = FALSE;

	// 만약 교환 모드라면 교환을 취소한다.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// 중립이 리콜 마법을 사용하면 투명하게 되는 버그 수정 
	// 중립이면 리콜 마법을 사용하지 못하게 된다. 
	// v2.14 중립 리콜않되는 버그 수정 
//	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
//		return;

	// 현재 이 플레이어를 목표로 삼고 있는 몹들의 공격행동을 멈추게 한다. 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	
	// 현재 맵 위치에서 지운다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, 
	                                                             m_pClientList[iClientH]->m_sX, 
	   														     m_pClientList[iClientH]->m_sY);

	// 다른 클라이언트들에게 플레이어가 현 위치에서 사라짐을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

	// 현재 텔레포트가 마법에 의한 것인지, 아니면 일반적인 텔레포트 타일에 의한 것인지를 체크한다. 
	// 만약 일반적인 텔레포트 타일에 의한 것이라면 텔레포트할 위치의 맵이름, 좌표를 구해와서 
	// 그 맵이 현재 서버에 존재하는지를 검색한다. 만약 현재 서버에 존재하지 않는다면 클라이언트에게 
	// 다른 서버로의 접속을 시도하라는 메시지를 보낸다. 

	// 먼저 플레이어가 서있는 위치가 텔레포트 타일인지 알아낸다. 
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
		// 만약 갈 맵이 건물 내부라면  

		iMapSide = iGetMapLocationSide(cDestMapName);

		if (iMapSide >= 3) iMapSide -= 2 ;

		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
			// 들어가고자 하는 맵이 같은 편의 건물 내부라면 들어갈 수 있다.
		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet == TRUE) && (cMapName == NULL)) {
		// 플레이어가 텔레포트 타일 위에 서 있다. 텔레포트 할 맵이 현재 서버에 존재하는지 검색한다. 물론 목적지가 지정되지 않은 텔레포트여야한다.

	 	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {
			if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
				// 현재 서버에 텔레포트할 맵이 존재한다.
				m_pClientList[iClientH]->m_sX   = iDestX;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = iDestY;
				m_pClientList[iClientH]->m_cDir = cDir;
				m_pClientList[iClientH]->m_cMapIndex = i; // 맵 인덱스를 바꾼다.
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 맵 이름을 바꾼다.
				goto RTH_NEXTSTEP;
			}
		}

		// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
		m_pClientList[iClientH]->m_sX   = iDestX;	  // 텔레포트 좌표를 입력한다.
		m_pClientList[iClientH]->m_sY   = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  // 맵 이름을 바꾼다.
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
		SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
		
		// 플레이어의 데이터를 저장하고 저장했다는 응답이 오면 클라이언트에게 접속을 다시 할것을 알려준다.
		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);  // ! 카운팅 하지 않는다.
		// !!!!
		m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
		return;
	}
	else {
		// 마법에 의한 텔레포트이다. 
		switch (pData[0]) {
		case '0':
			// Forced Recall. 
			// 레벨 제한이 있는 맵에 들어갔을때 일어난다. 
			
		case '1':
			// Recall.플레이어가 소속된 마을의 진입 포인트로 간다.
			// 만약 부활존이라면 리콜되지 않는다.
			//if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;
						
			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if ( m_pClientList[iClientH]->m_cSide == DEF_NETURAL ) {
				strcpy(cTempMapName, "default");
			}
			else {

				// v2.14 레벨 80 이하는 리콜시 농경지로 간다.
				if (m_pClientList[iClientH]->m_iLevel > 80)
				{
					if( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN )
						strcpy(cTempMapName, "aresden");
					else
						strcpy(cTempMapName, "elvine");
				}
				else {
					if ( m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) 
						 strcpy(cTempMapName, "aresden");
					else strcpy(cTempMapName, "elvine");
				}
			}
			
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
					// 현재 서버에 텔레포트할 맵이 존재한다.
					{
					GetMapInitialPoint(i, &aX, &aY, m_pClientList[iClientH]->m_cLocation);
					if ((m_pClientList[iClientH]->m_sX == aX)&& (m_pClientList[iClientH]->m_sY == aY))
					{
					GetMapInitialPoint(i, &aX, &aY, m_pClientList[iClientH]->m_cLocation);
					if ((m_pClientList[iClientH]->m_sX == aX)&& (m_pClientList[iClientH]->m_sY == aY))
					{
					GetMapInitialPoint(i, &aX, &aY, m_pClientList[iClientH]->m_cLocation);
					}
					}
                    m_pClientList[iClientH]->m_sX = aX;
                    m_pClientList[iClientH]->m_sY = aY;
					}
					/*short playerCoordX = m_pClientList[iClientH]->m_sX;
short playerCoordY = m_pClientList[iClientH]->m_sY;

GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX,      &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

if (playerCoordX == m_pClientList[iClientH]->m_sX
    && playerCoordY == m_pClientList[iClientH]->m_sY)
{
    RequestTeleportHandler(iClientH, "1");

    return;
}*/
					m_pClientList[iClientH]->m_cMapIndex = i; // 맵 인덱스를 바꾼다.
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 맵 이름을 바꾼다.
					goto RTH_NEXTSTEP;
				}
			}

			// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
			m_pClientList[iClientH]->m_sX   = -1;	  // 텔레포트 좌표를 입력한다.
			m_pClientList[iClientH]->m_sY   = -1;	  // -1은 InitialPoint를 말한다.
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
			
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
			
			// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
			// !!!
			m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
			return;
		
		case '2':
			// 목적지가 지정된 텔레포트.
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0) && (memcmp(cMapName, "resurr", 6) != 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// 현재 서버에 목적지가 없다. 
				// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
				m_pClientList[iClientH]->m_sX   = dX; //-1;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  // -1은 InitialPoint를 말한다.
			
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
				// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
				
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);
								
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}

			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		
		case '3':
			// 목적지가 지정된 텔레포트.
			// v2.16 입장권 종류 
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0) && (memcmp(cMapName, "resurr", 6) != 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// 현재 서버에 목적지가 없다. 
				// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
				m_pClientList[iClientH]->m_sX   = dX; //-1;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  // -1은 InitialPoint를 말한다.
			
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
				// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
								
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}

			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		}
	}

RTH_NEXTSTEP:;

	// 2002-11-29 같은 서버의 맵 이동이 있을 경우에도 중독을 제거해 준다. (대만 요청)
	// 다른 서버 이동시에는 중독 정보가 전달 되지 않는다. 따라서 자동적으로 중독이 풀린다.
	m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
	SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

	iSetSide(iClientH);



	//v2.19 2002-11-14 전면전 승리한쪽으 가격을 10프로 싸게 해준다.
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		cPrice = 0;

		if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
			cPrice = -10;
	}
	//2009-03-21
	char cLost = 0; 
	if( TRUE == m_pClientList[iClientH]->m_bIsOnShop ) 
	{
		switch(m_sLastHeldenianWinner){
		case 1:
			cLost = 2;
			break;
		case 2:
			cLost = 1;
			break;
		}
		if(cLost == m_pClientList[iClientH]->m_cSide)
			cPrice += 100;
	}


	// Crusade
	if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);
	
	// 맵데이터를 전송한다.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// 플레이어의 위치를 확정한다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		 bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// 전송할 맵 데이터의 기준위치. 플레이어는 기준위치 (x, y)로부터 (x+14, y+12)에 위치한다.
	sp  = (short *)cp;
	*sp = iClientH;		// Player ObjectID
	cp += 2;
	
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	// v1.4 ApprColor
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;
	
	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;
	
	// (!) 플레이어가 위치하는 맵이름을 기록한다.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// 명칭상의 맵 이름을 입력한다. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// 주야간 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// 기상 상태 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;
	
	// @@@ 플레이어를 맵상에 최초로 위치시킨다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			                                                       DEF_OWNERTYPE_PLAYER, 
																   m_pClientList[iClientH]->m_sX, 
								  								   m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;

	// 2002-11-14 물가 정보 추가
#ifdef DEF_V219
	*cp = cPrice;
	cp += 1;
#else 
	*cp = 0;
	cp += 1;
#endif
		  
	// 맵의 정보를 추가한다. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );
	cp += iSize;

	
	// 메시지 전송 
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 + 1 +4 +4 + 3); // v2.23 // v2.183 // v1.41
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, iSize + 66);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete []pBuffer;
		return;
	}

	if(pBuffer != NULL)	delete []pBuffer;


	// 다른 클라이언트들에게 플레이어가 새로운 위치에 나타났음을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
	

	// 2002-11-15 클라이언트의 Side, OnTown, OnShop 정보를 설정한다.
	iSetSide(iClientH);


	// 플레이어가 다른 맵에 들어갔다. 만약 적국이라면 시간을 설정한다.
	// v2.13 운영자는 강콜되지 않는다. 
	if (( DEF_ARESDEN == m_pClientList[iClientH]->m_cSide) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel < 1) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	}
	// v2.13 운영자는 강콜되지 않는다. 
	else if (( DEF_ELVINE == m_pClientList[iClientH]->m_cSide) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 강콜 시간을 조절 할 수 있게 수정한다.
		SetForceRecallTime(iClientH) ;
	// v2.15 전면전시 중립이 마을로 들어가면 바로 강콜 
	} else if (( DEF_NETURAL == m_pClientList[iClientH]->m_cSide) && 
		(m_bIsCrusadeMode == TRUE) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) 
		|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ; 
	}

		// v2.181 2002-10-24
	// 적 농경지나 건물에 들어가면 강콜 된다. 
	iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	if (iMapSide >= 3) iTmpMapSide = iMapSide - 2 ;
		else iTmpMapSide = iMapSide ;

	m_pClientList[iClientH]->m_bIsInBuilding = FALSE ;

	// 적마을이면 
	if  ((m_pClientList[iClientH]->m_cSide != iTmpMapSide) && (iMapSide != 0) ) {

		// 건물 안이면 
		if ( (iMapSide <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			&& (m_pClientList[iClientH]->m_cSide != DEF_NETURAL) )
		{
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1 ; 
			m_pClientList[iClientH]->m_bIsInBuilding = TRUE ;
		}
	}
	// 같은 서버에 사투장이 떠있는 경우 
	// v1.4311-3 변경 사투장에 입장하면 강콜타임을 시작한다.
	// v2.13 운영자는 강콜되지 않는다.
	// v2.17 길드전 모드에서는 사투장에서 강콜되지 않는다.
#ifndef DEF_GUILDWARMODE
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
		     (m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {  

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// 남아있을 수 있는 잔존 시간을 설정해 준다. 
		// 시간을 구한다음 iWarPeriod를 구한다.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;  
	}
#endif 
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) || 
		   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		      && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; 
		 // 강콜시간이 5분 보다 길면 
		} else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20*5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ;  // 5분
		}
	}
	else {
	m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}

	// v2.17 2002-7-15 강콜 시간을 사용자에게 보여준다.
	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RECALLTIMELEFT,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt) ;
	}


	// 추가로 보내줘야 할 정보를 보낸다. v1.1
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	// v1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	// V1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

	// Crusade 현재 크루세이드 모드이고 플레이어의 CrusadeGUID가 0 혹은 현재와 다르다면 처음 할당되는 것이다. 크루세이드 역할 초기화.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// 크루세이드모드이고 플레이어의 GUID가 0이란 것은 처음 크루세이드 모드에 들어왔다는 의미. 역할 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// 크루세이드모드이고 플레이어의 GUID가 현재 크루세이드 아이디와 다르다는 것은 저번에 벌어졌던 크루세이드의 결과이다.
			// 이런 경우 전공에 따른 포상을 할 수 없다. 최소한 크루세이드 모드가 종료된 다음 다음 전면전이 시작되기 전에 접속을 해야 포상을 얻을 수 있다.
			// 이전에 할당되었던 역할, 건설 포인트, 전쟁 공헌도 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		// 크루세이드 모드가 아닌 경우 역할과 공헌 포인트만 초기화. 전쟁 공헌도는 잠시후에 계산되어서 포상된다.
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}	
		else if (m_bIsHeldenianMode == TRUE) { 
				sSummonPoints = m_pClientList[iClientH]->m_iCharisma*300; 
			if (sSummonPoints > 12000) sSummonPoints = 12000;
			if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) { 
				m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID; 
				m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints; 
			} 
			else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) { 
					m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints; 
					m_pClientList[iClientH]->m_iWarContribution = 0; 
					m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID; 
				} 
if (m_bIsHeldenianMode == TRUE) { 
SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL); 
} 
if (bHeldenianFight == TRUE) { 
SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL); 
} 
SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL); 
bUpdateHeldenianStatus(-1); 
} 
		else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, -1, NULL);

	// v2.15
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	if (m_bIsHeldenianMode == TRUE) { 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL); 
	if (bHeldenianFight == TRUE) { 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL); 
	} 
	else { 
	bUpdateHeldenianStatus(-1); 
	} 
	} 
	// 2002-11-29 같은 서버의 맵 이동이 있을 경우에도 중독을 제거해 준다. (대만 요청)
	// 중독이 풀렸음을 알린다. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsGateAvailable == TRUE) {
		for (iGate = 0; iGate < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalDynamicGate; iGate++) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateX1, 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateY1, NULL, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
		}
	}
	RefreshPartyCoords(iClientH);
}

void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
 register int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
	if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
		if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
			(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
			(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {
			
			m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
		}
	}
}

BOOL CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 쨍쨋쨔첵 쨔첩짙 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					/*if (m_pMagicConfigList[atoi(token)] != NULL) {
						// 쨔 쨈챌쨉 쨔첩짙째징 쨈. 쩔징쨌짱쨈.
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}*/
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 쨍쨋쨔첵 쨍짠 
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// 쨍쨋쨔첵 쩐쨌첫 m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// 쨍쨋쨔첵 쨉척쨌쨔 쩍째짙 m_dwDelayTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// 쨍쨋쨔첵 철쩌쩍째짙 m_dwLastTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 7;
					break;
				
				case 7:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_sValue7
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
					cReadModeB = 13;
					break;
				
				case 13:
					// m_sValue8
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// m_sValue9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// m_sValue10
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// m_sValue11
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// m_sValue12
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return TRUE;

}



BOOL CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 스킬 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pSkillConfigList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate skill number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[atoi(token)] = new class CSkill;
					iSkillConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 스킬 이름 
					ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
					memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// 스킬 종류 m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


// 2002-12-6  Teleport 기능 추가
BOOL CGame::_bDecodeTeleportListConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1: // Teleport 번호
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					iTeleportConfigListIndex = atoi(token);

					if (m_pTeleportConfigList[iTeleportConfigListIndex] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Duplicate Teleport number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex] = new class CTeleport;
					cReadModeB = 2;
					break;

				case 2: // NPC 이름
					memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3: // SOURCE MAP
					memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cSourceMap, token, strlen(token));
					cReadModeB = 4;
					break;

				case 4: // TARGET MAP
					memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cTargetMap, token, strlen(token));
					cReadModeB = 5;
					break;
				
				case 5: // TARGET MAP X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iX = atoi(token);
					cReadModeB = 6;
					break;

				case 6: // TARGET MAP Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iY = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // COST
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iCost = atoi(token);
					cReadModeB = 8;
					break;

				case 8: // Minimum Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMinLvl = atoi(token);
					cReadModeB = 9;
					break;

				case 9: // Maximum Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMaxLvl = atoi(token);
					cReadModeB = 10;
					break;

				case 10: // Side (aresden, elvein)
					if( memcmp(token, "aresden", 7) == 0 )
					{
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = DEF_ARESDEN;
					}
					else if( memcmp(token, "elvine", 6) == 0 )
					{
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = DEF_ELVINE;
					}
					else if( memcmp(token, "both", 4) == 0 )
					{
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = DEF_BOTHSIDE;
					}
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 11;
					break;

				case 11: // HuntMode (0,1)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if( memcmp(token,"0",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = FALSE;
					else if( memcmp(token,"1",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 12;
					break;

				case 12: // Netural (0,1)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if( memcmp(token,"0",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = FALSE;
					else if( memcmp(token,"1",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 13;
					break;

				case 13: // Criminal (0,1)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if( memcmp(token,"0",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = FALSE;
					else if( memcmp(token,"1",1) == 0 )
						m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = TRUE;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "teleport", 8) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			else if (memcmp(token, "[END]", 5) == 0)
			{
				cReadModeA = 0;
				cReadModeB = 0;
				break; // Stop While Loop
			}
		}

		token = pStrTok->pGet();

	} // while

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) TELEPORT-LIST(Total:%d) configuration - success!", iTeleportConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
} // _bDecodeTeleportListConfigFileContents




// 12-22 성후니 수정  마법배우기에 실패한 이유를 클라이언트에 보내준다.
void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL bIsPurchase)
{
 char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet;
 BOOL bMagic = TRUE ;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	// 마법을 배운다. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);
	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// 이런 이름의 마법은 존재하지 않는다. 무시한다. 

	}
	else {
		if (bIsPurchase == TRUE) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE ; // 일반적으로 배울수 없는 마법이라면(가격이 음수) 배울 수 없다.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount)  bMagic = FALSE ; // 돈이 부족해도 배울 수 없다.
			// v2.20 2002-12-23 마법을 배울수 있는곳인지 체크 한다.
			//if (m_pClientList[iClientH]->m_bIsOnTower == FALSE) bMagic = FALSE ;
		}
	
		// 이미 배운 마법을 다시 배우겠다고 요청하면 무시 
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= (m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt)) && (bMagic == TRUE) ) {
			
			// 돈을 사용했음을 알린다.
			if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			
			// 소지품 총 중량 재 계산 
			iCalcTotalWeight(iClientH);
		
			// 마법 사용 능력 표시 .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
	
			// 마법을 배웠다는 메시지를 전송한다.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			
			// 마법 번호 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			// 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

#ifdef DEF_TAIWANLOG 
			_bItemLog(DEF_ITEMLOG_MAGICLEARN,iClientH, cMagicName, NULL);
#endif
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// 조건이 만족되지 않아 마법을 배울 수 없다.
			// 마법을 배울수 없었다는 메시지를 전송한다.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// 실패이유.
			*cp = 1;
			cp++;

			// 마법 번호 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;

			// 정보 전송 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
}


// v2.15 2002-5-21
BOOL CGame::_bDecodeWLServerConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadMode = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadMode != 0) {
			switch (cReadMode) {
			case 1:
					m_iWorldLogServerPort = atoi(token);
					cReadMode = 0;
					break;
			wsprintf(cTxt, "(!) world-server-port (%d)!",m_iWorldLogServerPort);
			PutLogList(cTxt);

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "world-server-port", 17) == 0) cReadMode = 1;
		}
		token = pStrTok->pGet();
	}	
	
	delete pStrTok;
	delete []pContents;

	if ((cReadMode != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! WLServer.cfg configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) World configuration - success!");
	PutLogList(cTxt);

	return TRUE;
}

// 2002-12-8 World server 보안 설정을 위해 

BOOL CGame::_bDecodeWorldConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
					m_iWorldMaxUser = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			case 2 :
					m_iPlayerMaxLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			case 3: // v2.17 2002-7-15 월드 서버에서 강콜시간을 수정할 수 있게 한다.
					m_sForceRecallTime = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

			wsprintf(cTxt, "(!) Force Recall Time (%d)min !",m_sForceRecallTime);
			PutLogList(cTxt);

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "world-server-max-user", 21) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
			if (memcmp(token, "world-server-forcerecall-time", 29) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	
	
	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! world.cfg configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) World configuration - success!");
	PutLogList(cTxt);

	return TRUE;
}

// v2.15 2002-8-7 // 2002-09-06 #1
BOOL CGame::_bDecodeNpcItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 int k = 0;
 class CStrTok * pStrTok;
 class CNpcItem * pTempNpcItem = NULL ;
  
	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:

				switch (cReadModeB) {

				case 1:
					// NPC 이름
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					for (iNpcConfigListIndex = 0; iNpcConfigListIndex < DEF_MAXNPCTYPES; iNpcConfigListIndex++)
						if (m_pNpcConfigList[iNpcConfigListIndex] != NULL) {
							if(strcmp(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName,token) == 0) {
								PutLogList(token);
								break ;	
							}
						}

					if (iNpcConfigListIndex == DEF_MAXNPCTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - No exist Npc Name");
						delete pContents;
						delete pStrTok;
						return FALSE ;
					}

					cReadModeB = 2;
					break;

				case 2:
					// 2002-09-17 #1
					// npcitem type 설정
					if( strlen(token) > 2 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Type Error.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcitemType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					// 아이템 이름 
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Item name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					if (pTempNpcItem == NULL)
						pTempNpcItem = new class CNpcItem();


					if( memcmp(token,"[ENDITEM]",9) == 0 ){
						cReadModeA = 0 ;
						cReadModeB = 0 ;

						if ( pTempNpcItem  != NULL) {
							delete pTempNpcItem ; 
							pTempNpcItem = NULL ;
						}
						break;
					}
					
					strcpy(pTempNpcItem->m_cName, token);

					// 2002-09-09 #1 NPCITEM List 에 ID를 추가한다.
					// 주의 : ITEM List가 NPCITEM List 보다 먼저 WLS에서 보내져야 한다.
					if( !m_bReceivedItemList )	// ITEM List가 오지 않았다.
					{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Before Item List receiving.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					for(k=0; k<DEF_MAXITEMTYPES; k++)
					{
						if ( m_pItemConfigList[k] == NULL )
							continue;
			
						if ( strcmp(token, m_pItemConfigList[k]->m_cName) == 0 ) {
							pTempNpcItem->m_sItemID = m_pItemConfigList[k]->m_sIDnum;

							break;
						}
					}

					if ( k == DEF_MAXITEMTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Do Not exist in ITEM LIST");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 4;
					break;

				case 4:
					// 첫번째 확률
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					pTempNpcItem->m_sFirstProbability = atoi(token);

					if (pTempNpcItem->m_sFirstProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - First probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					// 첫번째 확률에 대한 타겟값을 임의로 준다. 
					if ( pTempNpcItem->m_sFirstProbability > 13) 
						pTempNpcItem->m_cFirstTargetValue = 13;
					else if ( pTempNpcItem->m_sFirstProbability > 3) 
						pTempNpcItem->m_cFirstTargetValue = 3;
					else 
						pTempNpcItem->m_cFirstTargetValue = 1;
						
					cReadModeB = 5;
					break;

				case 5:
					// 두번째 확률
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					pTempNpcItem->m_sSecondProbability = atoi(token);

					if (pTempNpcItem->m_sSecondProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Second probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					// 두번째 확률에 대한 타겟값을 임의로 준다. 
					if ( pTempNpcItem->m_sSecondProbability > 13) 
						pTempNpcItem->m_cSecondTargetValue = 13 ;
					else if ( pTempNpcItem->m_sSecondProbability > 3) 
						pTempNpcItem->m_cSecondTargetValue = 3 ;
					else 
						pTempNpcItem->m_cSecondTargetValue = 1 ;

					cReadModeB = 3;
			
					// vector에 현재 까지 읽어 드린 값을 넣는다. 
					m_pNpcConfigList[iNpcConfigListIndex]->m_vNpcItem.push_back(*pTempNpcItem);

					// 2002-09-17 #1 NPCITEM Type 2일 경우
					if( m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcitemMax < pTempNpcItem->m_sSecondProbability )
						m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcitemMax = pTempNpcItem->m_sSecondProbability;

					break;

				} // switch #2

			default: 
				break;

			} // switch #1
		} // if
		else {

			if (memcmp(token, "NpcItem", 7) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file contents error!");
		return FALSE;
	}

	return TRUE;

} // _bDecodeNpcItemConfigFileContents()


int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
 register int i;
 char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	if (m_pMagicConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
			// 같은 이름을 가진 마법 설정을 찾았다. 마법 번호를 반환한다.
			*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
			*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;
			
			return i;
		}
	}
	
	return -1;
}



/*aca
int CGame::_iGetSkillNumber(char * pSkillName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strncpy(cTmpName, pSkillName, sizeof(cTmpName)-1);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[ i ] != NULL) {
		if (memcmp(cTmpName, m_pSkillConfigList[ i ]->m_cName, 20) == 0) {
			return i;
		}
	}
	
	return 0;
}
*/
int CGame::_iGetSkillNumber(char * pSkillName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
			// 째째쨘 쨍짠쨩 째징첩 짹창쩌첬 쩌쨀짚쨩 짙쩐쨈. 짹창쩌첬 쨔첩짙쨍짝 쨔짱쨈.
			return i;
		}
	}
	
	return 0;
}



BOOL CGame::__bReadMapInfo(int iMapIndex)
{
 char * pContents, * token, * pTile, cTxt[250], cFn[255];	 
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportLocIndex  = 0;
 int  iWayPointCfgIndex  = 0;
 int  iTotalNpcSetting   = 0;
 int  iMGARCfgIndex      = 0;
 int  iSMGRCfgIndex      = 0;
 int  iNMRCfgIndex       = 0;
 int  iFishPointIndex 	 = 0;
 int  iMineralPointIndex = 0;
 int  iStrategicPointIndex = 0;
 int  iIndex = 0;
 int  iNumMob = 0;

 int  iNamingValue;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

 char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
 short sIPindex, dX, dY;
 SYSTEMTIME SysTime;

	// 사투장인지를 판단.
	// 2002-7-4 사투장의 갯수를 늘릴 수 있도록 
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fight", 5) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;


	// v2.20 2002-12-20 크리스마스와 iceboud맵에서는 항상 눈이 내린다.
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;

	GetLocalTime(&SysTime);
	if( SysTime.wYear == 2007 && SysTime.wMonth == 12 && SysTime.wDay == 25 ) {
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;
	}



	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 맵 정보파일을  읽을 수 없다.
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}
	else {
		wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 텔레포트 소스 좌표 X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// 텔레포트 소스 좌표 Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 텔레포트 목적지 맵 이름 
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						       sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					// 텔레포트 목적지 위치 X 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// 텔레포트 목적지 위치 Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;
				
				case 6:
					// 텔레포트 후 방향  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint 번호   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						// 이미 할당되어있는 Waypoint 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// waypoint 집합 정의 X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint 집합 정의 Y  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// Npc를 특정위치에 위치시킨다.
				switch (cReadModeB) {
				case 1:
					// NPC의 이름. 
					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					// 이제 이곳에서 NPC를 생성한다. 
					
					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
					}
					else {
						// NPC를 생성한다.
						ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;
											
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
							// 실패했으므로 예약된 NameValue를 해제시킨다.
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						} 
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator 사용 여부 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				// 캐릭터 랜덤 생성 금지 구역 : 마을 중심부 같은데서 몹이 발생되면 곤란하므로 
				switch (cReadModeB) {
				case 1:
					// Rect 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						// 이미 할당되어있는 Waypoint 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:
				// 특정지역 몹 생성 
				switch (cReadModeB) {
				case 1:
					// Rect 번호 m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
						// 이미 할당되어있는 몹 제너레이터 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECT가 아니라 Waypoint집합을 읽어야 한다.
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;

			case 8:
				// 맵이 속한 장소 이름 
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
		
			case 10:
				// 공격 무효화 영역 RECT
				switch (cReadModeB) {
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						// 이미 할당되어있는 No-Magic-Rect 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL)atoi(token);
				// v2.20 2002-12-20 크리스마스와 iceboud맵에서는 항상 눈이 내린다.
				// 건물안에는 눈이 내리지 않는다.
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
					m_pMapList[iMapIndex]->m_bIsFixedSnowMode = FALSE;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// 이미 할당되어있는 Fish Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				// 광물 제네레이터의 존재유무와 등급 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// 이미 할당되어있는 Mineral Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
						// 이미 할당되어있는 Strategic Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
						// 이미 할당되어있는 Energy-Sphere-Creation Point 번호이다.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
						// 이미 할당되어있는 Energy-Sphere-Goal Point 번호이다.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
						// 이미 할당되어있는  Point 번호이다.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);
					
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);
					
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);
					
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);
					
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);
					
					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);
					
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);
					
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);
					
					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);
					
					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;

					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			case 24: // item event
				/*
				; mapdata에 들어갈 내용
				;item-event = index	item_name	amount	TotalNumber	month	day	type	mob_list[Max:5]
				;	type = 0 : 해당 아이템이 일반 아이템 생성과정에서 생성되지 않는다.
				;	       1 : Item Event에 의해서도 생성되고 일반 아이템 생성과정을 통해서도 생성된다.

				item-event = 	1	XelimaStone	1	10		11	1	0	Cannibal-Plant Ettin EOL
				item-event = 	2	MerienStone	1	10		11	1	0	Giant-Frog Scorpion EOL
				*/
				switch (cReadModeB) {
				case 1: //  index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						// 이미 할당되어있는 Item-Event 번호이다.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;
				
				case 2: // item_name
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3: // amount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4: // total number
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5: // month
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6: // day
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7: // type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iType = atoi(token);

					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob = 0;

					cReadModeB = 8;
					break;

				case 8: // monster list
					if( strcmp(token, "EOL") == 0 ) {
						cReadModeA = 0;
						cReadModeB = 0;
					} else {
						iNumMob = m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob;
						
						if( iNumMob >= 5 ) {
							cReadModeA = 0;
							cReadModeB = 0;
							PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
							break;
						}

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob] = new char[21];

						ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob],
							sizeof(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob]) );

						strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob], token);

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob ++;

						cReadModeB = 8;
					}
					break;
				}
				break;
			
			case 25:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;
				
			case 26: //ApocalypseMobGenType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: // ApocalypseBossMob
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;					
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.left = atoi(token);
					cReadModeB = 3;					
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.top = atoi(token);
					cReadModeB = 4;					
					break;
				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.right = atoi(token);
					cReadModeB = 5;					
					break;
				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;					
					break;
				}
				break;

			case 28: //DynamicGateType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
								
			case 29: //DynamicGateCoord
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateTgtY = atoi(token);
					m_pMapList[iMapIndex]->m_iTotalDynamicGate++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 30: // RecallImpossible
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsRecallImpossible = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 31: // ApocalypseMap
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			
			case 32: // CitizenLimit
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsCitizenLimit = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
							case 33: // HeldenianMap
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: // HeldenianTower
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
			case 35: // HeldenianModeMap
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			case 36: // HeldenianWinningZone
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					dX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					dY = atoi(token);
					pTile = 0;
					pTile = (char *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
					if (pTile == 0) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map Info file error HeldenianWinningZone - pTile is Null dx(%d), dy(%d).", dX, dY);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//pTile->m_iAttribute = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;


case 37: // HeldenianGateDoor // 37 
switch (cReadModeB) { 
case 1: 
if (_bGetIsStringIsNumber(token) == FALSE) { 
PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format."); 
delete pContents; 
delete pStrTok; 
return FALSE; 
} 
m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token); 
cReadModeB = 2; 
break; 
case 2: 
if (_bGetIsStringIsNumber(token) == FALSE) { 
PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format."); 
delete pContents; 
delete pStrTok; 
return FALSE; 
} 
m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token); 
cReadModeB = 3; 
break; 
case 3: 
if (_bGetIsStringIsNumber(token) == FALSE) { 
PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format."); 
delete pContents; 
delete pStrTok; 
return FALSE; 
} 
m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token); 
iIndex++; 
cReadModeA = 0; 
cReadModeB = 0; 
break; 
} 
break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;	
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;	
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;	

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;	
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;	
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				// 별도의 디코딩이 필요 없다.
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}

			// 2002-7-4 몹이벤트시 몹의 갯수를 맵에서 설정 할 수 있게 한다.
			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}
			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	

RMI_SKIPDECODING:;

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);

	// Crusade 공격 불가능 영역을 타일에 표시한다.
	m_pMapList[iMapIndex]->_SetupNoAttackArea();
	//m_pMapList[iMapIndex]->bApocalypseGate();
	return TRUE;

}

void CGame::Quit()
{
 int i;	

	// 쓰레드를 죽인다.
	G_bIsThread = FALSE;
	Sleep(300);
		
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;
#ifdef DEF_RADMIN
	if (m_pRAdminSock != NULL) delete m_pRAdminSock;
#endif
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];	
	}
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

	if (m_pGold != NULL) delete m_pGold;

}

int CGame::iGetLevelExp(int iLevel)
{
 int iRet;
	
	if (iLevel == 0) return 0;
	
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );


	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
 int iRet;

	if (iLevel < 1) return 1;
	
	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * iLevel ) / 10;
	}

	return iRet;
}

//pegalo aca
BOOL CGame::bCheckLevelUp(int iClientH) // Sobrepaso de lvl fix.
{
 BOOL bStr, bVit, bDex, bInt, bMag, bChr;
 char cLoopCnt;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (	(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && 
					(m_pClientList[iClientH]->m_iHP > 0) && 
					(m_pClientList[iClientH]->m_iLevel >= 10) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DESTINY, NULL, NULL, NULL, NULL);

	
	if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL) {
		if (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[DEF_PLAYERMAXLEVEL + 1]) {
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[DEF_PLAYERMAXLEVEL];
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft > DEF_MAXGIZONPOINT ) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = DEF_MAXGIZONPOINT; // adamas
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
		}
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL - 1 ) && (m_pClientList[iClientH]->m_bIsHunter == TRUE ) ) 
	{
		SetNoHunterMode(iClientH,TRUE) ;
	}

	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;
	
	bStr = bVit = bDex = bInt = bMag = bChr = FALSE;
	cLoopCnt = 0;
	while (m_pClientList[iClientH]->m_iExp > m_pClientList[iClientH]->m_iNextLevelExp
    && m_pClientList[iClientH]->m_iLevel < DEF_PLAYERMAXLEVEL)
		{
		
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3; // v2.23
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			//ZeroEoyPnk - Al subir nivel, vida, mana, y sp maximo
			m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
			m_pClientList[iClientH]->m_iMP = (2*(m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag)) + (2*m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt)/2);
			m_pClientList[iClientH]->m_iSP = (2*(m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)) + (2*m_pClientList[iClientH]->m_iLevel);				

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);
			//ZeroEoyPnk - Lo mismo que dije antes, pero notifico
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);

			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);
		
			CalcTotalItemEffect(iClientH, -1, FALSE);

			if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL) {
				wsprintf(G_cTxt, "(!) Character (%s) is over max level", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);
			}
			
			if (m_pClientList[iClientH]->m_iLevel > 20 && m_pClientList[iClientH]->m_iLevel <= 50)
				GoldPorLevel(iClientH);
		}
		else return TRUE;
	}
	return TRUE;
}

void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp;
 int * ip;
 int cStr, cVit, cDex, cInt, cMag, cChar;
 int iTotalSetting = 0;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	ip = (int *)cp;
	cStr = (int) *ip;
	cp  += 4;

	ip = (int *)cp;
	cVit = (int) *ip;
	cp  += 4;

	ip = (int *)cp;
	cDex = (int) *ip;
	cp  += 4;

	ip = (int *)cp;
	cInt = (int) *ip;
	cp  += 4;

	ip = (int *)cp;
	cMag = (int) *ip;
	cp  += 4;

	ip = (int *)cp;
	cChar = (int) *ip;
	cp  += 4;
	
	if ((cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	// Level-Up Setting값에 오류가 있는지 검사한다.
	if ((m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT) || (cStr < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT) || (cDex < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT) || (cInt < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT) || (cVit < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT) || (cMag < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT) || (cChar < 0)) 
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3 > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70))
	{
		int bobdole;
		bobdole = 3;
		m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;

		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar)
		>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);

	m_pClientList[iClientH]->m_iStr  += cStr;
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->m_iDex  += cDex;
	m_pClientList[iClientH]->m_iInt  += cInt;
	m_pClientList[iClientH]->m_iMag  += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;

//AutoSkill(iClientH);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

	

}


// v1.4311-3 추가 사투장 예약 함수 FightzoneReserveHandler
void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cData[100];
 int iFightzoneNum ,* ip ,  iEnableReserveTime ;
 DWORD * dwp, dwGoldCount ;
 WORD  * wp, wResult;
 int     iRet, iResult=1, iCannotReserveDay;
 SYSTEMTIME SysTime;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 
	GetLocalTime(&SysTime);
	
	// 예약 가능한 시간 : 두시간 간격으로 예약이 가능하며 사용완료 5분전에는 예약이 불가능하다.
	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;
	
	dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	// 예약을 원하는 사투장 번호를 받는다.
	iFightzoneNum = *ip;

	// 잘못된 fightzone 번호를 걸러낸다.
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// v2.05 길드전 연습용 사투장 1,2,3,4번은 당분간 판매하지 않는다.
	//if ((iFightzoneNum >= 1) && (iFightzoneNum <= 4)) return;

	// 사투장이 중복되지 않게 하기 위해 요일에 따라 사용할수 있는 사투장이 다르게 하기 위한 변수다.
	// 홀수날에는 아레스덴 2 4 6 8 엘바인이 1 3 5 7  사투장이 사용가능하다 
    //             ex) 1일인경우 => {1 + 1 (아레스덴) + 1 (사투장 번호 )} %2 == 1 이므로 
	//                            아레스덴은 홀수날 홀수 사투장을  예약 할수 없다. 

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		// 예약에 실패했다. 
		// 만약 예약 가능한 시간이 아니면 0 값을 클라이언트에 보내고 
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		// 사투장이 예약 되어 있으면  -1 값을 클라이언트에 보낸다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		// 플레이어가 갖고있는 Gold가 입장권 가격에 비해 적다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2 ;	           // 돈이 적으면 -2 값을 클라이언트에게 보낸다.
	} else if( iCannotReserveDay ) {
		// 오늘은 예약할 수 없는 날이다. 이때는 -3 값을 클라이언트에 보낸다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3 ;
	} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
		// 이미 다른 사투장을 예약했다. 이때는 -4 값을 클라이언트에 보낸다.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4 ;
	} else {
		// 사용자가 고른 사투장이 예약이 되어 있지 않고 
		// 예약에 필요한 금액도 가지고 있고
		// 예약 가능한 시간이면  예약한다.
	
		// 예약에 성공 했다. 
		wResult = DEF_MSGTYPE_CONFIRM;

		// 사투장 예약을 위한 금액을 감소 시킨다.
		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);
		
		// 사투장을 예약한 클라이언트의 ID를 넣는다.
		m_iFightZoneReserve[iFightzoneNum-1] = iClientH;
		
		m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
		m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

		// v2.15 사투장 번호를 로그에 남기기 위해 
#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_RESERVEFIGZONE,iClientH,(char *)NULL,NULL) ;
#endif

		if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;	// 홀수 시간대이면 한시간 후까지 예약된다.
		else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    // 짝수 시간대이면 두 시간 후까지 예약된다.
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
		iResult = 1 ;
	}  

	ZeroMemory(cData, sizeof(cData));

	dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

	wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp =  wResult ;

	ip  = (int *)(cData + DEF_INDEX2_MSGTYPE+2) ; 
	*ip =  iResult ;
	ip+= 4;
	
	// 사투장 예약 응답 메세지  클라이언트에게 전송
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
 
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}


BOOL CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if ( (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) && 
		 (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20 ) ) {
		// 여행자가 레벨 20 경험치를 얻었다면 19수준으로 환원. 

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}

	return FALSE;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
 char * cp, cData[100];
 DWORD * dwp;
 WORD * wp, wResult;
 int  iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// 이미 한 마을의 소속이 있다면 시민권을 가질 수 없다. 
	if ( m_pClientList[iClientH]->m_cSide != DEF_NETURAL ) wResult = 0;
	else wResult = 1;

	// 레벨이 5 이하라도 시민권을 얻을 수 없다. 
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;
	
	if (wResult == 1) {
		// 현재 맵의 이름을 할당한다.
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);

#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_APPLY, iClientH, (char) 0 , NULL) ;
#endif
	}


	// Side 할당
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) 
		m_pClientList[iClientH]->m_cSide = DEF_ARESDEN;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) 
		m_pClientList[iClientH]->m_cSide = DEF_ELVINE;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wResult;

	// v1.41 맵 이름 알려줌
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	// 응답 메시지를 클라이언트에게 전송
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// 특성이 바뀌므로 외양을 새로 보낸다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	
	// 시민권을 얻은 플레이어가 파티원이라면 파티에서 해제된다. 
	if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDeletePartyHandler(iClientH);

	// 2002-10-31 시민권 따는 순간에도 검사한다.
//	CheckSpecialEventThirdYear(iClientH);

	// v2.20 2002-12-31 시민권 따는 순간 자동으로 민간인 모드로 설정된다.
	RequestHuntmode(iClientH);

}


void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
 char * cp, cBankItemIndex, cMsg[100];
 register int i, j, iRet, iItemWeight;
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;

	// v2.20 2002-12-23 창고인지 체크 한다.
	//if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return ;


	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		// 오류다. 
		ZeroMemory(cMsg, sizeof(cMsg));
			
		dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {
		// 중량계산 
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		
		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			// 한계중량 초과, 아이템을 찾을 수 없다. 
			// 실패 메시지를 보낸다.
			ZeroMemory(cMsg, sizeof(cMsg));
			
			// 더이상 가질수 없다는 메시지를 보낸다.
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
			return;
		}
		
		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			// 중복이 가능한 아이템이라면 수량만 증가시킨다.	
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				 (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
			 	 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {
				// 같은 형식의 아이템을 찾았다. 수량을 증가시킨다.
				// v1.41 !!! 
				SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
				
				// 뱅크 아이템 삭제 
				delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

				// v2.17 2002-7-31 새크리파이스 버그 여부를 판별하기 위해 추적 로그 추가 
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
				{
					if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == 650 )
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
					else 
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i]) ;
				}


				// 빈 공간을 없앤다. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
				
				// 성공 메시지를 보낸다.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
			
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);
				// 화살 할당
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
								
				// 메시지 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);



				// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
				m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}

			// 같은 이름을 갖고 있는 아이템이 없다. 새로 추가해야 한다. 
			goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			// 수량개념이 없는 아이템 
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				// 빈 공간을 찾았다. 
				// 먼저 주소를 옮긴다. 
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				// v1.3 1-27 12:22
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
			
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
				
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;
				
				// v2.17 2002-7-31 새크리파이스 버그 여부를 판별하기 위해 추적 로그 추가 
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
				{
					if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == 650 )
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
					else 
						_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i]) ;
				}

				
				// 빈 공간을 없앤다. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
								
				// 성공 메시지를 보낸다.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
					
				// 소지품 총 중량 재 계산 
				iCalcTotalWeight(iClientH);
		
				// 화살 할당
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

						
				// 메시지 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);

				// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
				m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			// 아이템을 되찾을 공간이 없다. 오류
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

BOOL CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
 class CItem * pItem;
	
	// 소지하고 있는 아이템을 보관한다.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	// v2.20 2002-12-23 창고인지 체크 한다.
	if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return FALSE;


	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		// 비어있는 위치를 찾았다.
				
		m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
		pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
		// !!! 아이템의 포인터를 이동했으니 기존의 포인터는 NULL값으로 할당. 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		
		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);			   
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);		       
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // 위치 저장 
		cp++;

		// 1개.
		*cp = 1;
		cp++;						    

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// v2.14 창고에서 아이템을 가저오면 순도가 이상해지는 버그 수정 
		*cp = (char) pItem->m_sItemSpecEffectValue2 ;
		cp ++ ;
		
		*cp = (char) pItem->m_sItemSpecEffectValue3 ;
		cp ++ ;

		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 56); // 56

#ifdef DEF_TAIWANLOG
		_bItemLog(DEF_ITEMLOG_DEPOSIT, iClientH, (int) -1, pItem);
#endif

		// v2.13 성후니 추가 DB 부하를 줄이기 위한 변수
		m_pClientList[iClientH]->m_bIsBankModified = TRUE ;

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다. v1.41 제거하지 않는다.
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSE를 반환하면 아이템이 바닥에 복사된다.
		}

		return TRUE;
	}

	// 아이템을 보관할 여유공간이 없다.
	return FALSE;
}


void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
 int iV1, iV2;

	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL) return;
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return; 
	if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) return; // v2.95
	if (memcmp(m_pClientList[sAttackerH]->m_cMapName, "deathmach", 9) == 0) return;
	if (bAllVsAll) return;
	
	m_pClientList[sAttackerH]->m_iPKCount++;
	_bPKLog(DEF_PKLOG_BYPK,sAttackerH,sVictumH,NULL) ;
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel/2)+1, 50); 
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel/2)+1, 50);
	m_pClientList[sAttackerH]->m_iExp -= iV1; 
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating =  10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;
	

	if ( m_pClientList[sAttackerH]->m_cSide == DEF_ARESDEN ) {
#ifndef DEF_PKPENALTY               //  v2.19 2002-11-18 PK 하면 무조건 감옥으로 
		if (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cLocationName, "aresden") != 0 ) return ;
#endif	
		ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
		strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
		m_pClientList[sAttackerH]->m_iLockedMapTime = 30*1;
		RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
		return ;		
	}

	if ( m_pClientList[sAttackerH]->m_cSide == DEF_ELVINE ) {

#ifndef DEF_PKPENALTY
		if (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cLocationName, "elvine") != 0  ) return ;
#endif
		ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
		strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
		m_pClientList[sAttackerH]->m_iLockedMapTime = 30*1;
		RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
		return;		
		
	}
}


void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL)   return;

	_bPKLog(DEF_PKLOG_BYPLAYER,sAttackerH,sVictumH,NULL) ;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
	}
	else {
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;
		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;
		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
	}
}

//New Function - ZeroEoyPkn
void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
 int iRewardExp, iEK_Level;

	if (m_pClientList[iAttackerH] == NULL) return;
	if (m_pClientList[iClientH] == NULL)   return;
	if  (memcmp(m_pClientList[iClientH]->m_cMapName, "deathmach", 9) == 0) return; // MORLA 2.3 - Para que no den eks

		if ((strcmp(m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iAttackerH]->m_cIP2)==0)
	||(strcmp(m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iAttackerH]->m_cIPaddress)==0)) 
	{
		char cMsg[150];
		ZeroMemory(cMsg, sizeof(cMsg));
		wsprintf(cMsg, "Your EK(%s) has been blocked. Kill any other player!", m_pClientList[iClientH]->m_cCharName);
		ShowClientMsg(iAttackerH, cMsg);
		return; 
	}

	strcpy(m_pClientList[iAttackerH]->m_cIP2,m_pClientList[iClientH]->m_cIPaddress); 

	_bPKLog(DEF_PKLOG_BYENERMY,iAttackerH,iClientH,NULL) ;

	iEK_Level = 1;
	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
	}
	else {
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;
		if (bHappyHour == FALSE){  m_pClientList[iAttackerH]->m_iEnemyKillCount; } else {m_pClientList[iAttackerH]->m_iEnemyKillCount += 10*3;}
		//FurDay by prlucas
		if (bFuryDay == FALSE){  m_pClientList[iAttackerH]->m_iEnemyKillCount; } else {m_pClientList[iAttackerH]->m_iEnemyKillCount += 10*9;}
			
			
			if (m_bIsCrusadeMode == TRUE) {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;
				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;
				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);
#ifdef DEF_HIGH
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10*2;
#endif
#ifdef DEF_LOW
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10*2;
#endif
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
#ifdef DEF_HIGH
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10;
#endif
#ifdef DEF_LOW
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10;
#endif
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		else {
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;
			if (bHappyHour == FALSE){  m_pClientList[iAttackerH]->m_iEnemyKillCount; } else {m_pClientList[iAttackerH]->m_iEnemyKillCount += 10*3;}
			//FurDay by prlucas
			if (bFuryDay == FALSE){  m_pClientList[iAttackerH]->m_iEnemyKillCount; } else {m_pClientList[iAttackerH]->m_iEnemyKillCount += 10*9;}
			if (m_bIsCrusadeMode == TRUE) {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;
				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;
				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);
#ifdef DEF_HIGH
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10*2;
#endif
#ifdef DEF_LOW
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10*2;
#endif
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else { 
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
#ifdef DEF_HIGH
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10;
#endif
#ifdef DEF_LOW
					m_pClientList[iAttackerH]->m_iEnemyKillCount+=10;
#endif
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		if (m_pClientList[iAttackerH]->m_bAutoSS)
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_AUTOSSORDER, NULL, NULL, NULL, NULL);
		if (bCheckLimitedUser(iAttackerH) == FALSE) {
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
		bCheckLevelUp(iAttackerH);
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

void CGame::ApplyCombatKilledPenalty(int iClientH, char cPenaltyLevel, BOOL bIsSAattacked, BOOL bItemDrop)
{  
 int iExp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// Crusade
	if (m_bIsCrusadeMode == TRUE) {
		// 크루세이드 모드인 경우 전쟁중에 죽어도 아무런 페널티가 없다.
		// PKcount만 감소 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15 
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,(int) -1,iClientH,NULL) ;

		}
		return;
	}
	else {
		// PKcount 감소 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,(int) -1,iClientH,NULL) ;
		}

		// 플레이어로부터의 공격을 받고 전쟁중 사망했다.
		iExp = iDice(1, (5*cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));

		// 중립인 경우 죽었을 때 떨어지는 경험치는 1/3
		if (m_pClientList[iClientH]->m_bIsNeutral == TRUE) iExp = iExp / 3;

		// v2.17 2002-7-31 최고렙은 죽었을때 경치가 떨어지지 않는다. 수정 
		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	
		// v1.41 중립은 아이템이 떨어지지 않는다.
		if (m_pClientList[iClientH]->m_bIsNeutral != TRUE) {
			// v2.19 2002-11-14
#ifdef DEF_ITEMDROP
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// 레벨 80 미만은 아이템이 하나 적게 떨어진다.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked); 
				
			}
			else 
			{
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked); 
			}
#else
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// 레벨 80 미만은 아이템이 하나 적게 떨어진다.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
			else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
#endif
		}
	}
}

void CGame::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked)
{
  int i, j, iRemainItem;
 char cItemIndexList[DEF_MAXITEMS], cItemIndex;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ( (m_pClientList[iClientH]->m_iLuck >= 55) && (iDice(1, 5) == 3)) return;
	//code no dropear con zem kazin
	for (i = 0; i < DEF_MAXITEMS; i++)	{ //recorro todos los items
		if (!m_pClientList[iClientH]->m_pItemList[i]) continue;	 //si los items existen
		if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == 650)	{ //y si el item es un zem
			m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan--; //le bajo el endu
 
			if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan > 0)	//si tiene mas de 1 de endu
				DropItemHandler(iClientH, i, 1, m_pClientList[iClientH]->m_pItemList[i]->m_cName, FALSE); //lo dropeo
			else ItemDepleteHandler(iClientH, i, FALSE, FALSE); //sino, lo elimino
			return;
		}
	}

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) {
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);
 
			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		}
		else {
			PutLogFileList("Alter Drop Item Index Error1");
			for (i = 0; i < DEF_MAXITEMS; i++) 
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
				m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
				if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
					m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

				DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);	
				m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
				return;
			}
			goto PID_DROP;
		}
		return;
	}
	PID_DROP:;
	for (i = 1; i <= iTotal; i++) 
	{	iRemainItem = 0;
		ZeroMemory(cItemIndexList, sizeof(cItemIndexList));		
		for (j = 0; j < DEF_MAXITEMS; j++) 
		{	if (m_pClientList[iClientH]->m_pItemList[j] != NULL) 
			{	if (   (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectType != 0) 
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) 
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) 
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) 
				{	continue;
				}
				if (   (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum >= 398)
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum <= 428)
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum != 402))
				{	continue;
				}	
				if (   (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum >= 700)
					&& (m_pClientList[iClientH]->m_pItemList[j]->m_sIDnum <= 710)) 
				{	continue;
				}
				if (((m_pClientList[iClientH]->m_pItemList[j]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY))
					&& (bIsSAattacked == FALSE)) 	
				{	continue;
				}
				cItemIndexList[iRemainItem] = j;
				iRemainItem++;
		}	}	
		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];				
		DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName, FALSE);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
 int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cData[100], cItemName[21];
 class CItem * pItem;
 short * sp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	
	// 남은 중량을 계산한다. 
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
		
	if (iWeightLeft <= 0) return;
	// 중량을 반으로 나눈다. <- 찾은 돈으로 아이템을 살 공간은 마련해 둬야 하므로.
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
	
	// (iWeightLeft / pItem->m_wWeight)가 최대 받을 수 있는 Gold갯수. 갖고있는 포상금과 비교한다. 
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
		// 포상금을 모두 받을 수 있다. 
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		// (iWeightLeft / pItem->m_wWeight)만 받는다.
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		
		// 남은 포상금 내역 계산.
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		
		*cp = (char)pItem->m_sItemSpecEffectValue3;
		cp++;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/

		if (iEraseReq == 1) delete pItem;
		
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
						
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}

		// 그 다음 남은 포상금을 알려준다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}
	else {
		// 받을 수 없는 경우는 아무런 처리를 하지 않는다. 

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return 0;

	return ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{
 register int i;
 short sPreType;
 DWORD dwTime, dwRegisterTime;

	// 만약 이미 위치에 객체가 존재하면 생성할 수 없다.
	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	// 다이나믹 오브젝트의 종류에 따라 놓을 수 있는 여부를 판별한다. 
	switch (sType) {	
	case DEF_DYNAMICOBJECT_FIRE:
	case DEF_DYNAMICOBJECT_FIRE3:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
			return NULL;
		// 비가 온다거나 하는 일이 있으면 지속 시간이 줄어든다.
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			// 결과가 0이라면 최소한의 값을 넣어준다.
			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;
	
	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
			return NULL;
		break;

	case DEF_DYNAMICOBJECT_ARESDENFLAG1:
	case DEF_DYNAMICOBJECT_ELVINEFLAG1:
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		// 광물이 있는 곳은 임시로 갈 수 없다. 광물이 사라지면 해제시켜줘야 한다. 
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;
	}
   	
	// 새로 등록한다. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] == NULL) {
		// 빈공간을 찾았다.
		dwTime = timeGetTime();
		
		if (dwLastTime != NULL) 
			dwLastTime += (iDice(1,4)*1000);

		m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
		// 리스트에 등록했으므로 이제 맵에 등록하고 인접한 클라이언트들에게 동적객체 발생을 알린다.
		m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

		return i;	// Dynamic Object handle을 반환한다.
	}

	return NULL;
}

void CGame::CheckDynamicObjectList()
{
 register int i;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
 short sType;

	// 날씨 효과에 따른 동적 객체의 지속시간 단축을 계산한다. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) ) {
		
			switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE:
			case DEF_DYNAMICOBJECT_FIRE3:
				// 불의 경우 비가 옴으로 인해 수명이 급격히 단축된다.
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1: 
				case 2:
				case 3:
					// (남은 시간/10)*비오는 상태 만큼 시간을 뺀다.
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
						                                    (m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}
		}
	}

	// 시간이 만료된 객체를 종료시킨다. 지속시간이 NULL이면 영원히 남아있는 동적 객체이다.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) && 
			 ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime) ) {
		
			// 지속시간이 경과한 동적 객체를 찾았다.
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );
			// 등록시간이 일치한다면 객체가 사라진다는 메시지를 보내줘야 한다.
			
			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				// 맵에서 삭제한다.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				// 물고기 오브젝트가 사라졌으므로 처리한다.
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // 시간이 지나서 물고기가 사라진다.
				break;
			}
	
			// 리스트를 삭제한다.
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_b100skill == TRUE) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue* 5;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		
		switch (sSkillIndex) {
		case 0:  // Mining
		case 5:  // Hand-Attack
		case 13: // Manufacturing
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)* 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield        	
		case 14: // Hammer 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:	 // Farming
		case 12: // Alchemy
		case 15: // 응급처치
		case 19: // Pretend-Corpse
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // Poison-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// 만약 무기와 관련있는 스킬이 올랐고 현재 그 무기를 사용 중이라면 현재 명중률에 1을 더한다. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// 카운트가 0이면 스킬이 정상적으로 올랐다는 의미. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// 양손무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 활류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// 무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 검이나 Mace류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill의 총합이 600을 넘으면 다른 스킬중 하나를 1 내린다. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// Skill이 올랐다는 것을 클라이언트에게 알려준다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}


/*void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
 int   iOldSSN, iSSNpoint, iWeaponIndex;

  if (m_b100skill == TRUE) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// 기술 수준이 0이라면 스킬은 오르지 않는다.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

    // v2.19 2002-11-17 공격 스킬은 빨리 오른다.
	switch (sSkillIndex) {
	case 4: // Magic
	case 5: // Hand-Attack
	case 6: // Archery
	case 7: // Short-Sword
	case 8: // Long-Sword
	case 9: // Fencing
	case 10: // Axe-Attack
	case 14: // Hammer
	case 21: // Staff-Attack
		iValue *= 2 ;
		break;
	}

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
	
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) && 
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {
		
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		switch (sSkillIndex) {
		case 0: // Mining
		case 5: // Hand-Attack
		case 13: // Manufacturing
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 14: // v2.16 성후니 수정 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:		//v2.19 2002-12-16 농사 스킬 관련 INT로 제한..
		case 12:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // 독성 저항 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// 제한치보다 커졌다. 무효이므로 이전상태로 되돌린다.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// 만약 무기와 관련있는 스킬이 올랐고 현재 그 무기를 사용 중이라면 현재 명중률에 1을 더한다. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// 카운트가 0이면 스킬이 정상적으로 올랐다는 의미. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// 양손무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 활류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// 무기가 장착되어 있었다. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// 검이나 Mace류의 사용에 의한 스킬의 상승이었다. 명중률을 1 올린다. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
			
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill의 총합이 700을 넘으면 다른 스킬중 하나를 1 내린다. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
		
			// Skill이 올랐다는 것을 클라이언트에게 알려준다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}
*/

void CGame::MobGenerator()
{
 register int i, j, iNamingValue, iResult, iTotalMob;
 char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
 char cSA;
 int  pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iFirmSAType;
 BOOL bMaster, bFirmBerserk, bIsSpecialEvent;
 short sNpcType = 0 ;

 
	if (m_bOnExitProcess == TRUE) return;
	
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if (m_pMapList[i] != NULL) { // closed
			if ((m_pMapList[i]->m_bIsHeldenianMap == TRUE) && ((m_bIsHeldenianMode == TRUE)||((m_bHeldSafe == TRUE)&&(m_bIsHeldenianMode == FALSE)))) break;
		}
		iResultNum = 0;

#ifdef DEF_CHECKUSERNPCNUM
		// v1.432 월드 서버의 총 사용자 수에 비례하여 최대 오브젝트 수를 결정한다. 1000명 이상이면 100%  최소 50%
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE)) {
			// 사용자 수에 비례하여 랜덤 몹 갯수 보정.
			if (m_iTotalGameServerClients >= 1000) {
				iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			}
			else {
				dV2 = (double)m_iTotalGameServerClients;
				dV3 = (m_pMapList[i]->m_iMaximumObject - 30);

				dV1 = (dV2 / 1000.0f)*dV3;
				iResultNum = (int)dV1;
			}

			// v1.432 숫자 보정
			iMin = (m_pMapList[i]->m_iMaximumObject - 30) - ((m_pMapList[i]->m_iMaximumObject - 30)/3);
			if (iResultNum > (m_pMapList[i]->m_iMaximumObject - 30)) iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			if (iResultNum < iMin) iResultNum = iMin;
		}
#endif		

		if (m_pMapList[i] != NULL) {
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}
				
		if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) {
			// i번째 맵에 몹을 생성할 조건이 만족되었다.
			
			// Crusade : 전면전 모드일때 미들랜드 몹 생산 중단.
			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;
			
			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				// Master Mob을 생성한다.
				ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;
			
				ZeroMemory(cNpcName, sizeof(cNpcName));
			
				// 고정 특수 능력 플래그 
				iFirmSAType  = NULL;
				bFirmBerserk = FALSE;
				iResult = iDice(1,100);
				// 몹 제네레이터의 레벨 
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {
				case 1:
					if ((iResult >= 1) && (iResult < 20)) {
						iResult = 1;  // 슬라임 
					}
					else if ((iResult >= 20) && (iResult < 40)) {
						iResult = 2;  // 개미 
					}
					else if ((iResult >= 40) && (iResult < 85)) {
						iResult = 24; // 토끼 
					}
					else if ((iResult >= 85) && (iResult < 95)) {
						iResult = 25; // 고양이 
					}				
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 3;  // 오크 
					}

					iMapLevel = 1;
					break;

				case 2:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 10;
					iMapLevel = 1;
					break;

				case 3:     // v1.4334 몹제너레이터 변경 // MiddleLand
					if ((iResult >= 1) && (iResult < 20)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 20) && (iResult < 25)) {
						iResult = 30;  //v2.19 2002-12-9 루돌프 추가 관련
					}
					else if ((iResult >= 25) && (iResult < 50)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 5; break;
						case 2:	iResult = 6; break;
						case 3: iResult = 7; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 75)) {
						// 2002-09-12 #1 Ettin 추가 고랩 사냥터에
						switch ( iDice(1,7) ) {	
						case 1: 
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						case 4:	iResult = 12; break;
						case 5: iResult = 18; break;
						case 6: iResult = 26; break;
						case 7: iResult = 28; break;	// Ettin
						}
					}
					else if ((iResult >= 75) && (iResult <= 100)) {
						// 2002-09-12 #1 Mountain-Giant 추가
						switch ( iDice(1,5) ) {
						case 1:
						case 2:	iResult = 9;  break;
						case 3:	iResult = 13; break;
						case 4: iResult = 14; break;
						case 5: iResult = 27; break;	// Mountain-Giant
						}
					}
					iMapLevel = 4;
					break;

				case 4:
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 2; break;
						case 2: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 100)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 14; break;
						case 2:	iResult = 9; break;
						}
					}
					iMapLevel = 2;
					break;

				case 5: //dglv2
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 11; break;
						case 2: iResult = 14; break;
						case 3: iResult = 9; break;
						}
					}
					iMapLevel = 3;
					break;

				case 6: // huntzone 3,4
					if ((iResult >= 1) && (iResult < 60)) { //59/100 de posibilidad
						switch ( iDice(1,4) ) {
						case 1: iResult = 5; break; // Skeleton
						case 2:	iResult = 6; break; // Orc-Mage
						case 3: iResult = 7; break; // Scorpion
						case 4: iResult = 4; break; // Zombie
						}
					}
					else if ((iResult >= 60) && (iResult < 90)) { //29/100 de posibilidad
						switch ( iDice(1,5) ) {
						case 1:
						case 2: iResult = 8;  break; // Stone-Golem
						case 3:	iResult = 11; break; // Clay-Golem
						case 4:	iResult = 12; break; // Troll
						case 5: iResult = 44; break; // Tentocle
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) { // 10/100 de posibilidad
						// 2002-09-12 #1 Ettin 추가 고랩 사냥터에
						// 2002-09-12 #1 Mountain-Giant, Cannibal-Plant 추가
						switch ( iDice(1,8) ) {
						case 1: iResult = 26; break; // Giant-Frog
						case 2:	iResult = 9;  break; // Cyclops
						case 3:	iResult = 13; break; // Orge
						case 4: iResult = 14; break; // Hellbound
						case 5: iResult = 18; break; // WereWolf
						case 6: iResult = 28; break; // Ettin
						case 7: iResult = 27; break; // Mountain-Giant
						case 8: iResult = 29; break; // Cannibal-Plant
						}
					}
					iMapLevel = 4;
					break;

				case 7: // areuni, elvuni
					if ((iResult >= 1) && (iResult < 20)) { //19/100 de posibilidad
						switch ( iDice(1,4) ) {
						case 1:	iResult = 1;  break; // Slime
						case 2: iResult = 2;  break; // Giant-Ant
						case 3: iResult = 10; break; // Amphis
						case 4: iResult = 3;  break; // Orc
						}
					}
					else if ((iResult >= 20) && (iResult < 50)) { //29/100 de posibilidad
						iResult = 30;  //Rudolph
					}
					else if ((iResult >= 50) && (iResult < 85)) { //34/100 de posibilidad
						switch ( iDice(1,5) ) {
						case 1: // Orc-Mage
						case 2: // Orc-Mage
						case 3: iResult = 6;  break; // Orc-Mage
						case 4: iResult = 12; break; // Troll
						case 5: iResult = 40; break; // Giant-Plant
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) { //14/100 de posibilidad
						switch ( iDice(1,4) ) {
						case 1: iResult = 12; break; // Troll
						case 2: iResult = 29;  break; //Cannibal-Plant
						case 3: 
							if (iDice(1,100) >= 50) 
								 iResult = 17; // Unicorn
							else iResult = 12; // Troll
							break;
						// 2002-09-18 #1
						case 4: iResult = 29; break; // Cannibal-Plant
						}
					}
					iMapLevel = 4;
					break;

				case 8:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8;  break;
						case 2: iResult = 11; break;
						case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 90) && (iResult < 100)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 9;  break;
						case 2: iResult = 14; break;
						}
					}
					iMapLevel = 4;
					break;

				case 9: // dglv3
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4;  break; // Zombie
						case 2: iResult = 5;  break; // Skeleton
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 9;  break; // Cyclops
						case 3: iResult = 13; break; // Orge
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch ( iDice(1,6) ) {
						case 1:
						case 2:
						case 3: iResult = 9;  break; // Cyclops
						case 4:
						case 5: iResult = 14; break; // Hellbound
						case 6: iResult = 15; break; // Liche
						}
					}

					// Demon은 Berserk 상태가 되지 않는다.
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
					
					iMapLevel = 4;
					break;

				case 10: // dglv4
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4; break; // Zombie
						case 2: iResult = 5; break; // Skeleton
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						// 
						switch ( iDice(1,3) ) {
						case 1:
						case 2:	iResult = 13; break; // Orge
						case 3: iResult = 14; break; // Hellbound
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch (iDice(1,3)) {
						case 1:
						case 2: iResult = 14; break; // Hellbound
						case 3: iResult = 15; break; // Liche
						}
					}

					// Demon은 Berserk 상태가 되지 않는다.
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;

					iMapLevel = 5;
					break;

				case 11: // ???
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break; // Giant-Ant
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break; // Orc
						case 2: iResult = 4; break; // Zombie
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break; // Skeleton
						case 2: iResult = 7; break; // Scorpion
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1:
						case 2: iResult = 10;  break; // Clay-Golem
						case 3:	iResult = 11; break;	// Troll
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 11; break; // Troll
						case 2: iResult = 7; break; // Scorpion
						case 3: iResult = 8; break; // Stone-Golem
						}
					}
					iMapLevel = 4;
					break;

				case 12: // middled1n, promiseland
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( iDice(1,3) ) {
						case 1:	iResult = 1 ; break; // Slime
						case 2: iResult = 2 ; break; // Giant-Ant
						case 3: iResult = 10; break; // Amphis
						}
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break; // Skeleton
						case 2: iResult = 4; break; // Zombie
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8; break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						case 3: iResult = 26; break; // Giant-Frog
						}
					}
					iMapLevel = 4;
					break;

				case 13: // Toh1
					if ((iResult >= 1) && (iResult < 15)) {
						// 광 스켈레톤 : 마법 혹은  대미지 흡수 
						iResult = 4;	// Zombie
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 15) && (iResult < 40)) {
						// 광 헬하운드 : 물리 대미지 흡수 
						iResult = 14;	// Hellbound
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}

					else if ((iResult >= 40) && (iResult < 60)) {
						// 광 사이클롭스 : 물리 대미지 흡수 
						iResult = 9; // Cyclops
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 60) && (iResult < 75)) {
						// 광 오우거 : 마법 대미지 흡수 
						iResult = 13; // Orge
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						// 다크 엘프
						iResult = 23; // Dark-Elf
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						// 비홀더
						iResult = 22; // Beholder
					}
					iMapLevel = 4;
					break;

				case 14: // Toh2
					if ((iResult >= 1) && (iResult < 30)) {
						// 다크 엘프 
						iResult = 23;	// Dark-Elf
					}
					else if ((iResult >= 30) && (iResult < 50)) {
						// 비홀더
						iResult = 22;	// Beholder
					}
					else if ((iResult >= 50) && (iResult < 70)) {
						// 광 리치 : 마법 대미지 흡수 
						iResult = 15;	// Liche
						bFirmBerserk = TRUE;
						iFirmSAType  = 4 - (iDice(1,2)-1);
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						// 데몬
						iResult = 16;	// Demon
					}	
					else if ((iResult >= 90) && (iResult < 100)) {
						// 가고일
						iResult = 21;	// Gagoyle
					}
					iMapLevel = 4;
					break;

				case 15: // Toh3
					if ((iResult >= 1) && (iResult < 35)) {
						// 다크 엘프 
						iResult = 23;	// Dark-Elf
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 35) && (iResult < 50)) {
						// 비홀더
						iResult = 22;	// Beholder
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						// 광 데몬 
						iResult = 16;	// Demon
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 80) && (iResult < 100)) {
						// 가고일
						iResult = 21;	// Gagoyle
					}
					iMapLevel = 4;
					break;
					
				case 16: //Huntzone 1,2 초보 미들.  //v2.19 2002-12-9
					if ((iResult >= 1) && (iResult < 40)) {
						switch ( iDice(1,3) ) {
						case 1:	iResult = 1 ; break;	// Slime
						case 2: iResult = 2 ; break;	// Giant-Ant
						case 3: iResult = 10; break;	// Amphis
						}
					}
					else if ((iResult >= 40) && (iResult < 50)) {
						iResult = 30;	//v2.19 Rudolph
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;	// Skeleton
						case 2: iResult = 4; break;	// Zombie
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8; break;	// Stone-Golem
						case 2: iResult = 11; break;	// Clay-Golem
						case 3: iResult = 26; break;	// Giant-Frog
						}
					}
					iMapLevel = 1 ;
					break;
				case 17:	//v2.19 IceBound
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,4) ) {
						case 1:	iResult = 22 ; break;	// Beholder
						case 2: iResult = 8; break;	// Stone-Golem
						case 3: iResult = 24 ; break;	// Rabbit
						case 4: iResult = 5; break;	// Skeleton
						}
					}
					else if ((iResult >= 30) && (iResult < 40)) {
						iResult = 30;	//v2.19 Rudolph
					}
					else if ((iResult >= 40) && (iResult < 70)) {
						iResult = 32;	// DireBoar
						
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 31;	// Ice-Golem
						if (iDice(1,5) == 1) bFirmBerserk = TRUE;
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33;	// Frost
					}
					iMapLevel = 1 ;
					break;
					
				case 18: //v3.2 druncncity
					if ((iResult >= 1) && (iResult < 2)) {
						iResult = 46; // Hellclaw
					}
					else if ((iResult >= 2) && (iResult < 12)) {
						iResult = 36; // ClawTurtle
					}
					else if ((iResult >= 12) && (iResult < 50)) {
						iResult = 43; // Nizie
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 38; // Giant-Crayfish
					}
					else if ((iResult >= 80) && (iResult < 90)) {
						iResult = 47; // Stalker
					}			
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 26; // Giant-Frog
					}					
					iMapLevel = 4;
					break;
					
				case 19: //v3.2 maze
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 35; // Centaurus
					}
					else if ((iResult >= 15) && (iResult < 25)) {
						iResult = 42; // Minotaurs
					}
					else if ((iResult >= 25) && (iResult < 35)) {
						iResult = 21; // Gagoyle
					}
					else if ((iResult >= 35) && (iResult < 60)) {
						iResult = 44; // Tentocle
					}				
					else if ((iResult >= 60) && (iResult < 85)) {
						iResult = 23; // Dark-Elf
					}		
					else if ((iResult >= 85) && (iResult <= 100)) {
						iResult = 22; // Beholder
					}
					iMapLevel = 4;
					break;
				case 20: //v3.51 BtField			
                    if ((iResult >= 1) && (iResult < 20))
	                     iResult = 44; //Tentocle
                    if ((iResult >= 20) && (iResult < 40))
	                     iResult = 35; //Centaurus
                    if ((iResult >= 40) && (iResult < 60))
	                     iResult = 39; //Giant-Lizard
                    if ((iResult >= 60) && (iResult < 75))
	                     iResult = 28; //Ettin
                    if ((iResult >= 75) && (iResult < 80))
	                     iResult = 16;//Demon
                    if ((iResult >= 80) && (iResult < 85))
                       	 iResult = 21;//Gagoyle
                    if ((iResult >= 85) && (iResult < 93))
	                     iResult = 46;//Hellclaw
                    if ((iResult >= 93) && (iResult < 96))
	                     iResult = 47;//Tigerworm
                    if ((iResult >= 96) && (iResult < 100))
	                     iResult = 37;//FireWyvern
                   /* if ((iResult >= 99) && (iResult < 100))
	                     iResult = 48;//IceWyvern*/
                         break;

				}

				pX = NULL;
				pY = NULL;
				
				// Special Event. 여러 맵중 랜덤한 맵이 걸리도록 주사위를 굴려야만 한다.
				bIsSpecialEvent = FALSE;
				if ((m_bIsSpecialEventTime == TRUE) && (iDice(1,10) == 3)) bIsSpecialEvent = TRUE;

				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
					case 1:
						// 몹 이벤트. 현재 맵에서 가장 플레이어가 많은 곳에 뿌린다.
						if (m_pMapList[i]->m_iMaxPx != 0) {
							pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;

							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;

							if (m_bIsCrusadeMode == TRUE) {
								// 크루세이드 모드인 경우 적국에 용병을 소환 
								if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
									iResult = 20;
								else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
									iResult = 19;
							}
							
							wsprintf(G_cTxt, "(!) Mob-Event Map(%s) Loc(%d,%d)", m_pMapList[i]->m_cName, pX, pY);
							PutLogList(G_cTxt);
						}
						break;
					
					case 2:
						if (iDice(1,3) == 2) {
							if ((memcmp(m_pMapList[i]->m_cName, "aresden", 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "elvine", 6)    == 0)) {
								if (iDice(1,30) == 5) 
									 iResult = 16;
								else iResult = 5;
							}
							else iResult = 16;
						}
						else iResult = 17;
						
						m_bIsSpecialEventTime = FALSE;
						break;
					}
				}
				
				ZeroMemory(cNpcName, sizeof(cNpcName));
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");     sNpcType = 10 ;   iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant"); sNpcType = 16 ;   iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");       sNpcType = 14 ;   iProbSA = 15; iKindSA = 1; break;
				case 4:  strcpy(cNpcName, "Zombie");    sNpcType = 18 ;   iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");  sNpcType = 11 ;   iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");  sNpcType = 14 ;   iProbSA = 30; iKindSA = 7; break;
				case 7:  strcpy(cNpcName, "Scorpion");  sNpcType = 17 ;   iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem"); sNpcType = 12 ; iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");    sNpcType = 13 ;  iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");     sNpcType = 22 ;  iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem"); sNpcType = 23 ;  iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Troll");      sNpcType = 28 ;  iProbSA = 25; iKindSA = 3; break; 
				case 13: strcpy(cNpcName, "Orge");       sNpcType = 29 ;  iProbSA = 25; iKindSA = 1; break;
				case 14: strcpy(cNpcName, "Hellbound");  sNpcType = 27 ;  iProbSA = 25; iKindSA = 8; break;
				case 15: strcpy(cNpcName, "Liche");		 sNpcType = 30 ;  iProbSA = 30; iKindSA = 8; break;
				case 16: strcpy(cNpcName, "Demon");		 sNpcType = 31 ;  iProbSA = 20; iKindSA = 8; break;
				case 17: strcpy(cNpcName, "Unicorn");	 sNpcType = 32 ;  iProbSA = 35; iKindSA = 7; break;
				case 62: strcpy(cNpcName, "DarkUnicorn");sNpcType = 99;   iProbSA = 35; iKindSA = 7; break;
				case 18: strcpy(cNpcName, "WereWolf");	 sNpcType = 33 ;  iProbSA = 25; iKindSA = 1; break;
				case 19: strcpy(cNpcName, "YB-Aresden"); sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
				case 20: strcpy(cNpcName, "YB-Elvine");	 sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
				case 21: strcpy(cNpcName, "Gagoyle");	 sNpcType = 52 ;  iProbSA = 20; iKindSA = 8; break;
				case 22: strcpy(cNpcName, "Beholder");	 sNpcType = 53 ;  iProbSA = 20; iKindSA = 5; break;
				case 23: strcpy(cNpcName, "Dark-Elf");	 sNpcType = 54 ;  iProbSA = 20; iKindSA = 3; break;
				// v2.17
				case 24: strcpy(cNpcName, "Rabbit");	 sNpcType = 55 ;  iProbSA =  5; iKindSA = 1; break;
				case 25: strcpy(cNpcName, "Cat");		 sNpcType = 56 ;  iProbSA = 10; iKindSA = 2; break;
				case 26: strcpy(cNpcName, "Giant-Frog"); sNpcType = 57 ;  iProbSA = 10; iKindSA = 2; break;
				// 2002-09-12
				case 27: strcpy(cNpcName, "Mountain-Giant");  sNpcType = 58 ; 	iProbSA = 25; iKindSA = 1; break;
				case 28: strcpy(cNpcName, "Ettin");			  sNpcType = 59 ;	iProbSA = 20; iKindSA = 8; break;
				case 29: strcpy(cNpcName, "Cannibal-Plant");  sNpcType = 60 ; 	iProbSA = 20; iKindSA = 5; break;
				//v2.19 2002-12-9
				case 30: strcpy(cNpcName, "Rudolph");    sNpcType = 61 ; 	iProbSA = 20; iKindSA = 5; break;
				case 31: strcpy(cNpcName, "Ice-Golem");  sNpcType = 65 ;    iProbSA = 35; iKindSA = 8; break;
				case 32: strcpy(cNpcName, "DireBoar");  sNpcType = 62 ; 	iProbSA = 20; iKindSA = 5; break;
				case 33: strcpy(cNpcName, "Frost");		 sNpcType = 63 ;    iProbSA = 30; iKindSA = 8; break;
				//v2.95 10/05/06 00:24
				case 34: strcpy(cNpcName, "Spider");   sNpcType = 70;     iProbSA = 20; iKindSA = 1; break;
				case 35: strcpy(cNpcName, "Spectre"); sNpcType = 71;    iProbSA = 20; iKindSA = 1; break;
				case 36: strcpy(cNpcName, "Yeti"); sNpcType = 72;  iProbSA = 20; iKindSA = 1; break;
				case 37: strcpy(cNpcName, "Fire-Wyvern"); sNpcType = 73;  iProbSA = 20; iKindSA = 1; break;
				case 38: strcpy(cNpcName, "Giant-Crayfish"); sNpcType = 74; iProbSA = 20; iKindSA = 1; break;
				case 39: strcpy(cNpcName, "Giant-Lizard"); sNpcType = 75; iProbSA = 20; iKindSA = 1; break;
				case 40: strcpy(cNpcName, "Giant-Plant"); sNpcType = 76; iProbSA = 20; iKindSA = 1; break;
				case 41: strcpy(cNpcName, "Doomdemon"); sNpcType = 77; iProbSA = 20; iKindSA = 1; break;
				case 42: strcpy(cNpcName, "PitLord"); sNpcType = 78; iProbSA = 20; iKindSA = 1; break;
				case 43: strcpy(cNpcName, "Nizie"); sNpcType = 79; iProbSA = 20; iKindSA = 1; break;
				case 44: strcpy(cNpcName, "Tentocle"); sNpcType = 80; iProbSA = 20; iKindSA = 1; break;
				case 45: strcpy(cNpcName, "Abaddon"); sNpcType = 81; iProbSA = 20; iKindSA = 1; break;
				case 46: strcpy(cNpcName, "Hellclaw"); sNpcType = 49; iProbSA = 20; iKindSA = 1; break;
				case 47: strcpy(cNpcName, "Tigerworm"); sNpcType = 52; iProbSA = 20; iKindSA = 1; break;
                case 48: strcpy(cNpcName, "Wyvern"); sNpcType = 66;  iProbSA = 20; iKindSA = 1; break;
				default: strcpy(cNpcName, "Orc");		      sNpcType = 14 ; 	iProbSA = 15; iKindSA = 1; break;
				}

				cSA = 0;
				if (iFirmSAType == NULL) {
					if (iDice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
				}
				else cSA = (char)iFirmSAType;
												
				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				}
				else {
					
				}
			}	
			
			// 처음 생성된 몹의 종류에 따른 생성 갯수를 계산한다.
			switch (iResult) {
			case 1:	 iTotalMob = iDice(1,5)-1; break;  // Slime 
			case 2:	 iTotalMob = iDice(1,5)-1; break; // Giant-Ant
			case 3:	 iTotalMob = iDice(1,5)-1; break; // Orc
			case 4:	 iTotalMob = iDice(1,3)-1; break; // Zombie
			case 5:	 iTotalMob = iDice(1,3)-1; break;
			case 6:  iTotalMob = iDice(1,3)-1; break; // Skeleton
			case 7:  iTotalMob = iDice(1,3)-1; break; // Scorpion
			case 8:  iTotalMob = iDice(1,2)-1; break; // Stone-Golem
			case 9:  iTotalMob = iDice(1,2)-1; break;
			case 10: iTotalMob = iDice(1,5)-1; break; // Amphis
			case 11: iTotalMob = iDice(1,3)-1; break; // Clay-Golem
			case 12: iTotalMob = iDice(1,5)-1; break; // Troll
			case 13: iTotalMob = iDice(1,3)-1; break; // Orge
			case 14: iTotalMob = iDice(1,3)-1; break; // Rabbit
			case 15: iTotalMob = iDice(1,3)-1; break; // Cat
			case 16: iTotalMob = iDice(1,2)-1; break; // Giant-Frog
			case 17: iTotalMob = iDice(1,2)-1; break; // Mountain-Giant
			case 18: iTotalMob = iDice(1,5)-1; break; // Ettin
			case 21: iTotalMob = iDice(1,2)-1; break; // Cannibal-Plant
			case 22: iTotalMob = iDice(1,2)-1; break;
			case 23: iTotalMob = iDice(1,5)-1; break;
			// v2.17
			case 24: iTotalMob = iDice(1,2)-1; break;
			case 25: iTotalMob = iDice(1,2)-1; break;
			case 26: iTotalMob = iDice(1,4)-1; break;
			// 2002-09-12
			case 27: iTotalMob = iDice(1,2)-1; break;
			case 28: iTotalMob = iDice(1,3)-1; break;
			case 29: iTotalMob = iDice(1,3)-1; break;
			//v2.19 2002-12-11
			case 30: iTotalMob = iDice(1,3)-1; break;
			case 31: iTotalMob = iDice(1,5)-1; break;
			case 32: iTotalMob = iDice(1,3)-1; break;
			case 33: iTotalMob = iDice(1,3)-1; break;
			// v2.95 10/05/06 00:26
			case 34: iTotalMob = 1; break;
			case 35: iTotalMob = 1; break;
			case 36: iTotalMob = iDice(1,3)-1; break;
			case 38: iTotalMob = 1; break;
			case 39: iTotalMob = 1; break;
			case 96:
			case 98:
			case 94: iTotalMob = 1; break;
			case 44: iTotalMob = 1; break;
			default: iTotalMob = 0; break;
			}
			if (bMaster == FALSE) iTotalMob = 0;

			if (iTotalMob >= 2) {
				switch (iResult) {
				case 1:   // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
				case 24: // Rabbit
				case 25: // Cat
				case 26: // Giant-Frog
				case 27: // Mountain-Giant
				case 28: // Ettin
				case 29: // Cannibal-Plant
				//v2.19 2002-12-11 루돌프 추가 관련 
				case 30:
				case 32: // DireBoar
				case 33: // Frost
					if (iDice(1,5) != 1) iTotalMob = 0;  // 25%
					break;

				case 9:  // Cyclops
				case 6:  // Orc-Mage
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 31: // Ice-Golem
				case 34: // Barlog
				case 35: // Centaurus
				case 36: // Claw-Turtle
				case 37: // Fire-Wyvern
				case 38: // Giant-Crayfish
				case 39: // Giant-Lizard
				case 40: // Giant-Plant
				case 41: // MasterMage-Orc
				case 42: // Minotaurs
				case 43: // Nizie
				case 44: // Tentocle
					if (iDice(1,5) == 1) iTotalMob = 0;  // 75%
					break;

				default:
					break;
				}
			}
			
			// Special Event
			// 2002-7-4
			if (bIsSpecialEvent == TRUE) {
				switch (m_cSpecialEventType) {
				case 1:
					// 몹 이벤트
					if ((iResult != 15) && (iResult != 16) && (iResult != 21))
						iTotalMob = m_pMapList[i]->sMobEventAmount;

/*
						for (j = 1; j < DEF_MAXCLIENTS; j++) 
							if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
								SendNotifyMsg(NULL, j, DEF_NOTIFY_MONSTEREVENT_POSITION, pX, pY, sNpcType, NULL);	

					break;

				*/
				case 2:
					// v2.19 2002-11-12 LocationName m_cName
					// Location Name

					if ( (memcmp(m_pMapList[i]->m_cName, "aresden", 7) == 0) ||
						 (memcmp(m_pMapList[i]->m_cName, "elvine",  6) == 0) ||
						 (memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
						 (memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ) {
						iTotalMob = 0;
					}
					break;
				}
				m_bIsSpecialEventTime = FALSE;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// Slave Mob
					ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = '_';
					cName_Slave[1] = i + 65;
			
					cSA = 0;
					if (iFirmSAType == NULL) {
						if (iDice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
					}
					else cSA = (char)iFirmSAType;

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
						// NameValue
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						// Slave
						bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		}
		// random mob generator	^
 
		// spot mob generator 
		if ( (m_pMapList[i] != NULL) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject) ) {
			for (j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++)
			if ( (iDice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
				 (m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					
					ZeroMemory(cNpcName, sizeof(cNpcName));
					switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
					case 10:  strcpy(cNpcName,"Slime");        iProbSA = 5;  iKindSA = 1; break;
					case 16:  strcpy(cNpcName,"Giant-Ant");    iProbSA = 10; iKindSA = 2; break;
					case 14:  strcpy(cNpcName,"Orc");          iProbSA = 15; iKindSA = 1; break;
					case 18:  strcpy(cNpcName,"Zombie");       iProbSA = 15; iKindSA = 3; break;
					case 11:  strcpy(cNpcName,"Skeleton");     iProbSA = 35; iKindSA = 8; break;
					case 6:   strcpy(cNpcName,"Orc-Mage");     iProbSA = 30; iKindSA = 7; break;
					case 17:  strcpy(cNpcName,"Scorpion");     iProbSA = 15; iKindSA = 3; break;
					case 12:  strcpy(cNpcName,"Stone-Golem");  iProbSA = 25; iKindSA = 5; break;
					case 13:  strcpy(cNpcName,"Cyclops");      iProbSA = 35; iKindSA = 8; break;
					case 22:  strcpy(cNpcName,"Amphis");       iProbSA = 20; iKindSA = 3; break;
					case 23:  strcpy(cNpcName,"Clay-Golem");   iProbSA = 20; iKindSA = 5; break;
					case 24:  strcpy(cNpcName,"Guard-Aresden");iProbSA = 20; iKindSA = 1; break;
					case 25:  strcpy(cNpcName,"Guard-Elvine"); iProbSA = 20; iKindSA = 1; break;
					case 26:  strcpy(cNpcName,"Guard-Neutral");iProbSA = 20; iKindSA = 1; break;
					case 27:  strcpy(cNpcName,"Hellbound");    iProbSA = 20; iKindSA = 1; break;
					case 29:  strcpy(cNpcName,"Orge");         iProbSA = 20; iKindSA = 1; break;
					case 30:  strcpy(cNpcName,"Liche");        iProbSA = 30; iKindSA = 8; break;
					case 31:  strcpy(cNpcName,"Demon");        iProbSA = 20; iKindSA = 8; break;
					case 32:  strcpy(cNpcName,"Unicorn");      iProbSA = 35; iKindSA = 7; break;
					case 99:  strcpy(cNpcName,"DarkUnicorn");  iProbSA = 35; iKindSA = 7;  break;
					case 33:  strcpy(cNpcName,"WereWolf");     iProbSA = 25; iKindSA = 1; break;
					case 34:  strcpy(cNpcName,"Dummy");        iProbSA = 5;  iKindSA = 1; break;
					case 35:  strcpy(cNpcName,"Attack-Dummy"); iProbSA = 5;  iKindSA = 1; break;
					case 48:  strcpy(cNpcName,"Stalker");      iProbSA = 20; iKindSA = 3; break;
					case 49:  
						if (iDice(1, 40*60*60) == 13) {
							strcpy(cNpcName,"Hellclaw");
							iProbSA = 20;
							iKindSA = 8;
						}
						break;
					
					case 50:  
						if (iDice(1, 2*60*30) == 135) {
							strcpy(cNpcName,"Tigerworm");
							iProbSA = 20;
							iKindSA = 8;
						}
						else {
							strcpy(cNpcName, "Stalker");
							iProbSA = 15;
							iKindSA = 1;
						}
						break;

					case 51:  strcpy(cNpcName,"Hellclaw");      iProbSA = 20; iKindSA = 8; break;
					case 52:  strcpy(cNpcName,"Tigerworm");     iProbSA = 20; iKindSA = 8; break;
					case 53:  strcpy(cNpcName,"Dark-Elf");      iProbSA = 20; iKindSA = 8; break;
					case 54:  strcpy(cNpcName,"Beholder");      iProbSA = 20; iKindSA = 8; break;
					case 55:  strcpy(cNpcName,"Gagoyle");       iProbSA = 20; iKindSA = 8; break;
					case 56:
						if (iDice(1, 2*60*30) == 13) {
							strcpy(cNpcName,"Hellclaw");
							iProbSA = 20;
							iKindSA = 8;
						}
						break;

					case 57:   strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2; break;
					case 58:   strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1; break;
					case 59:   strcpy(cNpcName,"Ettin");			iProbSA = 20; iKindSA = 8; break;
					case 60:   strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5; break;
					case 61:   strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1; break;
					case 62:   strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1; break;
					case 63:   strcpy(cNpcName,"Frost");			iProbSA = 20; iKindSA = 8; break;
					case 65:   strcpy(cNpcName,"Ice-Golem");		iProbSA = 20; iKindSA = 8; break;
					case 66:   strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 1; break;
					case 5:    strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1; break;
					case 67:   strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1; break;
					case 68:   strcpy(cNpcName,"Perry");			iProbSA = 20; iKindSA = 1; break;
					case 69:   strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1; break;
					case 70:   strcpy(cNpcName,"Spider");     iProbSA = 20; iKindSA = 1; break;
					case 71:   strcpy(cNpcName,"Spectre");  iProbSA = 20; iKindSA = 1; break;
					case 72:   strcpy(cNpcName,"Yeti"); iProbSA = 20; iKindSA = 1; break;
					case 73:   strcpy(cNpcName,"Fire-Wyvern"); iProbSA = 20; iKindSA = 1; break;
					case 74:   strcpy(cNpcName,"Giant-Crayfish"); iProbSA = 20; iKindSA = 1; break;
					case 75:   strcpy(cNpcName,"Giant-Lizard"); iProbSA = 20; iKindSA = 1; break;
					case 76:   strcpy(cNpcName,"Giant-Plant"); iProbSA = 20; iKindSA = 1; break;
					case 77:   strcpy(cNpcName,"Doomdemon"); iProbSA = 20; iKindSA = 1; break;
					case 78:   strcpy(cNpcName,"PitLord"); iProbSA = 20; iKindSA = 1; break;
					case 79:   strcpy(cNpcName,"Nizie"); iProbSA = 20; iKindSA = 1; break;
					case 80:   strcpy(cNpcName,"Tentocle"); iProbSA = 20; iKindSA = 1; break;
					case 81:   strcpy(cNpcName,"Abaddon"); iProbSA = 20; iKindSA = 1; break;
					default:
						strcpy(cNpcName, "Orc");
						iProbSA = 15; 
						iKindSA = 1; 
						break;
					}

					// Spot Mob Generator도 FirmBersek
					bFirmBerserk = FALSE;
					if ((m_pMapList[i]->m_cRandomMobGeneratorLevel >= 9) &&(iMapLevel >= 4) && (iDice(1,3) == 1)  ) bFirmBerserk = TRUE;
					
					ZeroMemory(cName_Master, sizeof(cName_Master));
					wsprintf(cName_Master, "XX%d", iNamingValue);
					cName_Master[0] = '_';
					cName_Master[1] = i + 65;
			
					cSA = 0;
					if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1,100) <= iProbSA)) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
					case 1:
						// RANDOMAREA
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
							m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
						}
						else {
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
						}
						break;

					case 2:
						// RANDOMWAYPOINT
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
							m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
						}
						else {
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
					  	}
						break;
					}
				}
			}
		}
		// spot mob generator ^
 	}
}


void CGame::CalcNextWayPointDestination(int iNpcH)
{
 short sRange, sX, sY;
 register int i, j, iMapIndex;
 BOOL bFlag;

	switch (m_pNpcList[iNpcH]->m_cMoveType) {
	case DEF_MOVETYPE_GUARD:
		// 지정된 위치를 벗어나지 않으며 추격이 끝난 후에 돌아온다.
		break;
	
	case DEF_MOVETYPE_SEQWAYPOINT: 

		m_pNpcList[iNpcH]->m_cCurWaypoint++;
		if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
			m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMWAYPOINT:
	
		m_pNpcList[iNpcH]->m_cCurWaypoint = ((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMAREA:
				
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
		m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
		m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
		break;

	case DEF_MOVETYPE_RANDOM:
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		for ( i = 0; i <= 30; i++) {
			sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
			sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

			bFlag = TRUE;
			for (j = 0; j < DEF_MAXMGAR; j++)
			if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
				if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
					(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
					(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
					(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {

					bFlag = FALSE;
				}
			}
			if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
		}
		// Fail! 
		m_pNpcList[iNpcH]->m_tmp_iError  = 0; 
		return;

CNW_GET_VALIDLOC_SUCCESS:;
		m_pNpcList[iNpcH]->m_dX = sX;
		m_pNpcList[iNpcH]->m_dY = sY;
		break;
	}

	m_pNpcList[iNpcH]->m_tmp_iError  = 0;
}

  
void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
 char cAttackerSide, cDamageMoveDir;
  DWORD dwTime;
 register double dTmp1, dTmp2, dTmp3;
 short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY, sItemIndex;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && 
        (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1)) return;

	if (cTargetType == DEF_OWNERTYPE_PLAYER){
		if (m_pClientList[sTargetH]->m_iAdminUserLevel >= 1) return;
		if ((memcmp(m_pClientList[sTargetH]->m_cCharName, "Premios", 10) == 0) || (memcmp(m_pClientList[sTargetH]->m_cCharName, "Apuestas", 10) == 0)) return;
	}

	dwTime = timeGetTime();
	
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;
//14107	1.572635	69.64.37.220	190.210.92.220	IPv4	1514	Fragmented IP protocol (proto=UDP 0x11, off=2960, ID=6a80)
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		// v2.23 18/02/06 17:42 
		if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0&&m_pClientList[sAttackerH]->m_iAdminUserLevel < 3) return;
		if ((memcmp(m_pClientList[sAttackerH]->m_cCharName, "Premios", 10) == 0) || (memcmp(m_pClientList[sAttackerH]->m_cCharName, "Apuestas", 10) == 0)) return;

		if (m_pClientList[sAttackerH]->m_cHeroBonus == 2) iDamage += 3;
		
		
		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
					iDamage += (iDamage*0.8);
				}
			//centeheroWand dmg add
			else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 2090 ) {
					iDamage += (iDamage*2);
				}
			// v2.95 02/06/06 14:16 KlonessWand(MS.10) y (MS.20) 
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
					iDamage += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] != NULL) {
						if (m_pClientList[sTargetH]->m_iRating < 0) {
							iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
							if (iRepDamage > 10) iRepDamage = 10;
							iDamage += iRepDamage;
						}
					}
				}
			}
		}
		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iDamage += iRepDamage;
						}
					}
				}
			}

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 다른 Player를 공격하지 않는다. 전면전시 제외)
		if ( m_bIsCrusadeMode == FALSE &&
			(m_pClientList[sAttackerH]->m_bIsHunter == TRUE ) &&
			 (cTargetType == DEF_OWNERTYPE_PLAYER) ) return ;

		dTmp1 = (double)iDamage;
		if ((m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag);
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		// v1.432 2001 4 7 13 7
		

		if (iDamage <= 0) iDamage = 0;
        iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		// v1.44 사투장이면 대미지 1.33배 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;
		
		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		if  (memcmp(m_pClientList[sAttackerH]->m_cMapName, "deathmach", 9) == 0)
		// MORLA 2.8 - Damage en deathmach
			iDamage += iDamage*1.2;

		// Crusade : 전면전 모드일때 군인 대인 공격력 1.33배 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
			// v2.15 저랩의 경우는 데미지가 증가한다. 1.7 배 
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} // v2.15 저랩의 경우는 데미지가 증가한다. 1.5 배 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;

			} else iDamage += iDamage/2;
		}
		 
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;

		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 공격 대상이 존재하지 않으면 리턴 
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		// 이미 죽어 있다면 처리 안함.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 공격 당하지 않는다. 전면전시 제외)
		if ((m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && 
			(m_pClientList[sTargetH]->m_bIsHunter == TRUE ) && 
			(cAttackerType == DEF_OWNERTYPE_PLAYER) ) return ;

#ifdef DEF_ALLPLAYERPROTECT
		// v2.19 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 현재 초보 미들은 마을과 같은 룰이 적용되며 다른편도 공격이 가능하지 않는다.
		if(cAttackerType == DEF_OWNERTYPE_PLAYER)
		{
			if( m_pClientList[sTargetH]->m_iIsOnTown == DEF_NEVERNONPK )
			{
				if (m_pClientList[sTargetH]->m_iPKCount == 0)  return ;
			}
			else
			{
				if ((m_bIsCrusadeMode == FALSE) &&			
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide ) &&
					(m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
			}
		}

#endif  
#ifdef DEF_SAMESIDETOWNPROTECT
		// v2.172 같은편끼리는 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 중립도 공격 않되게 
		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
#endif 		
#ifdef DEF_BEGINNERTOWNPROTECT
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return;
#endif
		// 랙으로 인해 보호를 받아야 한다면 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// 공격자가 위치한 맵이 공격 불가능 맵이라면 
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		// v1.41 공격자가 중립이면 대인 공격이 불가능하다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		
		// 01-12-17 같은 파티원이면 공격 불가 
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

		// 만약 공격자가 플레이어이고 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			// 공격자가 안전 공격 모드라면 공격의 의미가 없다. 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// 아무 효과 없음. 마나 소비량이 줄었으므로 
				}
				else {
					// 같은 편이지만 만약 사투장 내에서 편이 같다면 공격 처리를 해야한다.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// 사투장 내에서 다른 길드다. 공격이 가능하다. 
						}
						else return;
					}
					else return;
				}
			}

			// 마법 보호 혹은 안전 영역이라면 공격 성공 못함 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		// 스킬의 사용상태를 모두 무효화 한다.
		ClearSkillUsingStatus(sTargetH);
		
		// v1.432 속성별 대미지 감소 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// 마법 대미지 절감 효과를 가진 아이템이다.
			
			// 아이템의 종류에 따라 대미지를 줄인다. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // 에머랄드 반지 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: // 루비 반지 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				// 마법 데미지 절감 아이템이 부서진다. 
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				// 마법 데미지 절감 아이템의 수명만 줄인다. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42 추가된 고정 마법 대미지 절감
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT에 따른 대미지 감소 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// 행운효과로 죽음을 모면한다.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
		// 만약 마법 보호중이라면 대미지는 1/2 
			if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
				iDamage = iDamage / 2;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_sType != 65)
			if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
				iDamage = iDamage / 2;
			break;
		}

		// v1.432 특수 능력 중 모든 대미지를 막는 효과가 활성화 된 경우 대미지를 입지 않는다.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		{	if ( (m_pClientList[sAttackerH]->m_dwShowDMG == TRUE) && (m_pClientList[sAttackerH] != NULL) )
			{	char cDamageMod[30];
				ZeroMemory(cDamageMod, sizeof(cDamageMod));
				wsprintf(cDamageMod ,"You did %d damage", iDamage);
				ShowClientMsg(sAttackerH, cDamageMod);
		}	}
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				// v2.04 타격을 받았는데 마나 변환 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					// 최대 마나치 
					iTemp = (2*(m_pClientList[sTargetH]->m_iMag+m_pClientList[sTargetH]->m_iAngelicMag)) + (2*m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iInt+m_pClientList[sTargetH]->m_iAngelicInt)/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04 타격을 받았는데 필살 충전의 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					// 확률 계산에 따라서 필살기가 충전된다.
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 5);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}
				
				// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				// 충격을 받았다면 충격동작 전송 
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				// v1.4 죽은척하고 있는 경우는 Owner 위치를 옮긴다. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person 되어 있었던 상태라면 풀린다. 마법공격 패럴라이즈 된 것도 풀린다.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 6:
			return;
		break;

		case 4:
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				// 다시 한번 방향을 랜덤하게 구한다.
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			// 예전 위치에서 지운다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			// 새 위치에 표시한다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			// 이벤트 알린다.
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				
			// 한번 더 간다.
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				// 다시 한번 방향을 랜덤하게 구한다.
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			// 예전 위치에서 지운다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			// 새 위치에 표시한다. 
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			// 이벤트 알린다.
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
				// 경험치 상승은 없다.
				DeleteNpc(sTargetH);
			}
			return;
		}

		// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 아군이나 중립의 공격에 대미지를 입지 않는다.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			case 39:
			case 87:
			case 89:
			case 92:
				if (m_bIsRushNetMode == TRUE)
					if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}
		
		// 몬스터가 마법 대미지 흡수률이 있다면(AbsDamage가 0보다 크다) 원래 마법 대미지를 감소시킨다.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		// 만약 마법 보호중이라면 대미지는 1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		{	if ((m_pClientList[sAttackerH]->m_dwShowDMG == TRUE) && (m_pClientList[sAttackerH] != NULL) )
			{	char cDamageMod[30];
				ZeroMemory(cDamageMod, sizeof(cDamageMod));
				wsprintf(cDamageMod ,"You did %d damage", iDamage);
				ShowClientMsg(sAttackerH, cDamageMod);
		}	}

  if (m_pNpcList[sTargetH]->m_iHP <= 0) {
 
			// NPC가 사망했다.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			// 공격당했지만 살아있다. 반격한다.
			// 편이 같으면 반격하지 않는다.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				// v2.15 경비는 같은 편도 반격한다.
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			// 충격을 받았다면 충격동작 전송
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			//
						
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				// 동족이고 편이 같으면 반격하지 않는다.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit가 1이면 반격을 하지 않는다. 오직 움직일수만 있으니.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;

				// Damage를 입은 충격으로 인한 지연효과.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				// 여기서 표효 동작같은것을 위한 메시지 발송.
				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold 되어 있었던 상태라면 풀린다. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				// Crusade
				int iExp;

				// NPC에 대한 공격이 성공했으므로 공격자가 플레이어라면 입힌 대미지 만큼의 경험치를 공격자에게 준다. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStock을 올린다. 단 소환몹인 경우 경험치를 올리지 않는다.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;


						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}
											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp/2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}

						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp/2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr, BOOL bFly)
{
 int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
 DWORD dwTime;
 char cAttackerSide, cDamageMoveDir;
 register double dTmp1, dTmp2, dTmp3;
 int iPartyID, iMoveDamage, dX, dY;
 short sTgtX, sTgtY, sItemIndex;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	if (cTargetType == DEF_OWNERTYPE_PLAYER){
		if (m_pClientList[sTargetH]->m_iAdminUserLevel >= 1) return;
		if ((memcmp(m_pClientList[sTargetH]->m_cCharName, "Premios", 10) == 0) || (memcmp(m_pClientList[sTargetH]->m_cCharName, "Apuestas", 10) == 0)) return;
	}

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	
	// 해당 타켓에게 대미지를 먹인다. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	// 공격자가 플레이어라면 Mag에 따른 보너스 대미지를 가산 
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		// v2.23 18/02/06 17:42 
		if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0&&m_pClientList[sAttackerH]->m_iAdminUserLevel < 3) return;
		if ((memcmp(m_pClientList[sAttackerH]->m_cCharName, "Premios", 10) == 0) || (memcmp(m_pClientList[sAttackerH]->m_cCharName, "Apuestas", 10) == 0)) return;

		if (m_pClientList[sAttackerH]->m_cHeroBonus == 2) iDamage += 3;
		
		// v2.95 02/06/06 14:16 KlonessWand(MS.10) y (MS.20) 
		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
					iDamage += (iDamage*0.8);
				}
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
					iDamage += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] != NULL) {
						if (m_pClientList[sTargetH]->m_iRating < 0) {
							iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
							if (iRepDamage > 10) iRepDamage = 10;
							iDamage += iRepDamage;
						}
					}
				}
			}
		}
		
		// v2.95 01/06/06 20:35 NecklaceOfKloness 
		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] != NULL) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iDamage += iRepDamage;
					}
				}
			}
		}
		if ( (m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sAttackerH]->m_bIsHunter == TRUE) &&
			 cTargetType == DEF_OWNERTYPE_PLAYER ) return ;

		dTmp1 = (double)iDamage;
		if ((m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag+m_pClientList[sAttackerH]->m_iAngelicMag);
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		// v1.44 사투장이면 대미지 1.33배 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;
		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}
		// Crusade : 전면전 모드일때 대인 공격력 1.33배 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
 			// v2.15 저랩의 경우는 데미지가 증가한다. 1.7 배 
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} // v2.15 저랩의 경우는 데미지가 증가한다. 1.5 배 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;
			} else iDamage += iDamage/3;
		}
		
		// v2.23 18/02/06 17:43 
		if (m_pClientList[sAttackerH]->m_cHeroBonus == 2) {
			iDamage += 3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// 공격 대상이 존재하지 않으면 리턴 
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		// 이미 죽어 있다면 처리 안함.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		// 랙으로 인해 보호를 받아야 한다면 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// 공격자가 위치한 맵이 공격 불가능 맵이라면 
		// v2.03 서버 다운되어서 고침 
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		// v1.41 공격자가 중립이면 대인 공격이 불가능하다. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		// 2002-11-14 사냥꾼 모드 추가 (사냥꾼은 공격 당하지 않는다. 전면전시 제외)
		if ((m_bIsCrusadeMode == FALSE) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && 
			(m_pClientList[sTargetH]->m_bIsHunter == TRUE ) && 
			(cAttackerType == DEF_OWNERTYPE_PLAYER) ) return ;

#ifdef DEF_ALLPLAYERPROTECT
		// v2.19 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 현재 초보 미들은 마을과 같은 룰이 적용되며 다른편도 공격이 가능하지 않는다.
		if(cAttackerType == DEF_OWNERTYPE_PLAYER)
		{
			if( m_pClientList[sTargetH]->m_iIsOnTown == DEF_NEVERNONPK )
			{
				if (m_pClientList[sTargetH]->m_iPKCount == 0)  return ;
			}
			else
			{
				if ((m_bIsCrusadeMode == FALSE) &&			
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide ) &&
					(m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
			}
		}

#endif 
#ifdef DEF_SAMESIDETOWNPROTECT
		// v2.172 같은편끼리는 마을에서 공격당하지 않는다. 범죄자와 NPC는 예외 중립도 공격 않되게 
		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return ;
#endif 		
#ifdef DEF_BEGINNERTOWNPROTECT
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return;
#endif

		// 01-12-17 같은 파티원이면 공격 불가 
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		
		// 만약 공격자가 플레이어이고 공격자가 안전 공격 모드라면 공격의 의미가 없다. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// 아무 효과 없음. 마나 소비량이 줄었으므로 
				}
				else {
					// 같은 편이지만 만약 사투장 내에서 편이 같다면 공격 처리를 해야한다.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// 사투장 내에서 다른 길드다. 공격이 가능하다. 
						}
						else return;
					}
					else return;
				}
			}

			// 마법 보호 혹은 안전 영역이라면 공격 성공 못함 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}
		
		// 스킬의 사용상태를 모두 무효화 한다.
		ClearSkillUsingStatus(sTargetH);

		// v1.432 속성별 대미지 감소 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}
		
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// 마법 대미지 절감 효과를 가진 아이템이다.
			
			// 아이템의 종류에 따라 대미지를 줄인다. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // 에머랄드 반지 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: // 루비 반지 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				// 마법 데미지 절감 아이템이 부서진다. 
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				// 마법 데미지 절감 아이템의 수명만 줄인다. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42 추가된 고정 마법 대미지 절감
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT에 따른 대미지 감소 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		// 만약 마법 보호중이라면 대미지는 1/2 
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
		// 만약 마법 보호중이라면 대미지는 1/2 
			if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
				iDamage = iDamage / 2;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_sType != 65)
			if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
				iDamage = iDamage / 2;
			break;
		}
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// 행운효과로 죽음을 모면한다.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// v1.432 특수 능력 중 모든 대미지를 막는 효과가 활성화 된 경우 대미지를 입지 않는다.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		{	if ( (m_pClientList[sAttackerH]->m_dwShowDMG == TRUE) && (m_pClientList[sAttackerH] != NULL) )
			{	char cDamageMod[30];
				ZeroMemory(cDamageMod, sizeof(cDamageMod));
				wsprintf(cDamageMod ,"You did %d damage", iDamage);
				ShowClientMsg(sAttackerH, cDamageMod);
		}	}
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// 플레이어가 사망했다.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {

				// v2.04 타격을 받았는데 마나 변환 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					// 최대 마나치 
					iTemp = (2*(m_pClientList[sTargetH]->m_iMag+m_pClientList[sTargetH]->m_iAngelicMag)) + (2*m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iInt+m_pClientList[sTargetH]->m_iAngelicInt)/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04 타격을 받았는데 필살 충전의 특성치가 있었다면 
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					// 확률 계산에 따라서 필살기가 충전된다.
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 5);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12 서버와 클라이언트 간에 카운트가 일치하지 않는 경우가 있을 수 있으므로 가감에 상관없이 보낸다.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}

				// v1.44 사투장이면 대미지 80이상일때 밀린다.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
					 iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
					// 대미지가 50이상이면 튕긴다.
			///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					// v1.44 밀려날때 대미지를 입력한다.
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// 튕겨 나가라는 메시지 입력 	
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}
				else {
EDSD_SKIPDAMAGEMOVE:;
					// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// 충격을 받았다면 충격동작 전송 
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}

				// v1.4 죽은척하고 있는 경우는 Owner 위치를 옮긴다. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person 되어 있었던 상태라면 풀린다. 마법공격 패럴라이즈 된 것도 풀린다.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
			return;
		}
		
		// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 아군이나 중립의 공격에 대미지를 입지 않는다.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			case 39:
			case 87:
			case 89:
			case 92:
				if (m_bIsRushNetMode == TRUE)
					if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}
		
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		{	if ((m_pClientList[sAttackerH]->m_dwShowDMG == TRUE) && (m_pClientList[sAttackerH] != NULL) )
			{	char cDamageMod[30];
				ZeroMemory(cDamageMod, sizeof(cDamageMod));
				wsprintf(cDamageMod ,"You did %d damage", iDamage);
				ShowClientMsg(sAttackerH, cDamageMod);
		}	}

		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			
			if(bFly == TRUE)
			{
				switch(m_pNpcList[sTargetH]->m_sType)
				{
				case 21:
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 94:
				case 96:
				case 98:
				case 87:
				case 89:
				case 91:
					bFly = FALSE;
						break;
				}
			}

			if ((iDamage > 50)&&(bFly == TRUE)) {
				sTgtX = m_pNpcList[sTargetH]->m_sX;
				sTgtY = m_pNpcList[sTargetH]->m_sY;
				if (sTgtX == sAtkX) {
					if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
					else if (sTgtY > sAtkY) cDamageMoveDir = 5;
					else if (sTgtY < sAtkY) cDamageMoveDir = 1;
				}
				else if (sTgtX > sAtkX) {
					if (sTgtY == sAtkY)     cDamageMoveDir = 3;
					else if (sTgtY > sAtkY) cDamageMoveDir = 4;
					else if (sTgtY < sAtkY) cDamageMoveDir = 2;
				}
				else if (sTgtX < sAtkX) {
					if (sTgtY == sAtkY)     cDamageMoveDir = 7;
					else if (sTgtY > sAtkY) cDamageMoveDir = 6;
					else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
				}

				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// 다시 한번 방향을 랜덤하게 구한다.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// 예전 위치에서 지운다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// 새 위치에 표시한다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// 이벤트 알린다.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
										
					// 한번 더 간다.
					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// 다시 한번 방향을 랜덤하게 구한다.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// 예전 위치에서 지운다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// 새 위치에 표시한다. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// 이벤트 알린다.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
										
				}

CAE_SKIPDAMAGEMOVE2:;
			// 충격을 받았다면 충격동작 전송

			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				// 동족이고 편이 같으면 반격하지 않는다.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit가 1이면 반격을 하지 않는다. 오직 움직일수만 있으니.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				
				// 여기서 표효 동작같은것을 위한 메시지 발송.

				// Damage를 입은 충격으로 인한 지연효과.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold 되어 있었던 상태라면 풀린다. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				int iExp;

				// NPC에 대한 공격이 성공했으므로 공격자가 플레이어라면 입힌 대미지 만큼의 경험치를 공격자에게 준다. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStock을 올린다. 단 소환몹인 경우 경험치를 올리지 않는다.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}
						
						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}

						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 경험치 증가 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6 공격자의 레벨이 100 이상이면 토끼나 고양이를 잡을때 경험치가 올라가지 않는다.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}


						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;


					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iHP, iMaxHP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// 해당 타켓의 HP를 올린다. 
	iHP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxHP = (3*m_pClientList[sTargetH]->m_iVit) + (2*m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iStr+m_pClientList[sTargetH]->m_iAngelicStr)/2); // v1.4

		// v1.432 Heal로도 블러드 소드류 HP 최대치 제한은 적용됨
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0) 
			iMaxHP = iMaxHP - (iMaxHP/m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);

		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;

			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;

		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;

			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}


void CGame::SendObjectMotionRejectMsg(int iClientH)
{
 char  * cp, cData[30];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;
	
	m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171
	// 이동이 불가능하다. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_REJECT;
	
	cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;
	
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
 register int i, iTotal;

	iTotal = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
 register int i, ix, iy, iIndex;
 short sOwnerH, iDamage, sType;
 char  cOwnerType;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		switch (m_pDynamicObjectList[i]->m_sType) {
		case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
			// 포이즌 클라우드
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Poison Damage를 입는다.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v2.17 2002-8-5 운영자는 필드류 마법에 데미지를 받지 않는다. 
						if(m_pClientList[sOwnerH]->m_iAdminUserLevel > 0 ) break ;

						// v1.41 중립이고 전투모드가 아니면 피해를 입지 않는다.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						// 이런 식으로 대미지의 크기를 결정
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// 플레이어가 사망했다.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// 마비 상태가 풀린다.	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Poison 효과
							if ( (bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_bIsPoisoned == FALSE) ) {
								
								m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								// 중독되었음을 알린다. 
								// v2.23
								SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
#ifdef DEF_TAIWANLOG
								_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						// 몬스터의 중독효과는 아직 구현 안됨
						if (m_pNpcList[sOwnerH] == NULL) break;

						// 이런 식으로 대미지의 크기를 결정
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 필드류 마법에 대미지를 입지 않는다.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
						case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
							iDamage = 0;
							break;
						}
						
						// HP에서 뺀다. Action Limit에 따라 처리한다.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 일반
						case 3: // 더미류
						case 5: // 건축물 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC가 사망했다.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 중독구름에 죽으면 마지막 대미지가 0. 아이템을 쉽게 구하지 못하게 하기 위함.
						}
						else {
							// Damage를 입은 충격으로 인한 지연효과.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold 되어 있었던 상태라면 풀린다. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC를 도망가는 모드로 전환시킨다.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
						break;
					}
				}
			}
			break;
						
		case DEF_DYNAMICOBJECT_ICESTORM:
			// Ice-Storm 류의 얼음 회오리.
			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Ice Damage를 입는다.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v2.17 2002-8-5 운영자는 필드류 마법에 데미지를 받지 않는다. 
						if(m_pClientList[sOwnerH]->m_iAdminUserLevel > 0 ) break  ;
						// v1.41 중립이고 전투모드가 아니면 피해를 입지 않는다.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(3,3) + 5;
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// 플레이어가 사망했다.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
									// Hold-Person 되어 있었던 상태라면 풀린다. 단 패럴라이즈 된것은 풀리지 않는다. 	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Ice 효과
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
								
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(3,3) + 5;

						// 전쟁용 구조물중 그랜드 매직 제네레이터, 에너지 실드 제네레이터는 필드류 마법에 대미지를 입지 않는다.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
						case 6: // v2.20 2002-12-20 마을 NPC 공격 않되게 
							iDamage = 0;
							break;
						}
						
						// HP에서 뺀다. Action Limit에 따라 처리한다.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 일반
						case 3: // 더미류
						case 5: // 건축물 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC가 사망했다.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 타서 죽으면 마지막 대미지가 0. 아이템을 쉽게 구하지 못하게 하기 위함.
						}
						else {
							// Damage를 입은 충격으로 인한 지연효과.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold 되어 있었던 상태라면 풀린다. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC를 도망가는 모드로 전환시킨다.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);

							// v1.42 Ice 효과
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
																
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
					   	break;
					}
				}

				// 죽은척하고 있는 캐릭이 있다면
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					iDamage = iDice(3,2);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// 플레이어가 사망했다.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// 근처에 Fire Object가 있다면 수명을 줄인다.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE:
			// Fire-Wall쨌첫 쨍쨈 쨘짼
			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				// 짹쨀쩔징 쨍쨈 쨔째째 쨈쨍챕 쨔첩첩쨈. 
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Fire Damage쨍짝 쨈쨈.
					switch (cOwnerType) {
					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41 쨍쨀째챠 체천쨍챨쨉책째징 쩐쨈쨍챕 쨍짝 철 쩐쨈쨈.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(1,6);
						// New 17/05/2004
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// 쨌쨔쩐챤째징 쨩챌쨍쨈.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// 쨔쨘 쨈챘쨔철쨍짝 챘쨘쨍쨈. <- HP쨍짝 짹쨈챘쨌 쩐쨍째쨈.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Hold-Person 쨉쩐챤 쩐첬쨈첩 쨩처쨋처쨍챕 짰쨍째쨈. Fire Field쨌쨈 쨌짼쨋처챤 쨉째쨉쨉 짰쨍째쨈. 	
									// 1: Hold-Person 
									// 2: Paralize	
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(1,6);

						// 체챦쩔챘 짹쨍쨋쨔째 짹쨌짙쨉책 쨍첨 짝쨀쨌쨔, 쩔징쨀철 쩍쨉책 짝쨀쨌쨔쨈 쨉책쨌첫 쨍쨋쨔첵쩔징 쨈챘쨔철쨍짝 철 쩐쨈쨈.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
							iDamage = 0;
							break;
						}
												
						// HP쩔징쩌짯 쨩짬쨈. Action Limit쩔징 쨉청쨋처 쨀쨍짰쨈.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 쨔
						case 3: // 쨈천쨔쨌첫
						case 5: // 째쨔째 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC째징 쨩챌쨍쨈.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 쨍쩌짯 쨍쨍챕 쨍쨋철쨍쨌 쨈챘쨔철째징 0. 쩐쨩 쩍짹째 짹쨍철 쨍첩째 짹창 짠.
						}
						else {
							// Damage쨍짝 쨘 챈째쨍쨌  철쩔짭쩔째첬.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold 쨉쩐챤 쩐첬쨈첩 쨩처쨋처쨍챕 짰쨍째쨈. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC쨍짝 쨉쨉쨍째징쨈 쨍챨쨉책쨌 체짱쩍짼쨈.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
					   	break;
					}
				}
					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_FIRE) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE3:
			// Fire-Wall쨌첫 쨍쨈 쨘짼
			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				// 짹쨀쩔징 쨍쨈 쨔째째 쨈쨍챕 쨔첩첩쨈. 
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			ix = m_pDynamicObjectList[i]->m_sX;
			iy = m_pDynamicObjectList[i]->m_sY; {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Fire Damage쨍짝 쨈쨈.
					switch (cOwnerType) {
					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41 쨍쨀째챠 체천쨍챨쨉책째징 쩐쨈쨍챕 쨍짝 철 쩐쨈쨈.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(1,6);
						// New 17/05/2004
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// 쨌쨔쩐챤째징 쨩챌쨍쨈.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// 쨔쨘 쨈챘쨔철쨍짝 챘쨘쨍쨈. <- HP쨍짝 짹쨈챘쨌 쩐쨍째쨈.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Hold-Person 쨉쩐챤 쩐첬쨈첩 쨩처쨋처쨍챕 짰쨍째쨈. Fire Field쨌쨈 쨌짼쨋처챤 쨉째쨉쨉 짰쨍째쨈. 	
									// 1: Hold-Person 
									// 2: Paralize	
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(1,6);

						// 체챦쩔챘 짹쨍쨋쨔째 짹쨌짙쨉책 쨍첨 짝쨀쨌쨔, 쩔징쨀철 쩍쨉책 짝쨀쨌쨔쨈 쨉책쨌첫 쨍쨋쨔첵쩔징 쨈챘쨔철쨍짝 철 쩐쨈쨈.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
							iDamage = 0;
							break;
						}
												
						// HP쩔징쩌짯 쨩짬쨈. Action Limit쩔징 쨉청쨋처 쨀쨍짰쨈.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // 쨔
						case 3: // 쨈천쨔쨌첫
						case 5: // 째쨔째 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC째징 쨩챌쨍쨈.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 쨍쩌짯 쨍쨍챕 쨍쨋철쨍쨌 쨈챘쨔철째징 0. 쩐쨩 쩍짹째 짹쨍철 쨍첩째 짹창 짠.
						}
						else {
							// Damage쨍짝 쨘 챈째쨍쨌  철쩔짭쩔째첬.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold 쨉쩐챤 쩐첬쨈첩 쨩처쨋처쨍챕 짰쨍째쨈. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC쨍짝 쨉쨉쨍째징쨈 쨍챨쨉책쨌 체짱쩍짼쨈.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
					   	break;
					}
				}
				// 쨘쨈째챠 쨈 쨀쨍짱 쨈쨍챕
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 쨘 쨈째챠 쨈 쨌쨔쩐챤쨈.
					iDamage = iDice(1,6);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// 쨌쨔쩐챤째징 쨩챌쨍쨈.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// 쨔쨘 쨈챘쨔철쨍짝 챘쨘쨍쨈. <- HP쨍짝 짹쨈챘쨌 쩐쨍째쨈.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// 짹쨀쩔징 Ice Object째징 쨈쨍챕 쩌철쨍챠쨩 쨈.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		}
	}
}



void CGame::ClearSkillUsingStatus(int iClientH)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL; //v1.12
	}

	// 만약 이벤트 낚시와 같은 것을 하고 있었다면 여기서 해제되었음을 통보해 준다. 
	
	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
		// 이벤트 낚시 모드였다. 해제시킨다. 
		
		// 카운트 감소
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
 class CItem * pItem;
 short lX, lY;
 int   iResult, iFish, iItemID = 0 ;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	// 스킬 사용 여부 주사위를 굴린다. 
	if (cOwnerSkill == 0) return 0;
	
	// 스킬이 100이라고 해도 가끔 낚시를 실패하게 하기 위해서 1D105 
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  // 실패다.

	// 땅에서는 낚시가 불가능 
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

	// 성공했으므로 스킬 카운트를 올린다.
/*	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);*/

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		// 길들이기 기술: dX, dY 부근의 몬스터를 길들인다.
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;
	
	case DEF_SKILLEFFECTTYPE_GET: 
		// 아이템을 얻는 기술이었다. 
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
			iItemID = 99 ;  // 고기 
			break;

		case 2:
			// 물고기 
			// 낚시의 경우 위치와 시간대의 영향에 따라 또 성공률이 달라진다. 
			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0; 
			
			// 근처에 다이나믹 오브젝트 물고기가 존재한다면 본격낚시 모드로 들어간다.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
		   		if (iFish == NULL) iItemID = 100 ; // 물고기 
			}
			else iItemID = 100 ; // 물고기 
			break;
		}

		if (iItemID != 0) {
			
			// 낚시에 성공했다면 메시지를 전송.
			if (iItemID == 100) { 
				SendNotifyMsg(NULL, iOwnerH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
				// v1.41 약간의 경험치 상승 
				// v2.15 낚시를 할때 경험치를 더 준다.
				GetExp(iOwnerH, iDice(2,5)); //m_pClientList[iOwnerH]->m_iExpStock += iDice(1,2);
			}
			
			pItem = new class CItem;
			if (pItem == NULL) return 0;
			if (_bInitItemAttr(pItem, iItemID) == TRUE) {

			// 아이템에 고유 코드 입력 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);

				pItem->m_sTouchEffectValue3 = (short) timeGetTime();

				// 아이템을 놓는다. 
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
		
				// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
			}
		}
		break;

	}

	return 1;
}



void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
 char  cOwnerType;
 short sAttackerWeapon, sOwnerH;
 int   iResult, iPlayerSkillLevel;
 DWORD dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;
	if (bAllVsAll) return;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				// 죽은척 하기를 할 자리에 시체가 있어 기술 사용이 중지 되었음을 알린다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			// v2.17 2002-6-29 죽은척할때 명 모드였다면 마법 Casting시에 해제된다.
			if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	{
				SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				
				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
				m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
			}

			// 스킬 카운트 올린다. <-- 내부에서 카운팅을 해야 엉뚱한 스킬이 오르는 경우가 없다. 
			//CalculateSSN_SkillIndex(iClientH, iV1, 1);
			
			// 다른 클라이언트에게 죽는 동작 전송.
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, NULL);
			// 정상 위치에서 지운다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			// 죽은 위치 표시를 한다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
 char cItemCategory;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 BOOL   bNeutral;
 DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;

	// 사용자의 아이템 팔기 요구.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	iCalcTotalWeight(iClientH);

	// v1.42
	bNeutral = FALSE;
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) bNeutral = TRUE;

	// v2.13 성후니 수정 물건을 어디서나 팔게 수정하여서 팔때는 NPC 구분이 필요없다. 
	// 단 카테고리를 기준으로 아이템 가격을 결정한다.
	switch (cSellToWhom) {
	case 15: 		// 상점 아줌마 
	case 24:        // 대장간 주인 
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		// 12-22 성후니 수정 어디서든 팔수 있게 수정 
		// 상점아이템 
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {

			// 적합하다. 무조건 반값 
			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			
			//v1.42 중립인 경우 반의 반값.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;


			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) < (DWORD)_iCalcMaxLoad(iClientH)) {
				// v2.12 팔 경우 무게가 초과되어서 팔 수 없다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		// 대장간 아이템
		else if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
				// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 가격을 매긴다.
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				// 고장난 아이템은 팔 수 없다
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					 d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
				d3 = d3 * d2; // 추산된 가격 
				
				iPrice = (int)d3;
				iPrice = iPrice*iNum;
				
				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				// 아이템 특성치에 따른 가격 상승 
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
					// 희귀 아이템 효과 종류: 
					// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
					// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의
					switch (dwSWEType) {
					case 6: dwMul1 = 2; break;  // 가벼운 
					case 8: dwMul1 = 2; break;  // 강화된
					case 5: dwMul1 = 3; break;  // 민첩의
					case 1: dwMul1 = 4; break;  // 필살의 
					case 7: dwMul1 = 5; break;  // 예리한
					case 2: dwMul1 = 6; break;  // 중독의
					case 3: dwMul1 = 15; break; // 정의의 
					case 9: dwMul1 = 20; break; // 고대문명 
					default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice*dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice1 = (int)(d1 + d3);
				}

				// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
					// 희귀 아이템 효과 종류: 
					//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
					//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
					//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
					switch (dwSWEType) {
					case 1: 
					case 12: dwMul2 = 2; break;
					
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;
					
					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}
					
					d1 = (double)iPrice*dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice2 = (int)(d1 + d3);
				}

				// v2.03 925 특수 아이템 가격 가중치를 77%수준으로 다운 
				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

				//v1.42 중립인 경우 반의 반값.
				if (bNeutral == TRUE) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;
				
				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) < (DWORD)_iCalcMaxLoad(iClientH)) {
					// v2.12 팔 경우 무게가 초과되어서 팔 수 없다.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;
	

	default:
		break;
	}
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
 class CItem * pItemGold;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 char   * cp, cItemName[21], cData[120], cItemCategory;
 DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
 WORD   * wp;
 int    iEraseReq, iRet;
 short * sp;
 BOOL   bNeutral;

	// 아이템을 팔겠다는 것이 결정되었다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;
	// v2.182 2002-11-15 사고 팔수 있는 곳인지 체크하는 변수 추가 
	if (m_pClientList[iClientH]->m_bIsOnShop == FALSE ) return;


	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = FALSE;
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) bNeutral = TRUE;

	iPrice = 0;
	// 아이템의 종류에 따라 가격 계산.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// 무기류다
  		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 가격을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		
		if (sRemainLife <= 0) {
			// 망가진 아이템은 팔지 못한다.	
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			// 아이템 특성치에 따른 가격 상승 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
				// 희귀 아이템 효과 종류: 
				// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
				// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  // 가벼운 
				case 8: dwMul1 = 2; break;  // 강화된
				case 5: dwMul1 = 3; break;  // 민첩의
				case 1: dwMul1 = 4; break;  // 필살의 
				case 7: dwMul1 = 5; break;  // 예리한
				case 2: dwMul1 = 6; break;  // 중독의
				case 3: dwMul1 = 15; break; // 정의의 
				case 9: dwMul1 = 20; break; // 고대문명 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
				// 희귀 아이템 효과 종류: 
				//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
				//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
				//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;
					
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;
					
				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}
					
				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			// v2.03 925 특수 아이템 가격 가중치를 77%수준으로 다운 
			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

			//v1.42 중립인 경우 반의 반값.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			// 아이템을 팔았다는 메시지 전송 (다이얼로그 박스 비활성화용)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

			// 팔 아이템을 삭제 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				// 수량 개념이 있다면 갯수를 줄인다.
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			// v2.15 Sell 로그가 남기 때문에 Deplete 로그를 남기지 않는다.
			else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);

		}
	}
	else 
	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
		// 식품, 잡화등의 반값물건들 
		iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice/2; 
		iPrice = iPrice*iNum;

		//v1.42 중립인 경우 반의 반값.
		if (bNeutral == TRUE) iPrice = iPrice/2;
		if (iPrice <= 0) iPrice = 1;
		if (iPrice > 1000000) iPrice = 1000000;
	
		// 아이템을 팔았다는 메시지 전송 (다이얼로그 박스 비활성화용)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

		_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

		// 아이템의 종류에 따라 적절한 처리를 한다.
		if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// 수량 개념이 있다면 갯수를 줄인다.
			// v1.41 !!!
			SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
		}
		// v2.15 Sell 로그가 남기 때문에 Deplete 로그를 남기지 않는다.
		else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);
	}

	// Gold를 증가시킨다. 만약 판 가격이 0 혹은 마이너스이면 금을 주지 않는다.
	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);
	
	pItemGold->m_dwCount = iPrice;
	
	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
		*cp = 1;
		cp++;
		
		memcpy(cp, pItemGold->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItemGold->m_dwCount;
		cp += 4;
		
		*cp = pItemGold->m_cItemType;
		cp++;
		
		*cp = pItemGold->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sLevelLimit;
		cp += 2;
		
		*cp = pItemGold->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSpriteFrame;
		cp += 2;

		*cp = pItemGold->m_cItemColor;
		cp++;

		*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItemGold->m_dwAttribute;
		cp += 4;

		*cp = (char)pItemGold->m_sItemSpecEffectValue3;
		cp++;

		/*
		*cp = (char)(pItemGold->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
		
		if (iEraseReq == 1)
			delete pItemGold;
		
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
		
		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
	}
	else {
		// 중량 초과등의 문제로 추가 실패.
		// 받지 못했으므로 바닥에 떨어진다. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);
		
		// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); // v1.4 color

		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);
		
		// 더이상 가질수 없다는 메시지를 보낸다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
 char cItemCategory;
 short sRemainLife, sPrice;
 double d1, d2, d3;

	// 아이템을 고치겠다는 요구.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// 아이템의 종류에 따라 가격 계산.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// 무기류다
  		
		// 만약 무기를 대장간 주인이 아닌 이에게 고쳐달라고 한다면 할 수 없다. 
		if (cRepairWhom != 24) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 수리 비용을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// 완전히 망가진 것이라면 원래가격의 절반이 든다. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if ( ((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 13))) {
		// 낚싯대, 곡괭이 등과 같은 비무기류 수리가능 아이템. 옷, 부츠류
		
		// 만약 상점 주인이 아닌 이에게 고쳐달라고 한다면 할 수 없다. 
		if (cRepairWhom != 15) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 수리 비용을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// 완전히 망가진 것이라면 원래가격의 절반이 든다. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		// 고칠수 없는 아이템이다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
 short    sRemainLife, sPrice;
 char   * cp, cItemCategory, cData[120];
 double   d1, d2, d3;
 DWORD  * dwp, dwGoldCount;
 WORD   * wp;
 int      iRet, iGoldWeight;

	// 아이템을 수리하겠다는 것이 결정되었다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	// v2.19 2002-11-12 상점이나 대장간에서만 아이템 수리가 가능하게 수정 (해킹방지를 위해)
	if( m_pClientList[iClientH]->m_bIsOnShop != TRUE ) return ;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// 아이템의 종류에 따라 가격 계산.
  	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		((cItemCategory >= 11) && (cItemCategory <= 13))) { // v2.15 2002-5-15 Wizard 로브도 수리가능하게 수정 
		// 무기류 혹은 낚시대, 곡괭이와 같은 아이템, 옷, 신발 

  		// 원래 아이템의 수명과 비교해서 감가 상각을 계산, 아이템의 수리 비용을 매긴다.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// 완전히 망가진 것이라면 원래가격의 절반이 든다. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // 원래 가격 
			d3 = d3 * d2; // 추산된 가격 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}
		
		// sPrice만큼의 돈이 되면 고칠 수 있으나 부족하면 고칠 수 없다. 
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
		if ( dwGoldCount < (DWORD)sPrice ) {
			// 플레이어가 갖고있는 Gold가 아이템 수리 비용에 비해 적다. 고칠 수 없음.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
			cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp  = cItemID;
			cp++;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
			return;
		}
		else {
			//돈이 충분하다. 고칠 수 있다. 
			
			// 아이템의 수명을 늘리고 통보한다. !BUG POINT 위치가 중요하다. 먼저 수명을 늘리고 돈의 카운트를 낮춘다.
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
		 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, NULL, NULL);

#ifdef TAIWANLOG
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName != NULL) 
			_bItemLog(DEF_ITEMLOG_REPAIR,iClientH,m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName,NULL) ;
#endif 
			
			iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice );
			
			// 소지품 총 중량 재 계산 
			iCalcTotalWeight(iClientH);

			//v1.4 마을의 자금에 더한다. 
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
		// 고칠 필요가 없는 아이템 
		// 해킹이나 버그에 의한 것일듯 
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
 register int i, iWeight;
 short sItemIndex;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// 착용하지 않아도 효과가 있는 아이템 효과. 소지하고 있어도 효과가 있기 때문에 여기서 검사.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// 수명이 있어야 효과가 있다.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}

	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		
		iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
	}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;	
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cName[11], cBuff[256], cTemp[120];
 class  CStrTok * pStrTok;
 register int i;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) 
		 memcpy(cName, token, 10);	
	else memcpy(cName, token, strlen(token));

	// cName의 이름을 가진 플레이어가 접속중인지 찾는다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
		// 같은 이름을 가진 캐릭터를 찾았다. 
		// 01-12-10 접속 위치 확인 

		// v2.14 /fi 기능 추가 
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		// v2.14 /fi 기능 
			cp = (char * ) cTemp ;
			memcpy(cp, m_pClientList[i]->m_cMapName, 10) ;
			cp += 10 ;
			
			wp = (WORD *)cp;
			*wp =(WORD) m_pClientList[i]->m_sX;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD) m_pClientList[i]->m_sY;
			cp += 2;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName, NULL, NULL, NULL, NULL, NULL, NULL, cTemp);

		delete pStrTok;
		return;
	}

	//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	// 현재 서버에 캐릭이 접속하고 있지 않다. 다른 서버에 접속 여부를 묻는다.

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}


     void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
char  seps[] = "= \t\n";
char  * token, cName[11], cBuff[256];
class CStrTok * pStrTok;
register int i;
char *cp;
WORD *wp;

if (m_pClientList[iClientH] == NULL) return;
if (dwMsgSize <= 0) return;

ZeroMemory(cName, sizeof(cName));
ZeroMemory(cBuff, sizeof(cBuff));
memcpy(cBuff, pMsg, dwMsgSize);

pStrTok = new class CStrTok(cBuff, seps);
token = pStrTok->pGet();
token = pStrTok->pGet();
  
if (token == NULL) {
 m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
 ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
 m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
 // Whisper mode enabled
 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
}
else {
 if (strlen(token) > 10)
  memcpy(cName, token, 10);
 else memcpy(cName, token, strlen(token));
 
 m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

 for (i = 1; i < DEF_MAXCLIENTS; i++)
 if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
  if (i == iClientH) {
  delete pStrTok;
  // Whisper self XenX
  SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You shouldnt talk to yourself!");
  return;
  }
  m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
  ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
  strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
   break;
 }

 if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
 ZeroMemory(cBuff, sizeof(cBuff));
 cp = (char *)cBuff;
 *cp = GSM_REQUEST_FINDCHARACTER;
 cp++;

 wp = (WORD *)cp;
 *wp = m_wServerID_GSS;
 cp += 2;

 wp = (WORD *)cp;
 *wp = iClientH;
 cp += 2;

 memcpy(cp, cName, 10);
 cp += 10;

 memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
 cp += 10;

 bStockMsgToGateServer(cBuff, 25);

 ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
 strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
 m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = TRUE;
 }
 else{
 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
return;
 }
 //player not online XenX
 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "This player is not online!");
}
delete pStrTok;
}


void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char cTemp[256];
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);
	
	// 공백란을 언더바로 바꾼다. 
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	// 에러 방지 코드 
	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256], cBuff2[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 프로필을 얻고자 하는 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
		
			ZeroMemory(cBuff2, sizeof(cBuff2));
			//v2.19 2002-12-18 profile이 않나오는 버그 수정 
			wsprintf(cBuff2, "%s Profile:%s", cName, m_pClientList[i]->m_cProfile); // v2.04
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

			delete pStrTok;
			return;
		}
		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	delete pStrTok;
	return;
}


void CGame::___RestorePlayerCharacteristics(int iClientH)
{
 int iStr, iDex, iInt, iVit, iMag, iCharisma;
 int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
 int iMax, iA, iB;
 BOOL bFlag;
 char cTxt[120];

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLU_Pool > 3) return;

	// 먼저 값을 백업한다. 
	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;
	

	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
		        m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
				m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
  
	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1)*3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	// 복구할 필요가 없다면 귀환.
	if (iToBeRestoredPoint == 0) return;
  
	if (iToBeRestoredPoint > 0) {
		// 이제 iToBeRestoredPoint 만큼의 포인트를 복구한다. 
		// 먼저 10 이하의 포인트가 있다면 우선적으로 채운다. 
		while (1) {
			bFlag = FALSE;
			
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			
			if (bFlag == FALSE)          break;
			if (iToBeRestoredPoint <= 0) break; 
		}
		
		// 맨손 격투 스킬의 최대치는 iMax, Str이 iMax/2보다 낮다면 그만큼 올린다. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];
		
		if (m_pClientList[iClientH]->m_iStr < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iStr == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 무기 사용 스킬의 최대치는 iMax, Dex가 iMax/2보다 낮다면 그만큼 올린다. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;
		
		
		if (m_pClientList[iClientH]->m_iDex < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iDex == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 죽은척하기 스킬의 최대치는 iMax, Int이 iMax/2보다 낮다면 그만큼 올린다. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];
		
		if (m_pClientList[iClientH]->m_iInt < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iInt == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 마법 스킬의 최대치는 iMax, Mag이 iMax/2보다 낮다면 그만큼 올린다. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		
		if (m_pClientList[iClientH]->m_iMag < (iMax/2)) {
			
			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				
				if (m_pClientList[iClientH]->m_iMag == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}
		
		// 남은 포인트를 랜덤하게 올린다.
		while (iToBeRestoredPoint != 0) {
			switch (iDice(1,6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}
		
		// 복구가 성공적으로 되었는지 확인한다. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
		
		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
			
			// 에러다. 이전 값으로 복구.
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		// 해킹이나 에러에 의해서 특성치가 오버된 경우이다. 오버된 포인트만큼 뺀다. iToBeRestoredPoint가 마이너스상태! 
		
		// 먼저 특성치 제한치를 오버한 값을 뺀다.
		while (1) {
			bFlag = FALSE;
		 	if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == FALSE)	break;
			if (iToBeRestoredPoint >= 0) break;
		}
		
		if (iToBeRestoredPoint < 0) {
			// 남은 포인트 만큼 랜덤하게 선택된 특성치의 값을 내린다.
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			// 계산을 했더니 다시 값이 오버되었다. 이럴수가 있을까?
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		// 복구가 성공적으로 되었는지 확인한다. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
		
		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
			
			// 에러다. 그러나 이전 값으로 복구할 수는 없다. 초과하므로
			/*
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
			*/
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}


void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, BOOL bNotify)
{
 register short sItemIndex;
 int  i, iArrowIndex, iPrevSAType, iTemp, iTemp2;
 char cEquipPos;
 double dV1, dV2, dV3;
 DWORD  dwSWEType, dwSWEValue;
 short  sTemp;

   	if (m_pClientList[iClientH] == NULL) return;

	if ( (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]   != -1) &&
		 (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) ) {
		
		// 잘못된 무기 장착 조합이다. 둘 중 하나를 내려 놓는다. 
		if (m_pClientList[iClientH]->m_pItemList[ m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] ] != NULL) {
			// 한손 검의 장착 상태를 해제한다. 
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = FALSE;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
		}
	}

	m_pClientList[iClientH]->m_iAngelicStr			= 0; 
	m_pClientList[iClientH]->m_iAngelicInt			= 0; 
	m_pClientList[iClientH]->m_iAngelicDex			= 0; 
	m_pClientList[iClientH]->m_iAngelicMag			= 0; 
	SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, 0);

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;  

	m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L      = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = (m_pClientList[iClientH]->m_iDex+m_pClientList[iClientH]->m_iAngelicDex) * 2;
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;
	
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i]  = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio  = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage  = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect  = FALSE;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir   = 0;	// 속성별 대미지 흡수
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire  = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack  = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L  = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L  = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = 0;	// 희귀 아이템 효과 종류: 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	// 희귀 아이템 효과 값

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0; 
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;	
	// v2.20 2002-12-28 3주년 기념반지 버그 수정  
	m_pClientList[iClientH]->m_iHPStatic_stock = 0;
	
	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType     = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec  = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		

	

	// 착용하지 않아도 효과가 있는 아이템.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// 수명이 있어야 효과가 있다.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}
	
	// 착용을 해야 효과가 있는 아이템 
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) && 
		 (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) {

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		
		case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
			// 마법 데미지 절감 아이템. 인덱스를 저장한다.
			m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
			break;
		// v2.181 2002-10-25 3주년 이벤트 반지 효과 추가 
		// v2.19 2002-10-25 3주년 이벤트 반지 효과 추가 버그 수정 
		// v2.20 2002-12-28 3주년 기념반지 버그 수정 
		case DEF_ITEMEFFECTTYPE_HP:
			m_pClientList[iClientH]->m_iHPStatic_stock += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4 ;
			break; 
		
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:
			// 무기 장착 효과
			m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;

			// v2.05 무기의 특성치 추가 
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;

			// 고정 대미지 추가
			if (iTemp == 15) {
			iTemp += 3;
			m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
			m_pClientList[iClientH]->m_iAddMagicalDamage  += (iTemp++);
			}
			else {
           	m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
			m_pClientList[iClientH]->m_iAddMagicalDamage  += iTemp;
			}
			// 공격무기의 해당 스킬만큼의 명중률을 더한다. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			
			// v1.432 사용하지 않는다. 무기의 공격대상별 명중률 가감치를 더한다.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			// 플레이어가 사용하는 무기의 스킬을 저장한다. 
			m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;
			
			// v1.41 Custom-Made 아이템이라면 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				// 에러 보정용 
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
					// 양수면 무기의 타격치 최소값이 최대 5까지 올라간다.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + 
														   m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMinAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L + 
														   m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

					// 수치 조정 
					if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

					// 최소값이 최대값보다 크면 최대값만큼 
					if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
				}
				else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
					// 음수면 무기의 타격치 최대값이 최대 5까지 내려간다.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM 
														   + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMaxAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L 
														   + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					
					// 수치 조정 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

					// 최대값이 최소값보다 작으면 최소값만큼 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MaxAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMaxAP_SM, m_pClientList[iClientH]->m_iMaxAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
			}

			// v1.42 희귀 아이템이라면 Main 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// 희귀 아이템 효과 종류: 
				// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
				// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의 10-마법 성공의
				m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = (int)dwSWEType;	
				m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

				switch (dwSWEType) {
				case 7: // 예리한 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // 고대문명의
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				}
			}

			// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// 희귀 아이템 효과 종류: 
				//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
				//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
				//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break; // Poison Resistance
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break; // ????
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break; // Defense Ratio
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break; // HP Recovery
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break; // SP Recovery
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break; // MP Recovery
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break; // Magic Resistance
				case 8:  if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 402) {m_pClientList[iClientH]->m_iAddAbsPD += (int)dwSWEValue*3; break;} // Physical Absorption
				case 9:  if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 402) {m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;} // Magic Damage Absorption
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break; // Critical Damage
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break; // Exp +%d
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break; // Gold +%d
				}

				// v2.04 특성치 제한을 붙임.
				switch (dwSWEType) {
				case 8: if (m_pClientList[iClientH]->m_iAddAbsPD > 80) m_pClientList[iClientH]->m_iAddAbsPD = 80; break;
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break;
				}
			}

			// 일반 공격 이외의 효과를 설정.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
				// 최대 HP 감소 효과
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
				// 마나 절약 효과: 마나 절감률은 최대 80%
				m_pClientList[iClientH]->m_iManaSaveRatio    += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
				// 추가 물리 방어 능력 효과 
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
				// 특수 능력 종류
				m_pClientList[iClientH]->m_iSpecialAbilityType    = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// 특수 능력 지속 시간
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// 장착 위치 기억해 놓는다.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
								
				// 특수 능력 설정됨을 알려준다.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_ADDEFFECT:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 2:
				m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case 3:
				m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 4:
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 5:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
					 m_pClientList[iClientH]->m_bIsLuckyEffect = TRUE;
				else m_pClientList[iClientH]->m_bIsLuckyEffect = FALSE;
				break;

			case 6:
				m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 7:
				m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 8:
				m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 9:
				m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 10:
				m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 11:
				m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;
			
			case 12: // Adds To Hit Bonus (Xelima Neck)
				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_iAddAR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				break;
			case 13: // Magin Ruby		Characters Hp recovery rate(% applied) added by the purity formula.
				m_pClientList[iClientH]->m_iAddHP += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /5);
				break;

			case 14: // Magin Diamond	Attack probability(physical&magic) added by the purity formula.
				m_pClientList[iClientH]->m_iAddAR += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /5);
				break;

			case 15: // Magin Emerald	Magical damage decreased(% applied) by the purity formula.				
				m_pClientList[iClientH]->m_iAddAbsMD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /10);
				break;
			case 16: // Angel STR//AngelicPandent(STR)
				iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicStr = (iTemp+iTemp2);
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 1, (iTemp+iTemp2));
			//	AngelSkills(iClientH, 1, 1);
				if ((iEquipItemID != -1)&&(m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 908))	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
		
			case 17: // Angel DEX //AngelicPandent(DEX)
				iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicDex = (iTemp+iTemp2);
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 2, (iTemp+iTemp2));
			//	AngelSkills(iClientH, 3, 1);
				if ((iEquipItemID != -1)&&(m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 909))	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			
			case 18: // Angel INT//AngelicPandent(INT)
				iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicInt = (iTemp+iTemp2);
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 3, (iTemp+iTemp2));
			//	AngelSkills(iClientH, 4, 1);
				if ((iEquipItemID != -1)&&(m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 910))	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;
			
			case 19: // Angel MAG//AngelicPandent(MAG)
				iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				m_pClientList[iClientH]->m_iAngelicMag = (iTemp+iTemp2);
				SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 4, (iTemp+iTemp2));
		//		AngelSkills(iClientH, 2, 1);
				if ((iEquipItemID != -1)&&(m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 911))	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				break;

			case 20: // Magin Sapphire	physical damage decreased(% applied) by the purity formula.				
				m_pClientList[iClientH]->m_iAddAbsPD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 /10);
				break;

			}
			break;
			
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
			// 화살을 필요로 하는 무기(활류)
			// 무기의 공격효과는 어떤 화살이 선택되느냐에 따라 달라진다. 아이템중 화살을 찾아 할당한다.
			if ( (m_pClientList[iClientH]->m_cArrowIndex != -1) && 
				 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == NULL) ) {
				// ArrowIndex에 화살이 없다. (비어있는 아이템) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			}
			else if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			
			if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
				// 화살이 없다.
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
				m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
			}
			else {
				iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
				/*
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue6;
				*/
				// v2.12 활의 타격치는 화살이 아니라 활 자체로 바뀐다.
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			}
			
			// 공격무기의 해당 스킬만큼의 명중률을 더한다. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			// v1.432 사용하지 않는다. 무기의 공격대상별 명중률 가감치를 더한다.
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			break;
			
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_DEFENSE:
			// 방어구 장착 효과.
			// 방어구가 장착되었다.	현재 Defense Ratio에서 방어구의 능력치만큼의 수를 더한다.
			m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			
			// v1.432 사용하지 않는다.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			
			// v1.41 Custom-Made 아이템이라면 효과를 설정한다. 
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				
				// 보너스 방어력 계산 
				dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV3 = (double)m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				dV1 = (double)(dV2 / 100.0f)*dV3;
					
				dV1 = dV1 / 2.0f;
				// 이 값을 더한다. 
				m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;

				//testcode
				//wsprintf(G_cTxt, "Custom-Defense: %d", (int)dV1);
				//PutLogList(G_cTxt);
			}

			// v1.42 희귀 아이템이라면 Main 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// 희귀 아이템 효과 종류: 
				// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 4-저주의 
				// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의 10-마법성공의 11-마나변환의 12-필살충전의
			
				switch (dwSWEType) {
				case 7: // 예리한 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // 고대문명의
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;

				// v2.04 
				case 11: // 마나 변환의 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddTransMana > 13) m_pClientList[iClientH]->m_iAddTransMana = 13;
					break;

				case 12: // 필살 충전의 
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				}
			}

			// v1.42 희귀 아이템이라면 Sub 효과를 설정한다. 공격무기는 1개만 장착된다고 했을때만 유효함.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// 희귀 아이템 효과 종류: 
				//추가 독성저항(1), 추가 명중값(2), 추가 방어값(3), HP 회복량 추가(4), SP 회복량 추가(5)
				//MP 회복량 추가(6), 추가 마법저항(7), 물리 대미지 흡수(8), 마법 대미지 흡수(9)
				//연타 대미지 추가(10), 더 많은 경험치(11), 더많은 Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 402) {m_pClientList[iClientH]->m_iAddAbsPD += (int)dwSWEValue*3; break;} // Physical Absorption
				case 9:  if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 402) {m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;} // Magic Damage Absorption
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}

				// v2.04 특성치 제한을 붙임.
				switch (dwSWEType) {
				case 8: if (m_pClientList[iClientH]->m_iAddAbsPD > 150) m_pClientList[iClientH]->m_iAddAbsPD = 150; break; // 마법 대미지 흡수 최대 80%
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break; // 마법 대미지 흡수 최대 80%
				} 

			}

			switch ( cEquipPos ) {
			case DEF_EQUIPPOS_LHAND:
				// 방어구 중 방패가 장착 되었다. 
				// 방패에 의한 충격 흡수 효과 할당한다. 방어값의 70% 수준 
				m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)/3;
				break;
			default:
				// 갑옷에 의한 충격 흡수 효과를 더한다. 방어값의 70% 수준 <- v1.43 100%로 변경되었다. V2!
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				break;
			}

			// 일반 공격 이외의 효과를 설정.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
				// 특수 능력 종류
				m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// 특수 능력 지속 시간
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// 장착 위치 기억해 놓는다.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				
				// 특수 능력 설정됨을 알려준다.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;
		}
	}

	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) {
		// 특수 능력이 해제되었다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		// 만약 특수 능력 사용 중이었다면 외모도 변화하며 사용도 종료.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// 다음 사용 가능 시간을 입력한다.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// 효과 비트 클리어
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// 외형이 변했음을 알린다.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
	
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) && 
		(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify == TRUE)) {
		// 특수 능력 사용 도중에 특수 능력을 바꾸면 능력 사용이 멈춘다.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			// 사용시간이 다 되었다.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// 다음 사용 가능 시간을 입력한다.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// 효과 비트 클리어
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// 외형이 변했음을 알린다.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
 register int ix, iy, iSum = 0;
 short sOwnerH;
 char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
	for (iy = dY - cRange; iy <= dY + cRange; iy++) {
		m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
			iSum++;
	}

	return iSum;
}

void CGame::RequestAdminUserMode(int iClientH, char * pData)
{


}

BOOL CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, BOOL bIsCheck)
{
 int   iNamingValue, tX, tY;
 short sOwnerH;
 char  cOwnerType, cName[11], cNpcName[21];
 char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
	if (m_bIsCrusadeMode == TRUE) return FALSE;

	// dX, dY에 대한 지속적 위해 행위가 범죄에 해당하는지 판단한다. 
	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
			// 범죄행위다. 마을에 있었다면 소환 가드로 공격시킨다. 
			if (bIsCheck == TRUE) return TRUE;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) 
				strcpy(cNpcName, "Guard-Neutral");
			else strcpy(cNpcName, "XXX");  // <- 이것은 마을이 아니므로 NPC를 생성하지 못하게 하기 위함 

			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
			}
			else {
				// NPC를 생성한다.
				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
				
				ZeroMemory(cName, sizeof(cName));
			   	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					// 공격 목표를 할당한다.
					bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}
			//
		}
	}

	return FALSE;
}

BOOL CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[sOwnerH]  == NULL) return FALSE;

	// 자기 자신에 대한 공격은 범죄라 볼 수 없다. 
	if (iClientH == sOwnerH) return TRUE;

	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
		// 공격자는 여행자이다.
		// 상대방이 범죄자이면 적성이며 그 이외에는 아니다. 
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 return TRUE;
		else return FALSE;
	}
	else {
		// 공격자는 소속 마을을 갖고 있다. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			// 서로 사이드가 다르다. 
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				 	 return TRUE;
				else return FALSE;
			}
			else return TRUE;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 	 return TRUE;
			else return FALSE;
		}
	}

	return FALSE;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, BOOL bIsPermAttack)
{
 register int i, iIndex;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
		iIndex = i;
		goto NEXT_STEP_SNAM1;

		//testcode
		//PutLogList("bSetNpcAttackMode - Npc found");
	}
	// 같은 이름을 가진 NPC가 없다.
	return;

NEXT_STEP_SNAM1:;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == NULL) return;
		break;
	}

	// 목표물을 할당한다. 
	m_pNpcList[iIndex]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;		
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;

	// 영구 공격 모드 여부 설정 
	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;

	//testcode
	//PutLogList("bSetNpcAttackMode - complete");
}


void CGame::PoisonEffect(int iClientH, int iV1)
{
 int iPoisonLevel, iDamage, iPrevHP, iProb;

	// 중독으로 죽지는 않는다. 다만 체력이 계속 깍이고 최소 1만 남는다. 
	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);
	
	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

	// 독성 저항 확률로 중독이 풀릴 수 있다.
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] -10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		// 중독이 풀렸음을 알린다. 
		// v2.23
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}



BOOL CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
 int iResist, iResult;
	
	// 독성 저항이 성공했는지를 계산한다. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return FALSE;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] +m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return FALSE;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
  	if (iResult >= iResist) // 독성 저항 실패. 중독된다.
		return FALSE;

	// 독성 저항 성공. 플레이어라면 스킬을 올린다. 
	/*if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);*/

	return TRUE;
}

BOOL CGame::bCheckBadWord(char * pString)
{
 char * cp;

	// 스트링을 검색하며 욕설이 있는지를 찾는다. 
	cp = pString;
	while (*cp != NULL) {
		
		cp++;
	}

	return FALSE;
}

void CGame::CheckDayOrNightMode()
{
 SYSTEMTIME SysTime;	
 char cPrevMode;
 int  i;

	// 현재 시간에 따라 낮 혹은 밤을 결정한다. 
	// 주, 야간 모드 설정 
	cPrevMode = m_cDayOrNight;
 
	GetLocalTime(&SysTime);
	if ((SysTime.wHour >= 20)||(SysTime.wHour < 6)){
		if (SysTime.wMonth == 12)
			m_cDayOrNight = 3;
		else
			m_cDayOrNight = 2;
	}
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		// 주, 야간 모드가 변경되었다. 주, 야간 모드의 영향을 받는 맵에 존재하는 클라이언트들에게 알린다. 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256],* cp;
 WORD * wp ;
 class  CStrTok * pStrTok;
 register int i, iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 



	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 채팅을 불가능하게 만들 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		// 다음 토큰은 정지 시킬 시간. 
		token = pStrTok->pGet();
		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			// v2.14 셧업시간을 분으로 수정
			m_pClientList[i]->m_iTimeLeft_ShutUp = iTime*20; // 1이 3초다. 20이면 1분 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);

			// Admin Log
			// v2.14 성후니 수정 
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime);

#ifdef DEF_TAIWANLOG
			_bItemLog(DEF_ITEMLOG_SHUTUP,i,m_pClientList[iClientH]->m_cCharName,NULL) ;

			// Admin Log
			// v2.14 성후니 수정 
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime);

			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);
#endif

			delete pStrTok;
			return;
		}

		// v2.12 다른 서버에 있는 캐릭터에게 메시지를 보내기 위함 
		// 현재 서버에 없다. 다른 서버에 있는지 검사해야 한다.
		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SHUTUPPLAYER;
		cp++;

		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 27);

		delete pStrTok;
		return;

	}

	delete pStrTok;
	return;
}

void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 15) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		// 평가를 내릴 시간이 되지 않았거나 범죄자는 평가를 내릴 수 없다. 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	else if ( m_pClientList[iClientH]->m_cSide == DEF_NETURAL ) { // 2002-11-15
		// 소속 마을이 없는 사람은 평판을 내릴 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;	
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			if (i != iClientH) {
				if (cValue == 0) 
					m_pClientList[i]->m_iRating -= 2;
				else if (cValue == 1)
					m_pClientList[i]->m_iRating +=2;
				
				if (m_pClientList[i]->m_iRating > 10000)  m_pClientList[i]->m_iRating = 10000;
				if (m_pClientList[i]->m_iRating < -10000) m_pClientList[i]->m_iRating = -10000;
				m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				
				delete pStrTok;
				return;
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}
	
	delete pStrTok;
	return;
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
 char * cp, cCharName[11];
 register int i;

	ZeroMemory(cCharName, sizeof(cCharName));
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	// 이제 이 이름을 갖는 클라이언트를 찾아 접속을 끊어도 좋다는 메시지를 보낸다. 
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			// 같은 이름을 가진 캐릭터를 찾았다. 접속을 종료하라는 메시지를 보낸다.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
		}
	}
}

void CGame::CalcExpStock(int iClientH)
{
 BOOL bIsLevelUp;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	
	// !!!!
	// v2.12 2002-2-6 지존도 현재 경험치가 최대 레벨 경험치보다 적으면 경험치를 얻을수 있게 변경 .. v2.15 삭제. 지존도 경험치 얻는다.
	//if ((m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iPlayerMaxLevel])) return;
			
	// 포상과 페널티가 없는 맵 위에 서 있다면 경험치는 올라가지 않는다.
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}
	
	// 그동안 축적 되었던 경험치를 계산한다. 
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;
	
	if (bCheckLimitedUser(iClientH) == FALSE) {
		// 체험판 사용자 제한에 해당되지 않으면 경험치가 올랐다는 통보를 한다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	// 레벨이 올랐는지를 검사한다.
	bIsLevelUp = bCheckLevelUp(iClientH);

	// v2.03 변경 9/1
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel <= 5)) {
		// 초보용 Gold 지급. 레벨 1~5까지 100 Gold 지급.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)100;
		bAddItem(iClientH, pItem, NULL);
	}
	// v2.03 변경 9/1
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20) ) {
		// 초보용 Gold 지급. 레벨 5~20까지 300 Gold 지급.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)300;
		bAddItem(iClientH, pItem, NULL);
	}

}

void CGame::___RestorePlayerRating(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iRating < -10000) m_pClientList[iClientH]->m_iRating = 0;
	if (m_pClientList[iClientH]->m_iRating >  10000) m_pClientList[iClientH]->m_iRating = 0;
}

int CGame::iGetExpLevel(int iExp)
{
 register int i;

	// 경험치가 어느 레벨 수준에 속하는지 판단한다.
	for (i = 1; i <= 201; i++) 
	if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 register int i, iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 채팅을 불가능하게 만들 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// 목표 캐릭터를 찾았다. 	
			
			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else strcpy(cNpcName, "Guard-Neutral");  // <- 이것은 마을이 아니므로 중립 가드를 생성시킨다.
			
			iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
			}
			else {
				// NPC를 생성한다.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {

				wsprintf(G_cTxt, "GM Order(%s): Guard Attack PC(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);

					// 가드를 생성시켰다. 공격 목표를 할당한다.
					bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}

			delete pStrTok;
			return;
		}

		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}

//pegalo aca
void CGame::AdminOrder_SummonAll(int iClientH, char *pData, DWORD dwMsgSize)
{

 char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cLocation[11], cMapName[11];
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		 delete pStrTok;
		 return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;


	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 10)
	memcpy(cLocation, token, 10);
	else memcpy(cLocation, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		 if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, token) == 0)) {
			  RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
		 }

	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cLocation,
	   cLocation, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONALL;
	cp++;

	memcpy(cp, cLocation, 10);
	cp += 10;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}



void CGame::AdminOrder_SummonDemon(int iClientH)
{
 char cName[21], cNpcName[21], cNpcWaypoint[11];	
 register int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
	}
	else {
		// NPC를 생성한다.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Demon");	
		
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// 실패했으므로 예약된 NameValue를 해제시킨다.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// v2.4 GM Log
			wsprintf(G_cTxt, "GM Order(%s): Summon Demon", m_pClientList[iClientH]->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);

		}
	}

}

// v1.4311-3 추가 운영자가 사투장을 예약한다.
void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256];
 class  CStrTok * pStrTok;
 int iNum ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if( m_iFightzoneNoForceRecall == 0 ) {
		m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
	} else {
		m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
	}

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	iNum = atoi(token) - 1;
			
	if ( m_iFightZoneReserve[iNum] != -1) {
		// v2.14 GM Log
		wsprintf(G_cTxt, "GM Order(%s): FightzoneNumber(%d) FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);
		
		m_iFightZoneReserve[iNum] = - 1 ;        // 운영자가 예약한 사투장은 -1 값이 들어간다.
												 // 이제부터 계속 다른 유저는 예약이 불가능하다.
		// 운영자가 사투장 예약에 성공하는 경우 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);
		
	}  else {	// v2.14 GM Log 운영자가 예약한 사투장을 다시 예약하면 예약이 취소된다.
		wsprintf(G_cTxt, "GM Order(%s): FightzoneNumber(%d) Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		// 운영자가 사투장 예약을 취소하는 경우       -3 값을 넘겨준다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);

	}
	delete pStrTok;	
	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;




	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	
	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 곧 채팅을 불가능하게 만들 사용자 이름 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// 목표 캐릭터를 찾았다. 강제로 접속을 끊는다.	
			if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// v1.22 강제 접속 종료된 클라이언트는 블리딩 아일랜드로 텔레포트된다.
				// v2.14 Admin Level 낮은 GM은 높은 GM 을 강퇴시킬수 없다. 
				if (m_pClientList[iClientH]->m_iAdminUserLevel < m_pClientList[i]->m_iAdminUserLevel) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
					delete pStrTok;
					return ;
				}

				wsprintf(G_cTxt, "GM Order(%s): Close Connection PC(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);

				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);
#ifdef DEF_TAIWANLOG
				_bItemLog(DEF_ITEMLOG_CLOSECONN,i, m_pClientList[iClientH]->m_cCharName,NULL);
#endif
				DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
			}

			delete pStrTok;
			return;
		}
		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



// v1.4311-3 추가및 변경 함수  길드원 강퇴 명령 void CGame::UserCommand_BanGuildsman
void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
		// 길드 마스터가 아니어서 이 기능을 사용할수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// token이 길드를 탈퇴시킬 사람 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) {
			// 목표 캐릭터를 찾았다. 강제로 길드를 강퇴 시킨다. 

			if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
				// 자신의 길드원이 아니라 허락이 불가능하다.
				
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
				delete pStrTok;
				return;
			}
			// 길드 정보 화일에서 탈퇴한 길드원의 이름을 삭제한다.
			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);

#ifdef DEF_TAIWANLOG
			_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
#endif

			// 다른 길드원들에게 길드원의 탈퇴를 알린다.
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
			// 길드의 이름을 초기화해 준다.
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;

			// 길드 마스터에게 강제 탈퇴에 성공했음을 알리는 메시지를 보내준다.
		    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
			
			// 강제 탈퇴된 길드원에게 강제 탈퇴 되었음을 알린다.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);
		
			// 특성이 바뀌므로 외양을 새로 보낸다. 
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
		
			delete pStrTok;
			return;
		}
		// 현재 접속중이 아니다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, DWORD dwMsgSize)
{

}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
 register int i, iDynamicHandle;

	// 맵의 위치가 물인지 확인한다. 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE) return NULL;

	for (i = 1; i < DEF_MAXFISHS; i++) 
	if (m_pFish[i] == NULL) {
		// 빈 공간에 물고기를 만든다.
		m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
		if (m_pFish[i] == NULL) return NULL;
 		
		// Dynamic Object를 발생시킨다. Owner에 Fish 인덱스를 넣는다.
		switch (pItem->m_sIDnum) {
		case 101: // 빨강물고기
		case 102: // 초록물고기
		case 103: // 노랑물고기
		case 570:
		case 571:
		case 572:
		case 573:
		case 574:
		case 575:
		case 576:
		case 577:	
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
			break;
		default: 
			// 물고기가 아닌 다른 아이템 
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pFish[i];
			m_pFish[i] = NULL;
			return NULL;
		}
		m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMapList[cMapIndex]->m_iCurFish++;

		return i;
	}

	return NULL;
}


BOOL CGame::bDeleteFish(int iHandle, int iDelMode)
{
 register int i, iH;
 DWORD dwTime;
		
	if (m_pFish[iHandle] == NULL) return FALSE;
	
	dwTime = timeGetTime();

	// 연관되어 있는 DynamicObject를 삭제한다.
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;
	
	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		// 맵에서 삭제한다.
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}

	// 이 물고기와 연결되어 있는 플레이어들에게 물고기가 사라져 낚시가 취소되었음을 알려준다. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			// 메시지 전송 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
			ClearSkillUsingStatus(i); // v1.4 낚시 스킬을 클리어한다.
 		}
	}
	
	// 삭제한다.
	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;

	return TRUE;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
 register int i;
 short sDistX, sDistY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= DEF_MAXMAPS)) return 0;

	// 맵의 특정 위치 내에 물고기 다이나믹 오브젝트가 있는지 판단한다. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
		sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);
		
		if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
			((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
			(sDistX <= 2) && (sDistY <= 2)) {
			// 물고기 다이나믹 오브젝트를 찾았다. 이제 이 다이나믹 오브젝트 인덱스를 소유한 Fish의 인덱스를 반환한다. 

			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

			// 이미 낚시모드에 들어가 있는 캐릭터는 중복 동작이 불가능.
			if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
			if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
			// 이제 캐릭터에게 낚시 모드를 시작할 것을 할당한다.
			m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
			m_pClientList[iClientH]->m_iFishChance = 1;
			// 이 캐릭터는 낚시 스킬을 사용중임을 설정.
			m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
				          m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

			// 카운트 증가 
			m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;
			
			return i;
		}
	}

	return 0;
}

void CGame::FishProcessor()
{
 register int i, iSkillLevel, iResult, iChangeValue;

	// 이벤트 낚시 모드가 할당된 플레이어들을 처리한다.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && 
			(m_pClientList[i]->m_iAllocatedFish != NULL)) {
		
			if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) break;	
	
			// 이 플레이어에게 할당된 물고기가 있다. 낚을 확률을 재계산하여 통보해 준다. 
			// 낚시 기술의 스킬 
			iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
			// 물고기의 난이도에 따라 스킬 레벨이 떨어진다. 
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;
			
			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult)	{
				// 스킬 주사위 굴림 성공. 낚을 확률 증가.
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
			else if (iSkillLevel < iResult) {
				// 스킬 주사위 굴림 실패. 낚을 확률 감소.	
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
		}
	}
}



void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256] ;
 class  CStrTok * pStrTok;
 class  CItem   * pItem;
 register int tX, tY, iType;
 int iItemID = 0 ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		// 이 좌표에 물고기를 만든다.
		pItem = new class CItem;
		if (pItem == NULL) {
			delete pStrTok;
			return;
		}
		// v2.17 2002-7-31 아이템을 아이템 고유번호로 생성할 수 있게 한다.
		iItemID = 100 ;

		if (_bInitItemAttr(pItem, iItemID) == TRUE) {
   			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);
			// v2.17 2002-8-5 메모리 누수 발견하여 수정함
			delete pItem;
			pItem = NULL ;
		}
		else {
			delete pItem;
			pItem = NULL ;
		}
   	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256] ;
 class  CStrTok * pStrTok;
 register int dX, dY;
 BOOL   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.13 옵저버 모드이면 텔레포트 않되게 수정 
	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) return ;

	// v2.13 운영자 레벨 조절
	if (memcmp(m_pClientList[iClientH]->m_cCharName, "Apuestas", 10) != 0) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
			// Admin user level이 낮아서 이 기능을 사용할 수 없다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
			return;
		}
		if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}



	bFlag = FALSE;
	if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("elvine", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
	if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("default", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvjail", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;

	if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;

	if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
	// v1.4334 운영자 텔레포트 
	if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;

	if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;

	if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;

	if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
	if (strcmp("icebound", cMapName) == 0) bFlag = TRUE;
	// v2.95
	if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE;
	if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE;
	if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE;
	if (strcmp("maze", cMapName) == 0) bFlag = TRUE;
	if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
	if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE;
	// v3.51
	if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("GodH", cMapName) == 0) bFlag = TRUE;
	if (strcmp("HRampart", cMapName) == 0) bFlag = TRUE;
	if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
	if (strcmp("Extreme", cMapName) == 0) bFlag = TRUE;
	if (strcmp("MBarracks", cMapName) == 0) bFlag = TRUE;
	if (strcmp("PVP", cMapName) == 0) bFlag = TRUE;
	if (strcmp("Whouse", cMapName) == 0) bFlag = TRUE;
	if (strcmp("deathmach", cMapName) == 0) bFlag = TRUE;
	if (strcmp("Isla", cMapName) == 0) bFlag = TRUE;
	if (bFlag == FALSE) { delete pStrTok ; return; }

	if ((dX == - 1) && (dY == -1))
			wsprintf(G_cTxt, "GM Order(%s): teleport MapName(%s)",m_pClientList[iClientH]->m_cCharName, cMapName);
	else wsprintf(G_cTxt, "GM Order(%s): teleport MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName, cMapName,dX,dY);
	bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);

	RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
   	
	delete pStrTok;
	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
 register int iResult, iFishH;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

	// 낚시 스킬 사용중임을 해제시킨다.
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {
		// 이 물고기를 낚는데 성공하였다!
		
		// 경험치 증가 
		GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 6)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		// 스킬 증가 
		/*CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);*/

		// 아이템 포인터를 얻어온다.
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;

		// 낚은 아이템을 바닥에 떨어뜨린다.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                       m_pClientList[iClientH]->m_sY, 
															       pItem);

		// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		// 낚시 성공 메시지 전송 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
				
		// 물고기를 지우고 리턴 
		bDeleteFish(iFishH, 1); // <- 여기서 다른 낚시꾼들에게 메시지가 전송될 것이다.
		return;
	}

	// 낚는데 실패! 
	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);
	
	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}


void CGame::FishGenerator()
{
	class CItem * pItem;
	register int i, iP, tX, tY, iRet;
	int iItemID = 0 ; 
	short sDifficulty;
	DWORD dwLastTime;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1;
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1,3) - 2);
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1,3) - 2);

			pItem = new class CItem;
			if (pItem == NULL) break;
		
			// 만들 물고기 종류와 난이도, 지속 시간을 결정한다.

			switch (iDice(1,9)) {
			case 1:	iItemID = 570 ; sDifficulty = iDice(1,10) +  5; break;	// 적색잉어 
			case 2:	iItemID = 571 ; sDifficulty = iDice(1,5) + 15;  break;	// 녹색잉어 
			case 3:	iItemID = 572 ; sDifficulty = iDice(1,10) + 20; break;	// 금색 잉어 
			case 4:	iItemID = 573 ; sDifficulty = 1;  break;				// 붕어
			case 5:	iItemID = 574 ; sDifficulty = iDice(1,15) + 1;  break;  // 청색돔
			case 6:	iItemID = 576 ; sDifficulty = iDice(1,18) + 1;  break;  // 적색돔
			case 7:	iItemID = 575 ; sDifficulty = iDice(1,12) + 1;  break;	// 연어
			case 8:	iItemID = 577 ; sDifficulty = iDice(1,10) + 1;  break;	// 숭어 
			case 9:
				// 가끔 가다 낚을 수 있는 특수 아이템 
				switch (iDice(1,150)) {
				case 1:
				case 2:
				case 3:
					iItemID = 390;  // 강력녹색시약 
					sDifficulty = iDice(4,4) + 20;
					break;

				case 10:
				case 11:
					iItemID = 391;  // 초강력녹색시약 
					sDifficulty = iDice(4,4) + 40;
					break;

				case 20:
					iItemID = 5;  // 단검+2 
					sDifficulty = iDice(4,4) + 5;
					break;

				case 30:
					iItemID = 19;  // 롱-소드+2 
					sDifficulty = iDice(4,4) + 10;
					break;

				case 40:
					iItemID = 27;  // 시미타+2 
					sDifficulty = iDice(4,4) + 15;
					break;

				case 50:
					iItemID = 36;  // 레이피어+2 
					sDifficulty = iDice(4,4) + 35;
					break;

				case 60:
					iItemID = 56;  // 플램버그+2 
					sDifficulty = iDice(4,4) + 40;
					break;

				case 70:
					iItemID = 73;  // 워-액스+2 
					sDifficulty = iDice(4,4) + 30;
					break;

				case 90:
					iItemID = 351;  // 루비 
					sDifficulty = iDice(4,4) + 30;
					break;

				case 95:
					iItemID = 350;  // 다이아몬드
					sDifficulty = iDice(4,4) + 30;
					break;
				}
				break;
			}

			dwLastTime  = (60000 * 10) + (iDice(1,3) - 1)*(60000 * 10);
		
			if (_bInitItemAttr(pItem, iItemID) == TRUE) {
   				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime);
			}
			else {
				delete pItem;
				pItem = NULL;
			}
		}
	}													  
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
 register int ix, iy, iRet;
 class CTile * pTile;	

	// 처리 속도를 높이기 위해 함수를 콜하지 않는다.
	if ((cMapIndex < 0)	|| (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
	for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
		if ( (ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			 (iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			// 좌표를 벗어나므로 처리하지 않는다.	
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
				iRet++;
		}
	}

	return iRet;
}


void CGame::WhetherProcessor()
{
 char cPrevMode;
 int i, j, iWeather;
 DWORD dwTime;
 SYSTEMTIME SysTime;

		dwTime = timeGetTime();
  
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) {
			// 날씨가 변동되어야 하는 맵이라면 처리한다.
			cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			// 날씨의 변동을 계산한다. 
			if (m_pMapList[i]->m_cWhetherStatus != NULL) {
				// 현재 날씨가 작동중이다. 멈출때가 되었으면 멈춘다.
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = NULL;
			}
			else {
				// 조건에 따라 날씨를 작동시키던가 말던가 결정한다. 
				// 2002-7-4 비올 확률을 낮춘다.
				if (iDice(1,300) == 13) {
					// 일단 간단한 조건으로 작동 시작 
#if defined(DEF_WINTER)
					m_pMapList[i]->m_cWhetherStatus = iDice(1,3) + 3; // 1~3 비 4~6 : Snow
#else				
					iWeather = iDice(1,3);
					GetLocalTime(&SysTime);
					if ((SysTime.wMonth == 12)&&(m_cDayOrNight == 3)) iWeather += 3;
						
					m_pMapList[i]->m_cWhetherStatus = iWeather; // 1~3 비 4~6 : Snow
#endif
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
				}
			}

			// icebound 맵에서는 항상 눈이 내린다.
			if (m_pMapList[i]->m_bIsFixedSnowMode == TRUE)
			{
				m_pMapList[i]->m_cWhetherStatus = iDice(1,3) + 3;
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
			}
			
			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
				// 날씨가 변경되었다. 
				for (j = 1; j < DEF_MAXCLIENTS; j++) 
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
					SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);	
			}
		
		}
	}
}

// v1.4311-3 추가 함수  사투장 예약 초기화및 사용자에게 예약이 취소 되었음 알린다.FightzoneReserveProcessor 
void CGame::FightzoneReserveProcessor()
{
 register int i;

// v2.02 로그 삭제 
//	PutLogList("CAN FIGHTZONE RESERVE!!");
			
	// 예약된 사투장들을 초기화 시킨다.  10개의 사투장의 입장을 허락한다.
	for (i=0 ; i < DEF_MAXFIGHTZONE ; i++ ) {

		if (m_iFightZoneReserve[i] == -1 ) continue ; // 운영자가 예약한 사투장은 예약이 불가능하다.
		m_iFightZoneReserve[i] = 0 ;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		// 사투장을 예약한 유저인지를 확인한다. 
		// 사투장을 예약한 유저에게 사투장 예약이 취소되었음을 알려준다.
		if((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	}
}




int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
 int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		// 전기계열 마법의 경우 비가 오면 보너스 타격치가 붙는다. 반면 파이어 계열 마법의 타격치는 낮아진다.
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			//iWheatherBonus = 2*cWheatherStatus;
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			//iWheatherBonus = -2*cWheatherStatus;
			iWheatherBonus = -1;
			break;
		}
   		break;
	}

	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// 본인이 범죄자이하면 상대방이 마을이 같은 경우 위협. 다르면 적 
		if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
			(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
			 iRet = 7; // 위협 
		else iRet = 2; // 적   
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// 상대방이 범죄자이하면
		if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
				(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
			 iRet = 6; // 마을이 같으면 PK
		else iRet = 2; // 다르면 그냥 적 
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL)) {
				// 둘 다 0(Traveler)이 아니면 적이다.
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}	
		else {
			// 아군이다. 길드원여부를 판단.
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// 길드 이름이 같다. 
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					 iRet = 5;	// 길드 랭크가 0. 길드마스터이다.
				else iRet = 3;	// 같은 길드원
			}
			else 
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// 길드 위치는 같고 길드 이름이 다르다.
				iRet = 4; // 다른 길드원 
			}
			else iRet = 1; // 그냥 같은편 
		}
	}

	return iRet;
}

int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	int iRet;

	if (m_pClientList[iWhatH] == NULL) return 0;
	if (m_pClientList[iRecvH] == NULL) return 0;

	iRet = 0;

	/*if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE &&
		m_pClientList[iWhatH]->m_iGuildRank != -1 && m_pClientList[iRecvH]->m_iGuildRank != -1 &&
		memcmp(m_pClientList[iWhatH]->m_cGuildName,m_pClientList[iRecvH]->m_cGuildName,20) != 0) {
			iRet = 8;
		}*/

		if (m_pClientList[iWhatH]->m_iPKCount != 0)
			iRet = 8;

		if (m_pClientList[iWhatH]->m_cSide != DEF_NETURAL)
			iRet = iRet | 4;

		if (m_pClientList[iWhatH]->m_cSide == DEF_ARESDEN)
			iRet = iRet | 2;

		if (m_pClientList[iWhatH]->m_bIsHunter == TRUE)
			iRet = iRet | 1;

		return iRet;
}


int CGame::iGetNpcRelationship(int iWhatH, int iRecvH)
{
	if (m_pClientList[iRecvH] == NULL) return 0;
	if (m_pNpcList[iWhatH] == NULL) return 0;

	int rtn = 0x0000;

	switch (m_pNpcList[iWhatH]->m_cSide) {
	case 0:	// 중립
		break;

	case 10: // 모두를 공격하는 NPC
		rtn |= 0x0001 << 3;
		break;

	case 1:	// aresden 소속 (경비병, 상점들의 주인들)
		rtn |= 0x0001 << 2;
		rtn |= 0x0001 << 1;
		break;

	case 2:	// elvine 소속 (경비병, 상점들의 주인들)
		rtn |= 0x0001 << 2;
		break;
	}

	return rtn;
}


/*
int CGame::iGetNpcRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	// 플레이어와 NPC의 관계를 구해 NPC에게 준다.
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iOpponentH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// 본인이 범죄자이하면 NPC는 모두 적이다.
		iRet = 2;
	}
	else {
		// 본인은 무고하다. 
		if (m_pNpcList[iOpponentH]->m_cSide == 0)
			iRet = 0; // 몹이 중립이라면 무조건 중립 
		else
		if (m_pNpcList[iOpponentH]->m_cSide == 10) 
			iRet = 2; // 몹이 일반몹이라면 무조건 적 
		else if (m_pClientList[iClientH]->m_cSide == m_pNpcList[iOpponentH]->m_cSide) 
			iRet = 1;  // 소환몹과 나와의 편이 같다면 같은편 
		else if (m_pClientList[iClientH]->m_cSide == 0) 
			 iRet = 0; // 내가 중립이니 소환몹과는 중립 
		else iRet = 2; // 소환몹과 내가 편이 다르니깐 소환몹은 적 
	}
	
	return iRet;
}
*/

// 2002-11-15 재작성
int CGame::iGetPlayerRelationship_SendEvent(int iClientH, int iOpponentH)
{
 int iRet;
	
	// 여기서 사이드 계산하는 방법은 관점이 다르므로 주의한다. 
    // 내 데이터를 작성하는 것이 아니라 다른 이에게 보내는 데이터를 작성하는 것임을 주의.
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// 내가 범죄자이하면 상대방에게는 마을이 다를 경우 적, 아니면 PK로 인식된다.
		if ((m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) &&
			(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
			 iRet = 2; // 적 
		else iRet = 6; // PK 
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// 내가 무고하고 상대방이 범죄자이하면 상대방에게 마을이 다를 경우 적, 아니면 위협으로 인식된다.
		if ((m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) &&
			(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL)) 
			 iRet = 2; // 적
		else {
			iRet = 7; // 위협
		}
	}
	else {
		// 상대방도 나도 범죄자가 아니다. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// 나의 편과 상대방의 편이 다르다. 
			if ((m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL)
				&& ((m_pClientList[iClientH]->m_bIsHunter != TRUE)) 
				) {
				// 나도 중립이 아니고 상대방도 중립이 아니라면 0(Traveler)이 아니면 적으로 인식된다.
				iRet = 2;
			}
			else {
				// 한쪽이 중립이므로 상대방에게 중립으로 인식된다.
				iRet = 0;
			}
		}	
		else {
			// 같은편. 둘다 중립이거나 같은 마을 소속. 길드원여부를 판단.
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) && 
				(m_pClientList[iClientH]->m_cSide == DEF_NETURAL)) {
				iRet = 0; // 둘다 중립이므로 중립.
			}
			else			
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// 길드 이름이 같다. 
				if (m_pClientList[iClientH]->m_iGuildRank == 0)
					 iRet = 5;	// 내 길드 랭크가 0. 길드마스터로 상대방에게 인식된다.
				else iRet = 3;	// 같은 길드원
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// 길드 이름은 다르나 길드 위치는 같고 길드 이름이 다르다.
				iRet = 4; // 다른 길드원 
			}
			else {
				iRet = 1; // 그냥 같은편 
			}
		}
	}

	return iRet;
}


int CGame::iGetNpcRelationship_SendEvent(int iNpcH, int iOpponentH)
{
 int iRet;
	
	// 여기서 사이드 계산하는 방법은 관점이 다르므로 주의한다. 
    // 내(NPC) 데이터를 작성하는 것이 아니라 다른 이에게 보내는 데이터를 작성하는 것임을 주의.
	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iNpcH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// 상대방이 범죄자이하면 편이 같으면 위협으로 아니면 NPC 적으로 인식된다.
		if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[iOpponentH]->m_cSide)
			 iRet = 7; 
		else iRet = 2;
	}
	else {
		if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// 몹의 편과 상대방의 편이 다르다.
			if (m_pNpcList[iNpcH]->m_cSide == 10) 
				iRet = 2; // 몹이 일반 몹이다. 상대방에게는 적으로 인식된다.
			else 
			if (m_pNpcList[iNpcH]->m_cSide == 0) iRet = 0; // 몹이 중립이면 무조건 중립 	
			else 
			if (m_pClientList[iOpponentH]->m_cSide == 0) 
				 iRet = 0; // 상대방이 중립이다. 소환몹과 중립과의 관계는 중립. 
			else iRet = 2; // 소환몹과 시민 이상인데 편이 다르므로 적 
			
		}
		else iRet = 1; // 같은 편 
	}

	return iRet;
}


int CGame::iGetMapIndex(char * pMapName)
{
 register int i, iMapIndex;
 char cTmpName[256];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) 
			iMapIndex = i;
	}

	return iMapIndex;
}



int CGame::_iForcePlayerDisconect()
{
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		if (m_pClientList[i]->m_bIsInitComplete == TRUE)
			 DeleteClient(i, TRUE, TRUE);
		else DeleteClient(i, FALSE, FALSE);
	}

	return 0;
}

void CGame::SpecialEventHandler()
{
 DWORD dwTime;
 
	// 특별한 이벤트를 생성한다. 
	dwTime = timeGetTime();

	// v2.17 몹 이벤트 시간이 5분으로 단축 되었으므로 데몬나올 학률도 감소 시킴 
	if ((dwTime - m_dwSpecialEventTime) < DEF_MOBEVENTTIME) return;
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = TRUE;
	
	switch (iDice(1,350)) {
	case 98: m_cSpecialEventType = 2; break; // 데몬 혹은 유니콘이 나올 가능성은 30분에 1번 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cIP[21], cInfoString[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		// token이 IP address이다. 
		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
			// 요구한 주소와 일치하는 클라이언트 발견. 
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
				     m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					 m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					 m_pClientList[i]->m_iLevel, NULL/*m_pClientList[i]->m_cAccountStatus*/,
					 m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}
	}

	
	delete pStrTok;
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// 안전 공격 모드를 토글한다. 
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		 m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	// iNpc 근방에 있는 전투중이 아닌 NPC에게 도움을 요청한다. 
	if (m_pNpcList[iNpcH] == NULL) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && 
			(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) &&
			(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) {
			
			// 조건에 부합하는 NPC를 찾았다. 
			m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
			m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

			return;
		}
	}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[ i ] != NULL) && (memcmp(m_pClientList[ i ]->m_cAccountName, pAccountName, 10) == 0)) {
		wsprintf(G_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[ i ]->m_cCharName, m_pClientList[ i ]->m_cAccountName, wCount);
		PutLogList(G_cTxt);
		SendNotifyMsg(NULL, i, DEF_NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		if (memcmp(token, "off", 3) == 0) {
			m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;
		}
		m_pClientList[iClientH]->m_sType = atoi(token);
	}
	
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	delete pStrTok;
}

void CGame::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.13 운영자 레벨 조절
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// 이 값이 문자 '1'이면 투명으로 세트. '0'이면 해제 
		if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else
		if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

BOOL CGame::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) 
		if (MessageBox(NULL, "La informacion no guardo, desea cerrar el servidor?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	else return TRUE;
		
	return FALSE;
}

void CGame::_CheckAttackType(int iClientH, short *spType)
{
 WORD wType;

	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:	
		// 화살이 없다면 화살 Effect는 넣지 않는다. 
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		// 활 공격인데 장착한 무기가 활이 아니다. 일반 공격으로 전환.
		if (wType < 40) *spType = 1;
		break;

	case 20:
		// 맨손 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21: 
		// 단검 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22: 
		// 펜싱 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23: 
		// 장검 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24: 
		// 도끼 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25: 
		// 활 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		// 활 공격인데 장착한 무기가 활이 아니다. 일반 공격으로 전환.
		if (wType < 40) *spType = 1;
		break;
	case 26: 
		// v2.16 2002-5-27 해머 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;

	case 27: 
		// v2.16 2002-5-27 지팡이 필살기 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}


void CGame::ReqCreatePortionHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cPortionName[21], cData[120];
 int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
 short * sp, sItemIndex[6], sTemp;
 short  sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;
	// 포션의 재료 인덱스를 받았다. 이 재료가 포션을 만들 수 있는 조합인지 확인한다. 

	// 데이터가 유효한 아이템 인덱스인지 체크한다.
	for (i = 0; i < 6; i++) {
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) {
		// 먼저 이미 있는 리스트인지 검색 
		bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) {
			// 있다. 카운트 증가 
			sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) {
			// 없다. 새로 추가한다.
			for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) {
				sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;
		}
	}
	
	// 아이템 리스트가 만들어 졌다. 소비되는 아이템이라면 갯수를 확인한다. 
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) {
		if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		// 아이템이 갯수가 오버해도 리턴.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
	}

	// 아이템을 아이템 아이디 번호가 큰 순서부터 정렬한다. Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
				(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
				// 바꾼다.
				sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
			}
		}
	}

	//testcode
	/*
	char cTemp[120];
	char cTxt1[120];
	char cTxt2[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	for (i = 0; i < 6; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		if (sItemIndex[i] != -1)
			 wsprintf(cTemp, "(%d) ", m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
		else strcpy(cTemp, "(*)");
		strcat(cTxt1, cTemp);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "(%d) ", sItemNumber[i]);
		strcat(cTxt2, cTemp);
	}
	PutLogList(cTxt1);
	PutLogList(cTxt2);
	*/

	// 데이터에 이상이 없음이 확인되었다. 포션 제작 배열을 작성한다. 
	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	//testcode
	/*
	char cTemp[120], cTxt1[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	for (i = 0; i < 12; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d", sItemArray[i]);
		strcat(cTxt1, cTemp);
	}
	PutLogList(cTxt1);
	*/

	// sItemArray의 12가지 배열과 일치하는 포션을 리스트에서 검색한다. 
	ZeroMemory(cPortionName, sizeof(cPortionName));

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pPortionConfigList[i] != NULL) {
		bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;
		
		if (bFlag == FALSE) {
			// 포션 조합이 일치하는 리스트를 발견했다. 
			ZeroMemory(cPortionName, sizeof(cPortionName));
			memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
			iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
			iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
		}
	}

	// 조합이 일치하는 포션이 없으므로 무시
	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, NULL, NULL, NULL, NULL);
		return;
	}

	// 플레이어의 연금술 스킬 수준
	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		// 플레이어의 스킬이 낮아 만들 수 없는 포션이다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// 포션의 제작 난이도에 따라 성공률을 조정한다.
	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

#if defined(DEF_TESTSERVER)
	iSkillLevel = 100;
#else
	// 2002-09-11 #1 연금 스킬 100일때 확률 5% 증가
	if( m_pClientList[iClientH]->m_cSkillMastery[12] == 100 )
		iSkillLevel += 5;
#endif

	iResult = iDice(1,100);
	if (iResult > iSkillLevel) {
		// 스킬 실패 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// v2.17 2002-7-21 연금술에 레벨 제한 추가 
	/*
	if ((m_pClientList[iClientH]->m_iLevel < 20) && (iSkillLevel > 80 )) {
		// 스킬 실패 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}
	*/


	// 모든 조건이 만족되어 포션을 만들 수 있다. 스킬카운트도 증가 
	/*CalculateSSN_SkillIndex(iClientH, 12, 1);*/
	
	// 만족하는 포션 조합이 있다면 strlen(cPortionName)이 0이 아니다. 이미 검사했지만 
	if (strlen(cPortionName) != 0) {
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;

		// 포션을 제작했으므로 재료를 없앤다.
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				// v1.41 !!!
				SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
				             m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
			else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONSUCCESS, NULL, NULL, NULL, cPortionName);
		// v1.41 소량의 경험치 증가 
		GetExp(iClientH, iDice(2, (iDifficulty/3))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty/3));

		if ((_bInitItemAttr(pItem, cPortionName) == TRUE)) {
			// 포션 아이템이 만들어졌다. 플레이어의 아이템 리스트에 등록한다. 만약 공간이 없거나 
			// 무게가 모자라면 발 밑에 떨어져야 한다.
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				ZeroMemory(cData, sizeof(cData));
				// 아이템을 획득했다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				
				// 1개 획득했다. Amount가 아니다!
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;	// 수량을 입력 
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				
				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
				cp++;
				*/
				
				if (iEraseReq == 1) delete pItem;
				
				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				
				// 비싼 아이템을 받았다면 데이터를 저장한다. 
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {
				// 더이상 아이템을 보관할 수 없는 상태이다.
				// 아이템을 서있는 위치에 버린다. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				
				// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				
				// 더이상 가질수 없다는 메시지를 보낸다.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
	}
}



BOOL CGame::_bDecodePortionConfigFileContents(char *pData, DWORD dwMsgSize)
{char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iPortionConfigListIndex = 0;
 int  iCraftingConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:	// Potion's index
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete pContents; delete pStrTok; return FALSE;
					}					
					if (m_pPortionConfigList[atoi(token)] != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[atoi(token)] = new class CPortion;
					iPortionConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // Potion's name
					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default: // m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14: // m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // Mini Skill
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:// Difficulty
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;			
				
			case 2: // Crafting
				switch (cReadModeB) {
				case 1:	// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format(1).");
						delete pContents; delete pStrTok; return FALSE;
					}					
					if (m_pCraftingConfigList[atoi(token)] != NULL) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Duplicate crafting number.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[atoi(token)] = new class CPortion;
					iCraftingConfigListIndex = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					ZeroMemory(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, sizeof(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName));
					memcpy(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default: // m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14: // m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15: // 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:// 
					if (_bGetIsStringIsNumber(token) == FALSE) 
					{	PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
						delete pContents; delete pStrTok; return FALSE;
					}
					m_pCraftingConfigList[iCraftingConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			default: 
				break;
			}
		}else 
		{	if (memcmp(token, "potion", 5) == 0) 
			{	cReadModeA = 1;
				cReadModeB = 1;
			}	
			if (memcmp(token, "CraftItem", 9) == 0) 
			{	cReadModeA = 2;
				cReadModeB = 1;
			}			
		}
		token = pStrTok->pGet();
	}	
	delete pStrTok;
	delete []pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) 
	{	PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
		return FALSE;
	}
	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
	PutLogList(cTxt);
	wsprintf(cTxt, "(!) CRAFTING(Total:%d) configuration - success!", iCraftingConfigListIndex);
	PutLogList(cTxt);
	return TRUE;
}

void CGame::LocalSavePlayerData(int iClientH)
{
 char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
 int    iSize;
 FILE * pFile;
 SYSTEMTIME SysTime;

	// 로그 서버로의 연결이 종료되어 임시로 게임서버 내의 폴더에 저장한다. 
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = new char[30000];
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character");

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	// 디렉토리를 만든다.
	_mkdir(cCharDir);
	_mkdir(cDir);

	// (char*)cp 부터 (dwMsgSize - 36)크기까지가 파일에 저장될 데이터이다.
	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete []pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}
	
	if (pFile != NULL) fclose(pFile);
	delete []pData;
}

void CGame::MineralGenerator()
{
 register int i, iP, tX, tY, iRet;
 
	for (i = 0; i < DEF_MAXMAPS; i++) {
		// v2.12 2002-2-6 미네럴 생성 루틴 변경 ..
		if ((iDice(1,6) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == TRUE) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

		   	iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}		
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
 register int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	
	for (i = 1; i < DEF_MAXMINERALS; i++) 
	if (m_pMineral[i] == NULL) {
		// 빈 공간에 광물덩이를 만든다.
		iMineralType = iDice(1, cLevel);
		m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
		if (m_pMineral[i] == NULL) return NULL;
 		
		iDynamicHandle = NULL;
		switch (iMineralType) {
		case 1: // 광물류
		case 2:
		case 3:
		case 4:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
				
		case 5: // 보석류 
		case 6:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
			break;
		
		default:
			// 에러 방지용 코드 
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pMineral[i];
			m_pMineral[i] = NULL;
			return NULL;
		}
		m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMineral[i]->m_cMapIndex = cMapIndex;
		
		// 난이도와 수량을 입력한다.
		switch (iMineralType) {
		case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
		case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
		case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
		case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
		case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
		default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		}

		// 맵의 미네랄 수 증가
		m_pMapList[cMapIndex]->m_iCurMineral++;
	
		return i;
	}

	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
 short sType;
 DWORD dwRegisterTime;
 int   iDynamicIndex, iSkillLevel, iResult;
 int   iMineralID ; 
 class CItem * pItem;
 WORD  wWeaponType;
	
	if (m_pClientList[iClientH] == NULL)  return;

	// v2.17 2002-6-29 광물 캘때 투명 모드였다면 마법 Casting시에 해제된다.
	if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}


	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);
	
	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		// 광물채취를 시도한 캐릭터의 조건을 살핀다. 곡괭이를 들고 있는가? 광물 채취 스킬은? 
		// 곡괭이에 해당하는 외형이면 통과 
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
			// 픽액스를 들고 있다. 광물 채취 가능 
		}
		else return;

		// 전투 모션이 아니더라도 리턴 
		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;
				
		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;
		// 캐는 광물의 난이도만큼 스킬을 낮춘다.
		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			// 확률은 성공했다. 광물채취 기술 증가 
			//CalculateSSN_SkillIndex(iClientH, 0, 1);
						
			// 플레이어의 발 밑에 광물을 떨어뜨린다.
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) {
				case 1: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
						case 3:    
							iMineralID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 4:    
							iMineralID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 5:
							iMineralID = 507; // BlondeStone
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
							break;
					} 
					break; 

				case 2: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
							iMineralID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 3:    
						case 4:    
							iMineralID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 5:
							if (iDice(1,3) == 2) { 
								iMineralID = 356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							} 
							else { 
								iMineralID = 354; // GoldNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							} 
							break; 
					} 
					break; 
			case 3:
				switch (iDice(1,6)) {
				case 1: 
					iMineralID = 355 ;  // 석탄 
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 2: 
				case 3:	
				case 4:	
				case 5:
					iMineralID = 357 ;  // 철광석
					GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					break;
				case 6:
					if (iDice(1,8) == 3) {
						if (iDice(1,2) == 1) {
							 iMineralID = 356 ;  // 은덩이
							 GetExp(iClientH, iDice(2, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,4);
						}
						else {
							iMineralID = 357 ;  // 철광석
							GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
						}
					}
					else {
						iMineralID = 357 ;  // 철광석
						GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
					}
					break;
				}
				break;
                  case 4: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
							iMineralID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 3:
						case 4:
							iMineralID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 5: 
							switch(iDice(1,5)){
							case 1:
							case 2:
								iMineralID = 354; // GoldNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,5);
								break;
							case 3:
							case 4:
								iMineralID =  356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
								break;
							case 5:
								iMineralID = 508; // Mithral
								m_pClientList[iClientH]->m_iExpStock += iDice(1,15); 
								break;
							}
							break; 
					}
					break;
			case 5: 
				switch (iDice(1,18)) {
				case 3:
					iMineralID =  352;  // 싸파이어
					GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					break;
				default:
					iMineralID =  358;  // 수정
					GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					break;
				}
				break;
			case 6: 
				switch (iDice(1,5)) {
				case 1: 
					if (iDice(1,6) == 3) {
						iMineralID =  353;  // 에머랄드
						GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
					break;
				case 2: 
					if (iDice(1,6) == 3) {
						iMineralID =  352;  // 싸파이어
						GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
					break;
				case 3: 
					if (iDice(1,6) == 3) {
						iMineralID =  351;  // 루비
						GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
					break;
				case 4: 
					iMineralID =  358;  // 수정
					GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					break;
				case 5: 
					if (iDice(1,12) == 3) {
						iMineralID =  350;  // 다이아몬드
						GetExp(iClientH, iDice(3, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,5);
					}
					else {
						iMineralID =  358;  // 수정
						GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
					}
				}
				break;
			}
			
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iMineralID) == FALSE) {
				delete pItem;
			}
			else {
				// 아이템을 서있는 위치에 버린다. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                     m_pClientList[iClientH]->m_sY, pItem);
				// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
						                    pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				//testcode
//				wsprintf(G_cTxt, "Mining Success: %d player %s", iMineralID,m_pClientList[iClientH]->m_cCharName); 
//				PutLogEventFileList(G_cTxt);
			}

			// 광물의 남은 량을 줄이고 0인경우 삭제한다.
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				// 광물이 모두 소모되었다. Delete Mineral 
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				// 동적 객체 삭제
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;

	default: 
		break;
	}
}


BOOL CGame::bDeleteMineral(int iIndex)
{
 int iDynamicIndex;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMineral[iIndex] == NULL) return FALSE;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		                        m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
								m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	// 맵에서 광물 동적 객체를 삭제한다.
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	// 광물이 사라졌으므로 이동이 가능하게 한다. 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);
			
	// 광물 개체 수 감소 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	// 광물 객체 삭제 
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;

	return TRUE;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
 char cRewardName[21], cTargetName[21];
 int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1:	// 길드홀 
		break;
	case 2:	// 일반 상점 
		break;
	case 3:	// 무기 상점
		break;
	case 4:	// 시청
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5:	// 창고
		break;
	case 6:	// 마법사타워
		break;

	case 32: // 유니콘
		break;
	case 67:
	case 68:
	case 69: // 도우미 NPC
		break;

	case 21: // 경비 
		// 경비병과의 대화는 별도로 처리한다. 퀘스트와 연관이 없을 수 있으므로. 
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return; // Quest 번호가 1000을 넘어서면 무시한다.
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		// 할당된 퀘스트가 있다.
		if (iRewardType > 1) {
			// 포상품이 아이템이다.
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "경험치"); break;
			}
		}

		// 제의한 퀘스트를 기록해 놓는다.
		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;		// 퀘스트 번호 
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;	// 퀘스트 해결시 상품 종류 -> 아이템의 ID값이다.
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;	// 상품 갯수 
	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			          iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		// 리턴값이 음수이면 퀘스트 번호가 아닌 일반적인 대화 번호를 의미한다. 절대값이 100을 더해 보낸다. 
		// Return Code
		// -1:101  : 현재 임무 수행중
		// -2:102  : 마을이 다르거나 중립은 임무를 얻을 수 없다.    
		// -3:103  : 범죄자는 임무를 얻을 수 없다.
		// -4:104  : 현재 조건에 맞는 임무가 없다. 이경우 다른 대화 내용으로 대체한다.
		// -5:105  : 퀘스트가 완료되어 해당 부분에서 처리되었다. 여기서는 메시지를 보낼 필요 없다.

		//    111  : 길드홀 일반 퀘스트 완료시 
		//    112  : 일반상점 일반 퀘스트 완료시
		//    113  : 무기상점 일반 퀘스트 완료시
		//    114  : 시청 일반 퀘스트 완료시 
		//    115  : 창고 퀘스트 완료시 
		//    116  : 마법사 타워 퀘스트 완료시 

		//    121~126  : 퀘스트 완료되었으나 상품을 소지할 수 없다는 메시지 
		//    131~136  : 일반 대화 

		switch (iQuestNum) {
		case  0: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
 register int ix, iy, iItemNum;
 register short sSpr, sSprFrame;
 char  cItemColor;
 class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
	for (iy = sY -1; iy <= sY +1; iy++) {
		// 만약 이 위치에 발화성 아이템이 있다면 지우고 불 오브젝트를 놓는다.	
		iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);
				
		switch (iItemNum) {
		case 355: 
			// 석탄이다. 아이템을 지우고 불을 만든다.
			pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
			if (pItem != NULL) delete pItem;
			iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);	

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
				                        ix, iy, sSpr, sSprFrame, cItemColor);
			break;
		}
	}
}



void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cNpcName[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, token);
	}

	for (i = 0; i < DEF_MAXNPCS; i++) 
	if (m_pNpcList[i] != NULL) {
		if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINIFO, 1, i, NULL, NULL);	
		}
	}

	delete pStrTok;
	return;
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
 WORD wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;

	
	// 현재 무장한 무기의 스킬 번호를 반환 
	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		// 맨손공격 
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		// 단검류
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9; // 펜싱검
		else return 8; // 장검 
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		// 도끼류 
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		// v2.16 2002-5-27 해머 
		return 14; // 해머 
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		// v2.16 2002-5-27 지팡이류 추가 
		return 21;
	}
	else if (wWeaponType >= 40) {
		// 활류  
		return 6;
	}
	
	return 1;
}


// 콤보 공격 보너스 테이블
//                             1 2 3 
static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,0,0};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 1,3,5};
static int ___iCAB9[]  = {0,0, 2,4,8};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5: // Hand-Attack
		return ___iCAB5[iComboCount];
		break;
	case 6: // Archery
		return ___iCAB6[iComboCount];
		break;
	case 7: // Short-Sword
		return ___iCAB7[iComboCount];
		break;
	case 8: // Long-Sword
		return ___iCAB8[iComboCount];
		break;
	case 9: // Fencing
		return ___iCAB9[iComboCount];
		break;
	case 10: // Axe-Attack
		return ___iCAB10[iComboCount];
		break;
	case 14: // Hammer
		return ___iCAB6[iComboCount];
		break;
	case 21: // Staff-Attack
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}


void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_b100skill == TRUE) return;
	if (m_pClientList[ iClientH ] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[ iClientH ]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[ iClientH ]->m_iDownSkillIndex = iSkillIndex;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[ iClientH ]->m_iDownSkillIndex, NULL, NULL, NULL);
}

BOOL CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
 BOOL bRet;

	// 위치를 지정하고 사용 후 사라지는 아이템 효과 처리 부분 
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		// 영토 점령용 깃발이다. m_sItemEffectValue1 가 사이드, m_sItemSpecEffectValue1이 EK 수를 나타낸다. m_sItemEffectValue2번이 1이면 Admin Flag
		
		// 마스터 깃발이면 아무데나 꽂을 수 있고 EKNum은 무조건 100이다.
		if ((BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 == TRUE)
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 = 100;
		
		bRet =  __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1,    //!!! SpecValue!!!
								 iClientH, // 설치자 
								 (BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 ); //
		if (bRet == TRUE) {
			// 깃발 설치 성공.
		}
		else {
			// 깃발 설치 실패를 통보한다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;

	// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		// 건설 키트이다. 미들랜드에서만 사용 가능함. m_sItemEffectValue1: 건축물 종류, m_sItemEffectValue2: 건축 시간 
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
								     iClientH); // 설치자 
		if (bRet == TRUE) {
			// 건설 시작 
		}
		else {
			// 건설 실패			
		}
		return bRet;
	
	case DEF_ITEMEFFECTTYPE_DYE:
		// 아이템 염색: 아이템 값이 유효한가 체크.
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					 (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12) ) {
					// 염색이 가능한 아이템이다.
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					// 색 속성이 바뀌었음을 알려준다. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					// 염색이 불가능한 아이템이다. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_ARMORDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;
	case DEF_ITEMEFFECTTYPE_ITEMFARM:	//v2.19 2002-12-16 농사 스킬 관련
		bRet = __bSetAgricultureItem(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,		//
									 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,		//
				 				     iClientH); // 설치자 
		if (bRet == TRUE) {
			// 농작물 씨뿌리기 시작 
		}
		else {
			// 농작물 씨뿌리기 실패			
		}
		return bRet;
		break;


	default:
		break;
	}

	return TRUE;
}


BOOL CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, BOOL bAutoFlag)
{register int ix,iy;
 int   iDynamicObjectIndex, iIndex;
 class CTile * pTile;
 DWORD dwTime = timeGetTime();	
	if (m_pMapList[cMapIndex] == NULL)									return FALSE;
	if ((m_bIsHeldenianMode == FALSE)&&(bAutoFlag == FALSE))		return FALSE; // War must be started is player flag
	if ((m_cHeldenianModeType == 1) && (m_iBTFieldMapIndex != cMapIndex))	return FALSE; // Type 1: only on BattleField
	if ((m_cHeldenianModeType == 2)	&& (m_iGodHMapIndex  != cMapIndex))     return FALSE; // allowed only in HRampart / GodH
	if ((m_cHeldenianModeType == 2)	&& (m_iGodHMapIndex  == cMapIndex) && (bAutoFlag == FALSE) && (m_pClientList[iClientH] != NULL))									
	{	if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) return FALSE; // for attackers only
		if (m_pClientList[iClientH]->m_iGuildRank != 0)	return FALSE;
	}
	
    if ((dX != 59) && (dX != 72))return FALSE;
	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iAttribute != NULL)									return FALSE;
	if (pTile->m_iOccupyFlagIndex != NULL)								return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)								return FALSE;
	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) 
	{	return FALSE;
	}//
	if (bAutoFlag == FALSE) // Flag set by a character
	{	if (m_pClientList[iClientH] == NULL) return FALSE;	
		switch (m_pClientList[iClientH]->m_cSide) {
		case 1:	// Aresden
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		case 2: // Elvine	
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		default: // Others
			return FALSE;
			break;
		}	
		if (iDynamicObjectIndex == NULL) return FALSE;
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
		if (iIndex == -1) PutLogList("Error registering OccupyFlag.");	
		for (ix = dX-iEKNum; ix <= dX+iEKNum; ix++) 
		for (iy = dY-iEKNum; iy <= dY+iEKNum; iy++) 
		{	
			if ((ix == dX) && (iy == dY)) 
			{}
			else 
			{	
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
				if (pTile->m_iOccupyFlagIndex == NULL) 
				{	
					switch (m_pClientList[iClientH]->m_cSide)
					{
					case 1:	// Aresden 
						pTile->m_iOccupyStatus -= iEKNum; 
						break;
					case 2: // Elvine	
						pTile->m_iOccupyStatus += iEKNum; 
						break;
					default:
						pTile->m_iOccupyStatus = 0;
						break;
					}	
				}	
			}	
		}
		switch (m_pClientList[iClientH]->m_cSide) 
		{
			case 1:	// Aresden 
			m_iHeldenianAresdenFlags ++;
			break;
			case 2: // Elvine	
			m_iHeldenianElvineFlags ++;				
			break;
		}
		wsprintf(G_cTxt, "PC(%s) \tused Flag...\t%s(%d %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, dX, dY);
		PutLogList(G_cTxt);	
		// Heldenian type 2 is won !
		if ((m_pClientList[iClientH]->m_iGuildRank == 0)	&& (m_pClientList[iClientH]->m_cSide != m_sLastHeldenianWinner) && (m_iGodHMapIndex == cMapIndex))
		{	
			m_pClientList[iClientH]->m_iWarContribution   += (1000 * iEKNum); // double bonus for gm putting the flag...
			LocalEndHeldenianMode(TRUE, iSide);
		}
		// give some Summon points in case the character was killed, he will be able to catch more scrolls..
		m_pClientList[iClientH]->m_iConstructionPoint += (1000 * iEKNum);
		m_pClientList[iClientH]->m_iWarContribution   += (100 * iEKNum);
		bUpdateHeldenianStatus(-1);
		if (m_pClientList[iClientH]->m_iConstructionPoint > DEF_MAXHELDENIANSUMMONPOINT) m_pClientList[iClientH]->m_iConstructionPoint = DEF_MAXHELDENIANSUMMONPOINT;
		}
		else // bAutoFlag Flag set by server at Heldenian type 2 beginning
		{
			if (m_cHeldenianModeType != 2) return FALSE;	
		switch (m_sLastHeldenianWinner) {
		case 1:	// Aresden:
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		case 2: // Elvine	
			iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	
			break;
		default: // Others
			return FALSE;
			break;
		}
		if (iDynamicObjectIndex == NULL) return FALSE;
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
		if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
		for (ix = dX-20; ix <= dX+35; ix++) 
		for (iy = dY-20; iy <= dY+25; iy++) 
		{	if ((ix == dX) && (iy == dY)) 
			{}else 
			{	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
				if (pTile->m_iOccupyFlagIndex == NULL) 
				{	switch (m_sLastHeldenianWinner) {
					case 1:	// Aresden 
						pTile->m_iOccupyStatus -= 15; 
						break;
					case 2: // Elvine	
						pTile->m_iOccupyStatus += 15; 
						break;
					default:
						pTile->m_iOccupyStatus = 0;
						break;
		}	}	}	}	
		wsprintf(G_cTxt, "Server set Master Flag\t %s(%d %d)"
			, m_pMapList[cMapIndex]->m_cName
			, dX
			, dY);
		PutLogList(G_cTxt);	
	}
	return TRUE;
}

void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{
 register int i, iTargetIndex;
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	// v2.1 중립은 몹공격 명령을 할 수 없다.
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));

	switch (iMode) {
	case 0: // Free 모드
	case 1: // Hold 모드
		//  마스터가 iClientH인 몹들의 제어모드를 변경한다.
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
				 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
				 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

				m_pNpcList[i]->m_iSummonControlMode = iMode;
				m_pNpcList[i]->m_bIsPermAttackMode  = FALSE;
				m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_iTargetIndex       = NULL;
			}
		}
		break;
	
/*	case 2:
		// 공격 모드 - 목표물을 얻어온다. 
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != NULL) {
			if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));

		delete pStrTok;

			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			{
				if ((m_pClientList[i] != NULL) &&
					(memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) 
				{
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

SSMA_SKIPSEARCH:;

		if ( (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) && 
			 (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {

			for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) {
				if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
					 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

					m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
				}
			}
		}
		break;*///acatgtviejo

		case 2: // target
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != NULL) 
		{	if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{	if (   (m_pClientList[i] != NULL) 
					&& (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) 
					&& (strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) 
				{	iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}
SSMA_SKIPSEARCH:;
		if (   (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) 
			&& (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) 
		{	for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) 
			{	if (   (m_pNpcList[i]->m_cFollowOwnerType  == DEF_OWNERTYPE_PLAYER)
					&& (m_pNpcList[i]->m_bIsSummoned == TRUE)
					&& (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH)) 
				{	m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
				}
			}
		}
		delete pStrTok;
		break;
	}
}

 
void CGame::GetFightzoneTicketHandler(int iClientH)
{
 int   iRet, iEraseReq, iMonth, iDay, iHour;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) { 
		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));


	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,DEF_ITEMNAME_ARENATICKET) ;
	else  wsprintf(cItemName,DEF_ITEMNAME_ARENATICKET2,m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 에러 방지용 코드
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
			
		// 아이템을 받을 수 있다는 것이 확정 되었으므로 입장권개수를 빼도 된다. 
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;
				
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		
		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
	    iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;
		
		_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

		ZeroMemory(cData, sizeof(cData));

		// 아이템 얻었다는 메시지를 전송한다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		// 1개 획득했다.
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
				
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
				
		*cp = pItem->m_cItemType;
		cp++;
				
		*cp = pItem->m_cEquipPos;
		cp++;
				
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
				
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
				
		*cp = pItem->m_cGenderLimit;
		cp++;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
				
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		
		*cp = (char)pItem->m_sItemSpecEffectValue3;
		cp++;
													
		if (iEraseReq == 1) 
		{
			delete pItem;
			pItem = NULL ;
		}

				
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				
		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);
				
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
				// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}	
	else {
		// 공간이 부족해 아이템을 얻을 수 없다.
		delete pItem;
		pItem = NULL ;

		// 소지품 총 중량 재 계산 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 메시지를 보낼때 에러가 발생했다면 제거한다.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}		
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
 SYSTEMTIME SysTime;
 char cTxt[120];
 int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	
	// 
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) { 
		
		wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
			                                m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}

	strcat(pData, "\n\n");

	return strlen(pData);
}


BOOL CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iFlagIndex = 0;
 int  iSide;
 class CStrTok * pStrTok;
 int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return FALSE;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Side
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					iSide = atoi(token);
					cReadModeB = 2;
					break;
				
				case 2:
					// X 좌표 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					dX = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Y 좌표  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					dY = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// EKNum
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					iEKNum = atoi(token);
					
					// 데이터를 모두 만들었으므로 깃발을 등록한다. (!!! Master Flag로 처리해야만 설치할 수 있다)
					if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, TRUE) == TRUE)
						iTotalFlags++;
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				
			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return FALSE;
	}

	wsprintf(G_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(G_cTxt);

	return TRUE;
}

/*
void CGame::GetDarkKnightItemHandler(int iClientH)
{
	int		iItemID, iNum, i, iEraseReq, iRet;
	char	cItemName[21], *cp, cData[256];
	DWORD *dwp;
	short	*sp;
	WORD	*wp;
	class CItem *pItem;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLevel < 180) return;
	
	pItem = new class CItem;
	iItemID = pItem->m_sIDnum;
	
	iItemID = 706; // DarkKnightHauberk
	
	iNum = 1;
	for (i = 1; i <= iNum; i++) {
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) {
			delete pItem;
			pItem = NULL ;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
	
				ZeroMemory(cItemName, sizeof(cItemName));
				memcpy(cItemName, pItem->m_cName, 20);
				wsprintf(G_cTxt, "(*) GetDK : Char(%s) Item(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
				//PutLogFileList(G_cTxt);
				PutLogList(G_cTxt);

				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
								
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0;
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}
			else 
			{
				delete pItem;
				pItem = NULL;

				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}
*/
				

void CGame::GetHeroMantleHandler(int iClientH, int iOpcion)
{
 int   i, iNum, iRet, iEraseReq, iRequiredEK = 0, iRequiredContri = 0, iItemID;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) return;

	if (_iGetItemSpaceLeft(iClientH) == 0) {  
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
    			switch (iOpcion) {
					case 1:
						if(m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) iItemID = 400;
						else if(m_pClientList[iClientH]->m_cSide == DEF_ELVINE) iItemID = 401;
						iRequiredEK = 300;
						iRequiredContri = 0;
					break;
		
					case 2:
						if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 403;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 404;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 405;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 406;
						iRequiredEK = 150;
						iRequiredContri = 20;
					break;
		
					case 3:
						if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 407;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 408;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 409;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 410;
						iRequiredEK = 100;
						iRequiredContri = 20;
					break;
		
					case 4:
						if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 411;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 412;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 413;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 414;
						iRequiredEK = 300;
						iRequiredContri = 30;
					break;
			
					case 5:
						if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 415;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 416;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 417;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 418;
						iRequiredEK = 200;
						iRequiredContri = 20;
					break;
		
					case 6:
						if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 419;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 420;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 421;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 422;
						iRequiredEK = 100;
						iRequiredContri = 10;
					break;
			
					case 7:
						if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 423;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 424;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 1)) iItemID = 425;
						else if((m_pClientList[iClientH]->m_cSide == DEF_ELVINE)&&(m_pClientList[iClientH]->m_cSex == 2)) iItemID = 426;
						iRequiredEK = 150;
						iRequiredContri = 15;
					break;
		
					default:
					return;
					break;
				}		
				if ((m_pClientList[iClientH]->m_iEnemyKillCount < iRequiredEK)||(m_pClientList[iClientH]->m_iContribution < iRequiredContri)) return;

	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) {
			delete pItem;
			pItem = NULL ;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
			
				m_pClientList[iClientH]->m_iEnemyKillCount -= iRequiredEK; 
				m_pClientList[iClientH]->m_iContribution -= iRequiredContri; 
				
	
				ZeroMemory(cItemName, sizeof(cItemName));
				memcpy(cItemName, pItem->m_cName, 20);
				wsprintf(G_cTxt, "(*) Get Mantle : Char(%s) Item(%s) Player-EK(%d) Contribution(%d)", m_pClientList[iClientH]->m_cCharName, cItemName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution);
				PutLogFileList(G_cTxt);

				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
								
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0;
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				
				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;

				_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);
								
				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONTRIBUTION, m_pClientList[iClientH]->m_iContribution, NULL, NULL, NULL); 
			}
			else 
			{
				delete pItem;
				pItem = NULL;

				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
 char * cp, cItemIndex;
 short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	// 잘못된 좌표값 보정 
	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
 register int i, iDamage;

	if (m_pClientList[iClientH] == NULL) return;
	// v1.3 유니크 아이템의 장착 상태를 판단한다. 특정인만이 착용 가능한 아이템을 장착한 경우 벗겨진다.

	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
			 (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) ) {
			// Touch Effect Type이 DEF_ITET_OWNER이면 Touch Effect Value 1, 2, 3이 주인 캐릭터의 고유값을 갖는다. 
						
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {
				// ID 값이 맞다.
			}
			else {
				// 자신의 것이 아니므로 착용이 해제된다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
				ReleaseItemHandler(iClientH, i, TRUE);
				// v1.4 대미지를 얻는다. 
				iDamage = iDice(10, 10);
				m_pClientList[iClientH]->m_iHP -= iDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) {
					ClientKilledHandler(iClientH, NULL, NULL, iDamage);
				}
			}
		}
	}
}

void CGame::_BWM_Init(int iClientH, char *pData)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_bIsBWMonitor = TRUE;
	wsprintf(G_cTxt, "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char *pData)
{
 char * cp, cName[11];
 register int i;

	cp = (char *)(pData + 16);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
			m_pClientList[i]->m_iTimeLeft_ShutUp = 20*3*10; // 1이 3초다. 20이면 1분 욕을 하면 무조건 페널티 10분  
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, 20*3*10, NULL, NULL, cName);
			
			// Admin Log
			wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)", cName, 20*3*10);
//			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);

			return;
		}
	}
}



int CGame::_iGetItemSpaceLeft(int iClientH)
{
 int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

BOOL CGame::bAddItem(int iClientH, CItem * pItem, char cMode)
{
 char * cp, cData[256];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int iRet, iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1개 획득했다. Amount가 아니다!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// 수량을 입력 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		
		*cp = (char)pItem->m_sItemSpecEffectValue3;
		cp++;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/
		
		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL;
		}
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
		
		return TRUE;
	}
	else {
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY, 
			                                                         pItem);
		
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		
		return TRUE;
	}

	return FALSE;
}


void CGame::CancelExchangeItem(int iClientH)
{
 int iExH;
	
	// 현재 교환을 취소한다. 상대방도 자동으로 취소된다. 
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}

void CGame::_ClearExchangeStatus(int iClientH)
{
	if ((iClientH <= 0) || (iClientH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_cExchangeName != FALSE) 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL, NULL,
						NULL, NULL, NULL, NULL, NULL);	

	m_pClientList[iClientH]->m_dwInitCCTime     = FALSE;
	m_pClientList[iClientH]->m_iAlterItemDropIndex = 0;
	m_pClientList[iClientH]->m_iExchangeH = NULL;
	m_pClientList[iClientH]->m_bIsExchangeMode = FALSE;
	m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
	ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
	
	//Dword 14-09
	bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH); //exchange fixed
}

int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int iQuest, iEraseReq, iExp;
 class CItem * pItem;

	// Return Code
	// -1  : 현재 임무 수행중
	// -2  : 마을이 다르거나 중립은 임무를 얻을 수 없다.    
	// -3  : 범죄자는 임무를 얻을 수 없다.
	// -4  : 현재 조건에 맞는 임무가 없다. 일상적인 대화나 정보 출력 

	if (m_pClientList[iClientH] == NULL) return 0;

	if (m_pClientList[iClientH]->m_iQuest != NULL) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == NULL) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) {
				if ( (m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					 (m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != NULL) ) {
					pItem = new class CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem) == TRUE) {
						// 퀘스트 아이템을 받을 수 있는 조건이다. 수여한다.
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
						if (iEraseReq == 1) {
							delete pItem;
							pItem = NULL;
						}
						
						// v2.24
						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						// 포상이 전달되었다는 메시지 전송 후 리턴. 퀘스트 상태 클리어.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);
						
						_ClearQuestStatus(iClientH);
						return -5;
					} 
					else {
						delete pItem;
						pItem = NULL;

						// 아이템을 받을 수 없다는 메시지 전송 후 리턴
						SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					// 퀘스트의 댓가가 경험치이다. 
					GetExp(iClientH, m_pClientList[iClientH]->m_iQuestRewardAmount); //m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					// 공헌도 상승 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							      "경험치              ", m_pClientList[iClientH]->m_iContribution);
					
					// 퀘스트 상태를 클리어한다.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					// 퀘스트의 댓가는 비례 경험치 적에게 죽었을때 경험치 * m_pClientList[iClientH]->m_iQuestRewardAmount 만큼의 경험치를 얻는다.
					//***
					iExp = iDice(1, (10*m_pClientList[iClientH]->m_iLevel));
					//***
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;
					
					GetExp(iClientH, iExp); //m_pClientList[iClientH]->m_iExpStock += iExp;
					// 공헌도 상승 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp, 
							      "경험치              ", m_pClientList[iClientH]->m_iContribution);
					
					// 퀘스트 상태를 클리어한다.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					// 퀘스트의 댓가는 없다. 공헌도만 오른다.
					// 공헌도 상승 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0, 
							      "                     ", m_pClientList[iClientH]->m_iContribution);
					
					// 퀘스트 상태를 클리어한다.
					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}
		
		return -4;	// 다른 NPC에게서 얻은 퀘스트를 수행중이다. 즉 조건에 맞는 임무가 없다. 일상적인 대화를 출력한다.
	}
	
	// 아무런 임무를 맞고 있지 않다. 임무를 맡을 수 있는 조건인지 판별한다. 
	if( m_pClientList[iClientH]->m_iIsOnTown == DEF_NONPK ) { // 2002-11-15 수정
		// 마을 소속이 같다. 
		// 범죄자라면 임무를 맡을 수 없다. 
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;
		
		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		// 임무 찾았다. 
		return iQuest;
	}
	else return -2; // 마을이 다르거나 마을 소속이 아니다.

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	// 경비병과의 대화. 플레이어의 위치에 적절한 대화 메시지를 디스플레이한다.
	if (m_pClientList[iClientH] == NULL) return 0;

	// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.
	if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) { 
		// 말 건 사람이 아레스덴 소속 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// 자기 마을 경비에게 말을 걸었음.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// 다른 마을 경비에게 말을 걸었음.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}
	else
	if (m_pClientList[iClientH]->m_cSide == DEF_ELVINE ) { 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// 다른 마을 경비에게 말을 걸었음.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
			return 1002;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// 자기 마을 경비에게 말을 걸었음.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
			return 1003;
		}
	}
	else
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// 중립이 아레스덴 경비에게 말을 걸었음
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
			return 1004;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// 중립이 엘바인 경비에게 말을 걸었음.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
			return 1005;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
			// 초보 사냥터
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
			return 1006;
		}
	}

	return 0;
}


BOOL CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iQuestConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 퀘스트 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pQuestConfigList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[atoi(token)] = new class CQuest;
					iQuestConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// 퀘스트 사이드  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 퀘스트 종류  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// TargetType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// MaxCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
					strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
					cReadModeB = 23;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
					cReadModeB = 27;
					break;

				case 27:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == NULL) return -1;
 
	// 적합한 미션 배열 초기화.
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < DEF_MAXQUESTTYPE; i++) 
	if (m_pQuestConfigList[i] != NULL) {
		
		if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
			// 고려해야 할 스킬이 있다. 
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
		}
		
		// 크루세이드 모드일때는 할당 타입이 1인 퀘스트만 부여된다.
		if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP; 
		// 크루세이드 모드가 아닐때는 할당 타입이 1은 선택되지 않는다.
		if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP; 

		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		// 여기까지 오면 조건에 합당한 퀘스트다. 등록한다. 
		iQuestList[iIndex] = i;
		iIndex++;

SFQ_SKIP:;
	}

	// iIndex개 만큼의 조건에 만족하는 퀘스트를 찾았다. 그 중에서 랜덤하게 1개를 선택한다.
	if (iIndex == 0) return -1;
	iQuest		 = (iDice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];
	// 퀘스트 인덱스 
	iReward = iDice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					// 퀘스트 응답 모드 
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	// 퀘스트 상품 종류 
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	// 퀘스트 상품 갯수 
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			// 퀘스트 해결시 올라가는 공헌도 
	
	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			// 퀘스트 맵 이름 수록 
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}
 
void CGame::QuestAcceptedHandler(int iClientH)
{
 int iIndex;

	if (m_pClientList[iClientH] == NULL) return;
	
	// Does the quest exist ??
	if(m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == NULL) return;

	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		// 쳉셋맡㈒체쩔챘 쳉뮤승봤짰쳉쨈. 
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: // 쳉쨌쨔쳉련짰쩔챘 1쳇맞셋 쳉뮤승봤짰. 쳉쨌쨔쳉련짰쳉째챠 쨀짧쨍챕 쨀징쳉쨈. 쨈천쳉쨩처쳉 쳉뮤승봤짰 쩔짤쨘쳇걔 쩐첩쳇.
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				                   m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	// 쳉쨌쨔쳉쩐챤째징 쳉뮤승봤짰쨍짝 쩌철쨋척쳉쨈. 쳉뮤승봤짰 쨔첩쳇, ID째짧 쳉쨈챌.
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = FALSE;
	
	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}
/*
void CGame::_SendQuestContents(int iClientH)
{
 int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21], cQuestRemain;

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		// 할당된 Quest가 없다. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
		              NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		// 할당된 Quest 내용을 보내준다.
		if (m_pQuestConfigList[iIndex] == NULL) return ;

		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
	    iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
      	cQuestRemain = m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);

	}
}*/

void CGame::_SendQuestContents(int iClientH)
{
 int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		// 쳉쨈챌쨉 Quest째징 쩐첩쨈. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
		              NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		// 쳉쨈챌쨉 Quest 쨀쨩쩔챘쳇 쨘쨍쨀쨩쳉쨈.
		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			          iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}
void CGame::_CheckQuestEnvironment(int iClientH)
{
 int iIndex;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;

	// v2.181 2002-11-4  Quest 관련 버그 수정 (삭제된 퀘스트를 가지고 있는 유저의 퀘스트를 초기화 한다.)
	if (iIndex >= 35 && iIndex <= 40 ){
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}
	
	if (m_pQuestConfigList[iIndex] == NULL) return;
	
	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		// 퀘스트 ID 값이 다르다. 할당받았던 그 퀘스트가 아니다. 퀘스트는 취소된다.
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		// 몬스터 사냥의 경우 매번 몬스터 사냥시 맵 이름을 비교하는 것은 비효율적이므로 미리 맵 이름을 비교, 플래그를 설정해 놓는다. 
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			 m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = TRUE;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = FALSE;
		break;
	}
}

BOOL CGame::_bCheckIsQuestCompleted(int iClientH)
{
 int iQuestIndex;

	// 퀘스트가 종료되었는지 판단한 후 메시지 처리.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) return FALSE;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return FALSE;
		
	if (m_pQuestConfigList[iQuestIndex] != NULL) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && 
				 (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
				// 몬스터 사냥 퀘스트가 완료되었다. 완료되었으면 의뢰인에게 돌아가 대화를 하면 포상받는다. 
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && // 맵은 맞고
				 (m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && // 좌표도 이내이면 
				 (m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {
				// 특정 장소 찾아가기 퀘스트 완료.
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{
 char  * cp, cData[512];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	if (m_pClientList[iClientH] == NULL) return;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
		*cp = 1; // 1개 획득했다. <- 여기서 1개란 수량 카운트를 말하는 것이 아니다
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor; // v1.4
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		
		*cp = (char)pItem->m_sItemSpecEffectValue3;
		cp++;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
		cp++;
		*/

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
		break;

	case DEF_NOTIFY_ITEMPURCHASED:
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;
		
		wp  = (WORD *)cp;
		*wp = iV1; // (iCost - iDiscountCost);
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		iRet =m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}
}

BOOL CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// 먼저 중량 초과 여부를 가린다.
	/*
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// 수량개념이 있는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + (pItem->m_wWeight * pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// 수량 개념이 없는 아이템 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->m_wWeight) > _iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	*/
	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > (DWORD)_iCalcMaxLoad(iClientH)) 
		return FALSE;
		
	// 아이템을 받을 여유공간 유무 판단.
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return TRUE;

	return FALSE;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = FALSE;
}

int CGame::iGetMaxHP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = m_pClientList[iClientH]->m_iVit*3 + m_pClientList[iClientH]->m_iLevel*2 + (m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)/2;
	
	if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
		iRet = iRet - (iRet/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
 int i, iTotalPoint;
 POINT  pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == NULL) return;

	// 리스트를 작성한다.
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)
	if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
		pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
		pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
		iTotalPoint++;
	}

	if (iTotalPoint == 0) return;

	// v1.42 소속이 중립이면 무조건 Initial Point의 처음으로 간다.
	if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		 i = 0;
	else i = iDice(1, iTotalPoint) - 1;

	*pX = (short)pList[i].x;
	*pY = (short)pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
 class CTile * pTile;
 int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
	if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {
	
		iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
		iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
		iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
		iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

		// 전략적 지점의 가중치를 곱해서 더한다. 
		m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iLogSockH, iRet;

	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;
	
	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	
	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
	//	wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
	//	PutLogList(G_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;

	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// 로그서버로의 연결이 이루어 졌다.
		/*wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
		PutLogList(G_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;*/
		if (m_bIsSubLogSockAvailable[5] == TRUE) bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		break;


	case DEF_XSOCKEVENT_READCOMPLETE:
		// 메시지가 수신되었다. 
		OnSubLogRead(iLogSockH);
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// 확인코드가 일치하지 않는다. 
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
       	delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		wsprintf(G_cTxt, "(!!!) MENSAJE LARGO", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		break;

		// 수신해야 할 메시지 크기가 버퍼보다 크다.	종료해야만 한다.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// 소켓에 에러가 났다.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 소켓이 닫혔다.
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		break;
	}
}





void CGame::OnSubLogRead(int iIndex)
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// 메시지 큐에 이상이 생겼다. 치명적인 에러.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

BOOL CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,BOOL bForceItemLog)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;
	if (pItem == NULL) return FALSE;

	// !! 짹쨔쩔징 청쩔챘쨋짠  New Item  쨩첵짹챈쨋짠쨈  iGive째징 쨀쩌철 쨈.
	if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

	if (iAction == DEF_ITEMLOG_DUPITEMID) {
		if (m_pClientList[iGiveH] == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
		wsprintf(G_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
			pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
			m_pClientList[iGiveH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,G_cTxt);
		return TRUE;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	switch (iAction) {
		case DEF_ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_GIVE:	
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_DROP:
			wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_GET:
			wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		case DEF_ITEMLOG_MAKE:
			wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_DEPLETE:	
			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount , 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_SELL:
			wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		default:
			return FALSE ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}

BOOL CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	if(pItem == NULL) return FALSE;
	if(_bCheckGoodItem( pItem ) == FALSE) return FALSE;
	if(iAction != DEF_ITEMLOG_NEWGENDROP)
	{
		if( m_pClientList[iClientH] == NULL ) return FALSE;
	}
	char  cTxt[200], cTemp1[120];
	//  쨌짹 쨀짼짹채쨈. 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	if( m_pClientList[iClientH] != NULL ) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
	case DEF_ITEMLOG_NEWGENDROP:
		if (pItem == NULL) return FALSE;
		wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)",cName, pItem->m_cName, pItem->m_dwCount,  
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		break;
	case DEF_ITEMLOG_SKILLLEARN:
	case DEF_ITEMLOG_MAGICLEARN:
		if (cName == NULL) return FALSE; 
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 
	case DEF_ITEMLOG_SUMMONMONSTER:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break ;
	case DEF_ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, 
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	case DEF_ITEMLOG_REPAIR:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	default:
		return FALSE;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}

BOOL CGame::_bCheckGoodItem( class CItem * pItem )
{
	if( pItem == NULL ) return FALSE;

	if( pItem->m_sIDnum == 90 )
	{
		if( pItem->m_dwCount > 10000 ) return TRUE;  //Gold에 한해 10000원 이상만 로그에 남긴다.
		else return FALSE;
	}
	switch (pItem->m_sIDnum) {
	case 20: // 엑스 칼리버 
//	case 90: // Gold 추가 
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 391:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 508:
	case 581:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 616:  // 데몬-슬레이어
	case 618:  // 다크엘프-보우

	case 620:
	case 621:
	case 622:
	case 623:

	case 630:
	case 631:

	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:

	case 642:
	case 643:

	case 644:
	case 645:
	case 646:
	case 647:
	case 648: //넥클리스오브리치

	case 650:
	case 651:
	case 652:
	case 653:
	case 654:
	case 655:
	case 656:
	case 657:

    case 700: 	// v2.03 상어 아이템 
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 706:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:
	case 716:  // 흑마법사레더아머 
	case 717:  // 흑기사의레이피어
	case 718:  // 흑기사의그레이트소드
	case 719:  // 흑마법사스케일메일

	case 720:
	case 721:
	case 722:
	case 723:

	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:

	case 734:
	case 735:

	case 736:  // 새로운 상어의 자이언트 소드
	case 737:  // 새로운 흑기사의 자이언트 소드
	case 738:  // 새로운 흑마법사의매직원드
	case 762:  // 자이언트-배틀해머
	case 765:  // 3주년 기념 반지
	case 775:  // 흑여마법사레더아머
	case 776:  // 흑여마법사스케일메일
	
		return TRUE;  //특별한 아이템이기 땜시 기록...
		break;
	default:
		// v2.17 2002-7-31 제작 아이템도 로그에 남게 한다.
		if ((pItem->m_dwAttribute & 0xF0F0F001) == NULL) return FALSE;  //특별한 아이템두 아니구 특성치도 없다면 별루..
		else if( pItem->m_sIDnum > 30 ) return TRUE;  //특별한 아이템은 아니지만 특성치가 있고 단검류가 아니라면 좋은 아템..
		else return FALSE;  //특별한 아이템두 아니구 특성치는 있지만 단검류라면 별루...
	}
}

BOOL CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{
		char  cTxt[200];
		
	//  로그 남긴다. 
		ZeroMemory(cTxt, sizeof(cTxt));

		switch (iAction) {

		case DEF_CRUSADELOG_STARTHAPPYHOUR:
			wsprintf(cTxt,"Happy-Hour Activado! Doble EKs.");
			break ;

		case DEF_CRUSADELOG_ENDHAPPYHOUR:
			wsprintf(cTxt,"Happy-Hour Desactivado! EKs Normales.");
			break ;
		//FurDay by prlucas
		case DEF_CRUSADELOG_STARTFURYDAY:
			wsprintf(cTxt,"Fury Day Activado! Ek x100");
			break ;

		case DEF_CRUSADELOG_ENDFURYDAY:
			wsprintf(cTxt,"Fury Day Desactivado! EKs Normales.");
			break ;

		case DEF_CRUSADELOG_ENDCRUSADE:
			if (cName == NULL) return FALSE;
			wsprintf(cTxt,"\tEnd Crusade\t%s",cName);
			break;

		case DEF_CRUSADELOG_SELECTDUTY :
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,iData,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_STARTCRUSADE:
				wsprintf(cTxt,"\tStart Crusade");
			break ;

		default:
			return FALSE;
		}

	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, NULL, cTxt);
	return TRUE ;
}

BOOL CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{
 char  cTxt[1024], cTemp1[120], cTemp2[120];

		//  로그 남긴다. 
		ZeroMemory(cTxt, sizeof(cTxt));
		ZeroMemory(cTemp1, sizeof(cTemp1));
		ZeroMemory(cTemp2, sizeof(cTemp2));

		if ( m_pClientList[iVictumH] == NULL) return FALSE ;

		switch (iAction) {

		case DEF_PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
				 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 

		case DEF_PKLOG_BYPLAYER:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by PC\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break;
		case DEF_PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYENERMY:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "PC(%s)\tKilled by EN\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYNPC:
			if(pNPC==NULL) return FALSE ;
				wsprintf(cTxt, "PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,pNPC);
			break; 
		case DEF_PKLOG_BYOTHER:
				wsprintf(cTxt, "PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnKnown", m_pClientList[iVictumH]->m_cCharName, 
					 m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 
		default:
			return FALSE;
		}
	PutEkAndPkLogFileList(cTxt);
	return TRUE ;
}

void CGame::_CheckGateSockConnection()
{
	// 이미 서버가 셧다운된 상태라면 카운팅 할 필요가 없다.
	if (m_bIsServerShutdowned == TRUE) return;

	if (m_iGateSockConnRetryTimes != 0) {
		wsprintf(G_cTxt, "(!!!) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes); 
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}

	// 60초간 Gate-socket이 연결되지 않았다면 자동 재부팅 모드로 들어간다.
	if (m_iGateSockConnRetryTimes > 20) {
		// 게이트 서버와의 연결이 끊겼으므로 복구할 수 없다. 자동으로 서버를 셧다운한다.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
		}
	}
}

BOOL CGame::_bCheckSubLogSocketIndex()
{
 int  iCnt;
 BOOL bLoopFlag;

	// 메시지를 보낼 Sub-log-socket 인덱스 전진 
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// 보낼 수 있는 Sub-log-socket이 하나도 없다. 강제 셧다운 모드로 전환 
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// 게임 서버 셧다운이 시작되면 더이상의 클라이언트 접속이 거부된다. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  i, iIndex = 0;
 class CStrTok * pStrTok;
 class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 아이템 이름 
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
										
					cReadModeB = 2;
					break;

				case 2:
					// 스킬 제한치 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
					cReadModeB = 12;
					break;


				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);
					
					cReadModeB = 17;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);
					
					cReadModeB = 18;
					break;

				
				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);
					
					cReadModeB = 21;
					break;



				case 21:
					// m_iAverageValue
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// m_iMaxSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// m_wAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					
					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) {
						// 아이템의 존재가 확인되었다.
						m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;

						// 최대 가중치값 계산
						for (i = 0; i < 6; i++)
							m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

						iIndex++;	
					}
					else {
						// 이런 이름을 가진 아이템이 존재하지 않는다. 에러 
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
						PutLogList(G_cTxt);
						
						delete m_pBuildItemList[iIndex];
						m_pBuildItemList[iIndex] = NULL;
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					delete pItem;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::BuildItemHandler(int iClientH, char *pData)
{
 char * cp, cName[21], cElementItemID[6];
 int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
 class  CItem * pItem;
 BOOL   bFlag, bItemFlag[6];
 double dV1, dV2, dV3;
 DWORD  dwTemp, dwTemp2;
 WORD   wTemp;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;
	

	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i <= 4; i++) 
		if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
			cElementItemID[i] = cElementItemID[i+1];
			cElementItemID[i+1] = -1;
			bFlag = TRUE;
		}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;


	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
		return;
	}

	for (i = 0; i < 6; i++)
	if (cElementItemID[i] != -1) {
		if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) return;		
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {

			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
						
			for (x = 0; x < DEF_MAXITEMS; x++) 
			if (m_pClientList[iClientH]->m_pItemList[x] != NULL) 
				 iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
			else iItemCount[x] = 0;
			
			// 해당 빌드 아이템의 재료가 충분한지를 검사한다. 더불어 빌드 아이템의 가중치 값도 계산.
			iMatch = 0;
			iTotalValue = 0;
			
			for (x = 0; x < 6; x++) {
				if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
					iMatch++;
				}
				else {
					for (z = 0; z < 6; z++) 
					if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {
												
						if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
							(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
							(iItemCount[cElementItemID[z]] > 0)) {
							// 재료중 하나를 찾았다. 
							iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
							if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
								// 재료의 순도가 내 스킬 수준을 상회한다면 순도를 낮춘다. 
								iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13])/2;
							}

							iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
							iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
							iMatch++;
							bItemFlag[z] = TRUE;
						
							goto BIH_LOOPBREAK;
						}
					}
BIH_LOOPBREAK:;
				}
			}

			// 여기서 iMatch가 6이면 아이템 제작 조건이 만족된 것이다. 
			if (iMatch != 6) {
				// 재료 부족. 아이템 제작 불가 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			// 순도 계산 
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// 백분률로 바뀐 값.
			iTotalValue = (int)dV1;

			// 아이템 생성 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
				delete pItem;
				return;
			}

			// 아이템이 Custom-Made임을 나타내는 플래그를 입력 
			dwTemp = pItem->m_dwAttribute;
			dwTemp = dwTemp & 0xFFFFFFFE;
			dwTemp = dwTemp | 0x00000001;
			pItem->m_dwAttribute = dwTemp;

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				// 만들어진 아이템이 무기 제작 재료(잉곳)이라면 기술 수준에 따른 순도를 입력한다. 
				iTemp = iDice(1, (iPlayerSkillLevel/2)+1) -1;
				pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;
				// v2.15 제작 아이템에 아이템 고유번호 추가 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

			}
			else {
				// 무기 제작 재료가 아니고 무기나 방어구류라면 
				// 아이템 속성값 입력 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0x0000FFFF;

				dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
				dwTemp2 = dwTemp2 << 16;

				dwTemp  = dwTemp | dwTemp2;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//재료 순도에 따른 성능 입력: SpecEffectValue1은 수명, SpecEffectValue2는 성능 가중치 
				
				// 1. 성능 가중치 계산(백분율)
				if (iResultValue > 0) {
					if (iResultValue > 200) iResultValue = 200;
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue <= 0)/* {
					dV2 = (double)(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else */pItem->m_sItemSpecEffectValue2 = 0;

				// 2. 새로운 최대 수명 계산 
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				// v2.15 제작 아이템에 아이템 고유번호 추가 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// 에러로 인해 너무 많은 수명값이 나옴을 막기위함 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				//Custom-Item은 색상이 2번. 
				pItem->m_cItemColor = 2;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
			PutLogList(G_cTxt);
		
			// 아이템 전달 
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); // Integer를 전달하기 위해 

#ifdef DEF_TAIWANLOG
			// v1.41 희귀 아이템이라면 로그를 남긴다. 
			_bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif	

			// 마지막으로 재료가 되는 아이템을 없앤다. 
			for (x = 0; x < 6; x++)
			if (cElementItemID[x] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
					// ### BUG POINT!!!
					// 버그의 원인을 밝힌다.
					wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
					PutLogFileList(G_cTxt);
				}
				else {
					iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
					if (iCount < 0) iCount = 0;
					SetItemCount(iClientH, cElementItemID[x], iCount);
				}
			}

			// 이제 스킬을 카운트 한다. 단 아이템의 최대 성장 스킬 한도 내에서만 가능하다.  
			if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
				//CalculateSSN_SkillIndex(iClientH, 13, 1);

			// v1.41 소량의 경험치 증가 
			GetExp(iClientH, iDice(2, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

			return;
		}
	}
}




// v2.17 2002-7-15 운영자 명령어로 강콜시간을 설정한다.
void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 char   seps[] = "= \t\n";
 char   * token, cBuff[256],* cp; 
 WORD * wp ;
 int    iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	// v2.18 2002-10-15 GM 패스워드를 치지 않으면 동작하지 않는다. 

	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {

		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 	
		m_sForceRecallTime = iTime ;

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;
	
		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		bStockMsgToGateServer(cBuff, 3);

		wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(G_cTxt) ;
	}

	delete pStrTok;
	return ;
}
void CGame::AdminOrder_UnsummonAll(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	// v2.17 2002-8-5 모든 몬스터를 죽인다. 그러나 아이템은 나오지 않는다. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if (m_pNpcList[i]->m_bIsKilled == FALSE) 
		{
			m_pNpcList[i]->m_bIsSummoned = TRUE ; 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
		}
	}
}


// Stalker, Hellclaw, Tigerworm, Gagoyle, Demon 을 죽인다. 
void CGame::AdminOrder_UnsummonBoss(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	// 2002-7-4
	// 모든 배틀골램과 고즈핸드ㅡ, 데몬, 가고일, 헬클라우드, 타이거웜을 죽인다. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if (((m_pNpcList[i]->m_sType == 31) || // Demon
		(m_pNpcList[i]->m_sType == 49)  || // Hellclaw
		(m_pNpcList[i]->m_sType == 45)  || // GHKABS
		(m_pNpcList[i]->m_sType == 47) || // BG
		(m_pNpcList[i]->m_sType == 50) || // Tigerworm
		(m_pNpcList[i]->m_sType == 52) || // Gagoyle
		(m_pNpcList[i]->m_sType == 66) || // Wyvern
		(m_pNpcList[i]->m_sType == 73) || // Fire-Wyvern
		(m_pNpcList[i]->m_sType == 81)) && // Abaddon
			(m_pNpcList[i]->m_bIsKilled == FALSE)){ 
			// v2.17 2002-8-5 운영자 명령어로 죽이면 아이템이 나오지 않게 수정한다.
			m_pNpcList[i]->m_bIsSummoned = TRUE ; 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
		}
	}
}

char CGame::_cGetSpecialAbility(int iKindSA)
{
 char cSA;

	switch (iKindSA) {
	case 1: 
		switch (iDice(1,2)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		}
		break;

	case 2:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 3:
		switch (iDice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		case 4: cSA = 6; break;
		}
		break;

	case 4:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		}
		break;

	case 5:
		switch (iDice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		case 4: cSA = 8; break;
		}
		break;

	case 6:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 7:
		switch (iDice(1,3)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		}
		break;

	case 8:
		switch (iDice(1,5)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		case 4: cSA = 3; break;
		case 5: cSA = 8; break;
		}
		break;

	case 9:
		cSA = iDice(1,8);
		break;
	}

	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   cCity, * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue;
 class  CStrTok * pStrTok;
 BOOL   bMaster;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
   
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "aresden",7) != 0)&&(memcmp(m_pClientList[iClientH]->m_cMapName, "elvine",6) != 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 2)) return;
	GetLocalTime(&SysTime);
	if ((m_pClientList[iClientH]->m_iAdminUserLevel == 2) && ((SysTime.wDayOfWeek != 2)&&(SysTime.wDayOfWeek != 4))) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel == 2) cCity = 10;
	else cCity = -1;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();
	
	if (token != NULL) 
		 iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;

	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	// 메시지 출력 
	wsprintf(G_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	wsprintf(G_cTxt, "GM Order(%s): Summon NPC(%s)-Count(%d)",m_pClientList[iClientH]->m_cCharName, cNpcName, iNum);
	bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		// Master Mob을 생성한다.
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, cCity, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave Mob들을 생성한다.
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			// v1.411 몬스터의 특수 특성치를 입력한다. 
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, cCity, FALSE, FALSE, FALSE) == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// Slave모드로 전환.
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	delete pStrTok;
}


// 2002-10-24 3주년 이벤트 : 3주년 기념 반지 준다.
void CGame::CheckSpecialEventThirdYear(int iClientH)
{
 class		CItem * pItem;
 char		cItemName[21];
 int		iEraseReq;
 SYSTEMTIME SysTime;

 int iRet;
 short * sp;
 char  * cp, cData[100];
 DWORD * dwp;
 WORD  * wp;


	if (m_pClientList[iClientH] == NULL)
		return;

	// 시민권이 있는 사용자만 준다.
	if ( m_pClientList[iClientH]->m_cSide == 0)
		return;

	// 2002-10-31 레벨 15이상만
	if ( m_pClientList[iClientH]->m_iLevel < 15 )
		return;

#ifndef DEF_TESTSERVER
	// 기간 : 2002-11-01 ~ 2002-11-30 (11월 한달간)
	GetLocalTime(&SysTime);
	if( SysTime.wYear != 2002 || SysTime.wMonth != 11 )
		return;
#endif
	
	// v1.181 2002-10-24 3주년 이벤트 : 3주년 기념반지 제공
	if (m_pClientList[iClientH]->m_iSpecialEventID != 20021101) {
		
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, DEF_ITEMNAME_MEMORIALRING3);
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// 아이템 리스트상에 없다.
			delete pItem;
			pItem = NULL;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 에러 방지용 코드
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// testcode 로그파일에 기록한다.
				wsprintf(G_cTxt, "(*) Get 3주년기념반지 : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				// 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;

				// 아이템 받았으므로 클리어.
				m_pClientList[iClientH]->m_iSpecialEventID = 20021101;

				// v1.41 희귀 아이템이라면 로그를 남긴다.
				_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

				// 클라이언트에 알린다.
				ZeroMemory(cData, sizeof(cData));

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

				// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
				*cp = 1;
				cp++;

				memcpy(cp, pItem->m_cName, 20);
				cp += 20;

				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
				cp++;

				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				 
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor; // v1.4
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				
				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;

				// 아이템 정보 전송 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 메시지를 보낼때 에러가 발생했다면 제거한다.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
	}

} // CheckSpecialEventThirdYear


void CGame::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	_iForcePlayerDisconect();
}
void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem;
	char  cColor, cItemName[21];
	BOOL  bIsGold;
	int   iGenLevel, iResult, iItemID, iItemprobability, iGoldProbMax, iSecondProb, iGoldProb2;
	DWORD dwType, dwValue;
	double dTmp1, dTmp2, dTmp3;

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((cAttackerType != DEF_OWNERTYPE_PLAYER) || (m_pNpcList[iNpcH]->m_bIsSummoned == TRUE)) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = FALSE;

	switch (m_pNpcList[iNpcH]->m_sType) {
	case 21: // Guard
	case 34: // Dummy
	case 40: // CRUSADE
	case 64: // Crop
	case 87: // CT-elv y ares
    case 89: // AGC-elv y ares
	case 91: // Gates
	return;
	}

	// 6500 default; the lower the greater the Weapon/Armor/Wand Drop
  
    iSecondProb = 5000;


    if (m_pClientList[sAttackerH]->m_cSide == m_sLastHeldenianWinner)
	{
		iItemprobability = 5500; 
    }
	else
	{
		iItemprobability = 7500;
    }



	iGoldProbMax = 25;

	iGoldProb2 = 3500;



	// 6500 default; the lower the greater the Weapon/Armor/Wand Drop
	if (iDice(1,11000) >= iItemprobability) {
		// 35% Drop 60% of that is gold
		// 35% Chance of drop (35/100)
		if (iDice(1,11000) <= iGoldProb2) {
			strcpy(cItemName, "Gold");
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) {
				delete pItem;
				return;	
			}
			pItem->m_dwCount = (DWORD)(iDice(1, m_pNpcList[iNpcH]->m_iExpDice*iGoldProbMax)) + m_pNpcList[iNpcH]->m_iExpDice ; 
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}
	}
		else {
			// 9000 default; the lower the greater the Weapon/Armor/Wand Drop
			// 35% Drop 40% of that is an Item 
			if (iDice(1,10000) <= iSecondProb) {
				// 40% Drop 90% of that is a standard drop
				// Standard Drop Calculation: (35/100) * (40/100) * (90/100) = 12.6%
				iResult = iDice(1,10000);
				if ((iResult >= 1) && (iResult <= 3000))          dwValue = 1;
				else if ((iResult >= 3001) && (iResult <= 4000))  dwValue = 2;
				else if ((iResult >= 4001) && (iResult <= 5500))  dwValue = 3;
				else if ((iResult >= 5501) && (iResult <= 6700))  dwValue = 4;
				else if ((iResult >= 6701) && (iResult <= 8500))  dwValue = 5;
				else if ((iResult >= 8501) && (iResult <= 8999))  dwValue = 6;
				else if ((iResult >= 9000) && (iResult <= 10500))  dwValue = 7;
				else if ((iResult >= 10501) && (iResult <= 11200)) dwValue = 8;
				else if ((iResult >= 11201) && (iResult <= 13000)) dwValue = 9;


				//default

				/*				else if ((iResult >= 3001) && (iResult <= 4000))  dwValue = 2;
				else if ((iResult >= 4001) && (iResult <= 5500))  dwValue = 3;
				else if ((iResult >= 5501) && (iResult <= 7000))  dwValue = 4;
				else if ((iResult >= 7001) && (iResult <= 8500))  dwValue = 5;
				else if ((iResult >= 8501) && (iResult <= 9100))  dwValue = 6;
				else if ((iResult >= 9101) && (iResult <= 9800))  dwValue = 7;
				else if ((iResult >= 9801) && (iResult <= 10000)) dwValue = 8;
				else if ((iResult >= 10001) && (iResult <= 12000)) dwValue = 9;*/

				switch (dwValue) {	
						case 1: iItemID = 95; break; // Green Potion
						case 2: iItemID = 91; break; // Red Potion
						case 3: iItemID = 93; break; // Blue Potion
						case 4: iItemID = 390; break; // power green
						case 5: iItemID = 92; break; // Big Red Potion
						case 6: iItemID = 94; break; // Big Blue Potion
						case 7: 
						switch(iDice(1,2)) {
						case 1: iItemID = 390; break; // Power Green Potion
						case 2: iItemID = 390;  break; // Power Green Potion 
						}
						break;
						case 8: 
						switch(iDice(1,50)) {
						case 1:
                        /*iItemID = 3016; // ContribBall(+700)
						break;
						case 2:
                        iItemID = 3016; // ContribBall(+700)
						break;
						*/
						case 3:// 10%
						switch (iDice(1,3))
						{
							case 1: iItemID = 780; break; // Red Candy
							case 2: iItemID = 781; break; // Blue Candy
							case 3: iItemID = 782; break; // Green Candy
						}
					break;
					/*	case 4:
                        iItemID = 3016; // ContribBall(+700)
						break;
						*/
					case 5:// 10%
						switch (iDice(1,3))
						{
							case 1: iItemID = 656; break; // Xelima Stone
							case 2: iItemID = 657; break; // Merien Stone
							case 3: iItemID = 650; break; // Zemstone of Sacrifice
						}
					break;
						break;
						case 6:
							iItemID = 650; break; // Zemstone of Sacrifice
						break;
						}
						break;
						case 9: 		
							SYSTEMTIME SysTime;
							GetLocalTime(&SysTime);
							if (((short)SysTime.wMonth == 12) && (m_pNpcList[iNpcH]->m_sType == 61 || 55)) {
								switch(iDice(1,3)) {
						case 1: iItemID = 780; break; // Red Candy
						case 2: iItemID = 781; break; // Blue Candy
						case 3: iItemID = 782; break; // Green Candy
						//case 4: iItemID = 3016;  break; // ContribBall(+700)
								}
							}
							break;
				}
				// If a non-existing item is created then delete the item
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}
			}
			else {
				// Valuable Drop Calculation: (35/100) * (40/100) * (10/100) = 1.4%
				// Define iGenLevel using Npc.cfg#
				switch (m_pNpcList[iNpcH]->m_sType) {

				case 10: // Slime
				case 16: // Giant-Ant
				case 22: // Amphis
				case 55: // Rabbit
				case 56: //	Cat
					iGenLevel = 1;
					break;

				case 11: // Skeleton
				case 14: // Orc, Orc-Mage
				case 17: // Scorpion
				case 18: // Zombie
					iGenLevel = 2;
					break;

				case 12: // Stone-Golem
				case 23: // Clay-Golem
					iGenLevel = 3;
					break;

				case 27: // Hellbound
				case 61: // Rudolph
				case 74: // Giant-Crayfish
					iGenLevel = 4;
					break; 

				case 13: // Cyclops
				case 28: // Troll
				case 53: // Beholder
				case 60: // Cannibal-Plant
				case 62: // DireBoar
					iGenLevel = 5;
					break;

				case 29: // Orge
				case 33: // WereWolf
				case 48: // Stalker
				case 54: // Dark-Elf
				case 65: // Ice-Golem 

					iGenLevel = 6;
					break;

				case 30: // Liche
				case 63: // Frost
				case 79: // Nizzie
					iGenLevel = 7;
					break;

				case 31: // Demon
				case 32: // Unicorn
				case 49: // Hellclaw
				case 50: // Tigerworm
				case 52: // Gagoyle
				case 70: // barlog
				case 71: // Centaurus
				case 72: // yeti
				case 78: // pitlord
                	iGenLevel = 8;
					break; 

				case 58: // MountainGiant
				case 77: // MasterMage-Orc
					iGenLevel = 9;
					break;

				case 59: // Ettin
				case 75: // Giant-Lizard
					iGenLevel = 10;
					break;
				}	

				if (iGenLevel == 0) return;

				// Weapon Drop: 
				// 1.4% chance Valuable Drop 60% that it is a Weapon
				if (iDice(1,10000) <= 6000) {
					if (iDice(1,10000) <= 8000) {
						// 70% the Weapon is Melee
						switch (iGenLevel) { 

case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
					switch (iDice(1,3)) { 
				case 1: iItemID = 1;  break; // Dagger
				case 2: iItemID = 8;  break; // ShortSword
				case 3: iItemID = 59; break; // LightAxe
					}
					break; 

				case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
					switch (iDice(1,6)) {
						case 1: iItemID = 12;  break; // MainGauche
						case 2: iItemID = 15;  break; // Gradius
						case 3: iItemID = 65;  break; // SexonAxe
						case 4: iItemID = 62;  break; // Tomahoc
						case 5: iItemID = 23;  break; // Sabre
						case 6: iItemID = 31;  break; // Esterk
					}
					break;

				case 3: // Stone-Golem, Clay-Golem
					switch (iDice(1,4)) {
				case 1: iItemID = 17;  break; // LongSword
				case 2: iItemID = 68;  break; // DoubleAxe
				case 3: iItemID = 23;  break; // Sabre
				case 4: iItemID = 31;  break; // Esterk
					}
					break;

				case 4: // Hellbound, Rudolph
					switch (iDice(1,5)) {
				case 1: iItemID = 23;  break; // Sabre
				case 2: iItemID = 25;  break; // Scimitar
				case 3: iItemID = 28;  break; // Falchion
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
					}
					break;

				case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
					switch (iDice(1,3)) {
				case 1: iItemID = 31;  break; // Esterk
				case 2: iItemID = 34;  break; // Rapier
				case 3: iItemID = 71;  break; // WarAxe
					}
					break;

				case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
					switch (iDice(1,5)) {
				case 1: iItemID = 50;  break; // GreatSword
				//case 2: iItemID = 3016;  break; // ContribBall(+700)
				case 3: iItemID = 46;  break; // Claymore
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 3016; break; // ContribBall(+700)
					}
					break;

				case 7: // Liche, Frost
					switch (iDice(1,4)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 54;  break; // Flameberge
				case 3: iItemID = 31;  break; // Esterk
				case 4: iItemID = 34;  break; // Rapier
					}
					break;

				case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
					switch (iDice(1,5)) {
				case 1: iItemID = 3016;  break; // ContribBall(+700)
				case 2: iItemID = 615;  break; // Flameberge
				case 3: iItemID = 560; break; // BattleAxe
			//	case 4: iItemID = 2096;  break; // ArmorDye(Violet)
			//	case 5: iItemID = 734;  break; // RingofArcmage
				case 6: iItemID = 615;  break; // GiantSword
				//case 7: iItemID = 2091; break; // ContribBall(+700) ahora DyeArmor(Indigo)
					}
					break;

				case 9: // MountainGiant
					switch (iDice(1,6)) {
				case 1: iItemID = 23;  break; // Sabre
				case 2: iItemID = 25;  break; // Scimitar
				case 3: iItemID = 28;  break; // Falchion
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 760; break; // Hammer
					}
					break;

				case 10: // Ettin
					switch (iDice(1,5)) {
					case 1: iItemID = 46;  break; // Claymore
					case 2: iItemID = 31;  break; // Esterk
					case 3: iItemID = 761;  break; // bh
					case 4: iItemID = 3016; break; // ContribBall(+700)
					case 5: iItemID = 761; break; // GiantBattleHammer ahora bh
					}
					break;


						}
					}
					else {
						// 30% the weapon is a Wand
						switch (iGenLevel) {

						case 2: 
						case 3:
							iItemID = 258; break; // MagicWand(MS0)
						case 4: 
						case 5: 
						case 6: 
							iItemID = 257; break; // MagicWand(MS10)
						case 7:
						case 8:
							iItemID = 256; break; // MagicWand(MS20)
						case 9:
						case 10:
							break;
						}	
					}
				}
				else {
					// 1.4% chance Valuable Drop 40% that drop is an Armor/Shield
					switch (iGenLevel) {

					case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
						switch (iDice(1,3)) 
						{
							case 1: iItemID = 79;  break; // WoodShield
							case 2: iItemID = 80;  break; // LeatherShield
							case 3: 
								switch (iDice(1,2)) 
								{
									case 1: iItemID = 450; break; // Shoes
									case 2: iItemID = 451; break; // Botas
								}
						}
						break; 

					case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
						switch (iDice(1,3)) 
						{ 
							case 1: iItemID = 80;  break; // LeatherShield
							case 2: iItemID = 81;  break; // TargeShield
							case 3: 
								switch (iDice(1,2)) 
								{
									case 1: iItemID = 450; break; // Shoes
									case 2: iItemID = 451; break; // Botas
								}
						}
						break; 

					case 3: // Stone-Golem, Clay-Golem
						iItemID = 81; // TargeShield
						break;

					case 4: // Hellbound, Rudolph
						switch (iDice(1,5)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
							case 3: iItemID = 461; break; // ChainHose(M)
							case 4: iItemID = 482; break; // ChainHose(W)
							case 5: iItemID = 83;  break; // BlondeShield
						}
						break;

					case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
						switch (iDice(1,3)) {
							case 1: iItemID = 455; break; // LeatherArmor(M)
							case 2: iItemID = 475; break; // LeatherArmor(W)
							case 3: iItemID = 84;  break; // IronShield
						}
						break;

					case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,2)) {
							case 1: iItemID = 456; break; // ChainMail(M)
							case 2: iItemID = 476; break; // ChainMail(W)
						}
						break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
						}
						break;
						case 3: iItemID = 85; break; // LagiShield
						case 4: switch(iDice(1,8)) {
							case 1: iItemID = 750; break; // Horned-Helm(M)
							case 2: iItemID = 751; break; // Wings-Helm(M)
							case 3: iItemID = 754; break; // Horned-Helm(W)
							case 4: iItemID = 755; break; // Wings-Helm(W)
							case 5: iItemID = 752; break; // Wizard-Cap(M) 
							case 6: iItemID = 753; break; // Wizard-Hat(M)
							case 7: iItemID = 756; break; // Wizard-Cap(W) 
							case 8: iItemID = 757; break; // Wizard-Hat(W) 
						}
						break;	
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
						}
						break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 461; break; // ChainHose(M)
							case 2: iItemID = 482; break; // ChainHose(W)
						}
						break;
						}
						break;


					case 7: // Liche, Frost
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,2)) {
							case 1: iItemID = 457; break; // ScaleMail(M)
							case 2: iItemID = 477; break; // ScaleMail(W)
							}
							break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 86; break; // KnightShield
						case 4: iItemID = 87; break; // TowerShield
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 600; break; // Helm(M)
							case 2: iItemID = 602; break; // Helm(M)
							}
							break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 601; break; // Full-Helm(M)
							case 2: iItemID = 603; break; // Full-Helm(M)
							}
							break;
						}
						break;

					case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
						iItemID = 402; // Cape
						break;

					case 9:
					case 10:
						break;
					}
				}
				// 0-None 1-챠™챙쨈챗쨍째챘챘짱쨍챙짠챙쨋챗째 2-챙짚챘┚큄짢챗쨀쩌 3-챙▣챙  
				// 5-챘짱쩌챙짼짤챙 6-챗째챘짼쩌챙큄쨈 7-챙챘짝짭챠◑ 8-챗째▣™챘 9-챗쨀챘챘짭쨍챘짧┚ 10-챘짠챘짼 챙짹챗쨀쨉챙
				// 챙™챙쨈챠┖챙 챘짠챘짚챗쨀 
				pItem = new class CItem;
				// 챗쨍째챘쨀쨍 챠쨔챙짹챙쩌챘징 챙™챙쨈챠┖ 챙챙짹 
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}


/*if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					// 째첩째 쨔짬짹창쨌첫쩔징 쨘쨩 쩌철 쨈 짖쨉쨩챌쨍짝 쩌짹 
					// 째징쨘짯쩔챤(3%) 째짯짯쨉(7%) 쨩챙(15%) 쨔쨍(20%) 짚(20%) 쨉쨋(16%) 쩔쨔쨍짰(16%) 째챠쨈챘쨔짰쨍챠(3%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 299)) {
						dwType = 6; 
						cColor = 2; 
					}
					else if ((iResult >= 50) && (iResult <= 999)) {
						dwType = 8; 
						cColor = 3;
					}
					else if ((iResult >= 50) && (iResult <= 1000)) {
						dwType = 1;
						cColor = 5;
					}
					else if ((iResult >= 500) && (iResult <= 1000)) {
						dwType = 5;
						cColor = 1;
					}
					else if ((iResult >= 3500) && (iResult <= 4499)) {
						dwType = 3;
						cColor = 7;
					}
					else if ((iResult >= 4500) && (iResult <= 6099)) {
						dwType = 2;
						cColor = 4;
					}
					else if ((iResult >= 1500) && (iResult <= 3000)) {
						dwType = 7;
						cColor = 6;
					}
					else if ((iResult >= 1500) && (iResult <= 3000)) {
						dwType = 9;
						cColor = 8;
					}

  //MODIFICACION EN LOS DROPS (MAS ALTO)
					*/

				//DROP ORIGINAL
				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					// 째첩째 쨔짬짹창쨌첫쩔징 쨘쨩 쩌철 쨈 짖쨉쨩챌쨍짝 쩌짹 
					// 째징쨘짯쩔챤(3%) 째짯짯쨉(7%) 쨩챙(15%) 쨔쨍(20%) 짚(20%) 쨉쨋(16%) 쩔쨔쨍짰(16%) 째챠쨈챘쨔짰쨍챠(3%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 299)) {
						dwType = 6; 
						cColor = 2; 
					}
					else if ((iResult >= 300) && (iResult <= 999)) {
						dwType = 8; 
						cColor = 3;
					}
					else if ((iResult >= 500) && (iResult <= 1000)) {
						dwType = 1;
						cColor = 5;
					}
					else if ((iResult >= 1500) && (iResult <= 3499)) {
						dwType = 5;
						cColor = 1;
					}
					else if ((iResult >= 3500) && (iResult <= 4499)) {
						dwType = 3;
						cColor = 7;
					}
					else if ((iResult >= 4500) && (iResult <= 6099)) {
						dwType = 2;
						cColor = 4;
					}
					else if ((iResult >= 1500) && (iResult <= 3000)) {
						dwType = 7;
						cColor = 6;
					}
					else if ((iResult >= 1500) && (iResult <= 3000)) {
						dwType = 9;
						cColor = 8;
					}

					// 쩐 쨩철쨩처 쨌 
					pItem->m_cItemColor = cColor;

					// 째징쨘짯쩔챤, 째짯짯쨉, 쨩챙, 쨔쨍, 짚, 쨉쨋, 쩔쨔쨍짰, 째챠쨈챘쨔짰쨍챠
					// 쩐 Main 짱쩌쨘징 짚쨉쨉째짧 쨌 

					// 쩐 Sub 짱쩌쨘징 짚쨉쨉째짧 쨌 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29700))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29700) && (iResult < 29880))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29880) && (iResult < 29950))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29950) && (iResult < 29990))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29990) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// 쨔짬짹창 Main 짱쩌쨘징쩔징 쨉청쨋처 쩌철징 쨘쨍짚 
					switch (dwType) {
					case 1: // 쨩챙 쨍째 첬 +5
						if (dwValue <= 5) dwValue = 5;
						break; 
					case 2: // 쨉쨋 쨍째 첬 +20
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 6: // 째챈쨌짰짯 첬  +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // 쩌철쨍챠 첬 +14%					
						if (dwValue <= 2) dwValue = 2;
						break; 
					}
					// v2.03 912 쩐 쩌철 2쨋짠 짱쩌쨘징 쨈챘째짧쨘 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					// 쩐 Main 짱쩌쨘징, 째짧 쨌
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// 쩐 Sub 짱쩌쨘징째징 쨌쨉 짰쨌체쨘 40%
					if (iDice(1,10000) >= 6000) {

						// 챰짹 쩐 Sub 짱쩌쨘징 쩔째첬 쩐쨌첫: 
						//째징 쨉쨋쩌쨘첬(1), 째징 쨍챠째짧(2), 째징 쨔챈쩐챤째짧(3), HP 쨍쨘쨔쨌짰 째징(4), SP 쨍쨘쨔쨌짰 째징(5)
						//MP 쨍쨘쨔쨌짰 째징(6), 째징 쨍쨋쨔첵첬(7), 쨔째쨍짰 쨈챘쨔철 챠쩌철(8), 쨍쨋쨔첵 쨈챘쨔철 챠쩌철(9)
						//쩔짭쨍 쨈챘쨔철 째징(10), 쨈천 쨍쨔쨘 째챈챔징(11), 쨈천쨍쨔쨘 Gold(12)

						// 쨔짬짹창쨌첫짹창 쨋짠쨔짰쩔징 째첩째 쨍챠 째징(50%), 쩔짭쨍 쨍째징 천째징(35%), 쨈천 쨍쨔쨘 Gold(10%), 쨈천 쨍쨔쨘 째챈챔징(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						// 쩐 Sub 짱쩌쨘징 짚쨉쨉째짧 쨌 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29700))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29700) && (iResult < 29880))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29880) && (iResult < 29950))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29950) && (iResult < 29990))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29990) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

						// 쨔짬짹창 Sub 짱쩌쨘징쩔징 쨉청쨋처 쩌철징 쨘쨍짚 
						switch (dwType) {
						case 2: // 째첩째쨍챠 첬 +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // 쩔짭쩌 쨍째 첬 +1 쨈챘 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp쨈 쨔짬쨋째 +20%
							dwValue = 2;
							break; 
						case 12: // Gold쨈 쨔짬쨋째 +50%
							dwValue = 5;
							break; 
						}
						// v2.03 912 쩐 쩌철 2쨋짠 짱쩌쨘징 쨈챘째짧쨘 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						// 쩐 Sub 짱쩌쨘징 쨌
						dwType  = dwType << 12;
						dwValue = dwValue << 8;

						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					// 쨍쨋쨔첵 째첩째 쨔짬짹창쨌첫쩔징 쨘쨩 쩌철 쨈 짖쨉쨩챌쨍짝 쩌짹 10, 11
					// 쨍쨋쨔첵 쩌쨘째첩(100%) <- 철챌 쨍쨋쨔첵 철쩔징 쨘쨩 쩌철 쨈 쩔채쩌째징 째 쨔쩔징 쩐첩쨈.
					dwType = 10;
					cColor = 5;

					// 쩐 쨩철쨩처 쨌 
					pItem->m_cItemColor = cColor;
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29700))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29700) && (iResult < 29880))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29880) && (iResult < 29950))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29950) && (iResult < 29990))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29990) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// v2.03 912 쩐 쩌철 2쨋짠 짱쩌쨘징 쨈챘째짧쨘 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					// 쨔챈쩐챤짹쨍 Main 짱쩌쨘징, 째짧 쨌
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// 쩐 Sub 짱쩌쨘징째징 쨌쨉 짰쨌체쨘 40%
					if (iDice(1,10000) >= 6000) {

						// 챰짹 쩐 Sub 짱쩌쨘징 쩔째첬 쩐쨌첫: 
						//째징 쨉쨋쩌쨘첬(1), 째징 쨍챠째짧(2), 째징 쨔챈쩐챤째짧(3), HP 쨍쨘쨔쨌짰 째징(4), SP 쨍쨘쨔쨌짰 째징(5)
						//MP 쨍쨘쨔쨌짰 째징(6), 째징 쨍쨋쨔첵첬(7), 쨔째쨍짰 쨈챘쨔철 챠쩌철(8), 쨍쨋쨔첵 쨈챘쨔철 챠쩌철(9)
						//쩔짭쨍 쨈챘쨔철 째징(10), 쨈천 쨍쨔쨘 째챈챔징(11), 쨈천쨍쨔쨘 Gold(12)

						// 쨔짬짹창쨌첫짹창 쨋짠쨔짰쩔징 째첩째 쨍챠 째징(50%), 쩔짭쨍 쨍째징 천째징(35%), 쨈천 쨍쨔쨘 Gold(10%), 쨈천 쨍쨔쨘 째챈챔징(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						// 쩐 Sub 짱쩌쨘징 짚쨉쨉째짧 쨌 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29700))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29700) && (iResult < 29880))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29880) && (iResult < 29950))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29950) && (iResult < 29990))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29990) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

						// v2.03 912 쩐 쩌철 2쨋짠 짱쩌쨘징 쨈챘째짧쨘 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						// 쨔짬짹창 Sub 짱쩌쨘징쩔징 쨉청쨋처 쩌철징 쨘쨍짚 
						switch (dwType) {
						case 2: // 째첩째쨍챠 첬 +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // 쩔짭쩌 쨍째 첬 +1 쨈챘 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp쨈 쨔짬쨋째 +20%
							dwValue = 2;
							break; 
						case 12: // Gold쨈 쨔짬쨋째 +50%
							dwValue = 5;
							break; 
						}

						// 쩐 Sub 짱쩌쨘징 쨌
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {
					// 쨔챈쩐챤짹쨍쩔징 쨍쨈 짖쨉쨩챌쩔 짱쩌쨘징쨍짝 쩌짹, 쨈챌쨈.

					// 째짯짯쨉(60%) 째징쨘짯쩔챤 (30%) 쨍쨋쨀짧 쨘짱짱(5%) 쨩챙 챈체(5%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
					else if ((iResult >= 6000) && (iResult <= 8999))  dwType = 6;
					else if ((iResult >= 9000) && (iResult <= 9554))  dwType = 11; //dwType = 11;
					else if ((iResult >= 9555) && (iResult <= 10000)) dwType = 12; //dwType = 12;

					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29700))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29700) && (iResult < 29880))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29880) && (iResult < 29950))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29950) && (iResult < 29990))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29990) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// 쨔챈쩐챤짹쨍 Main 짱쩌쨘징쩔징 쨉청쨋처 쩌철징 쨘쨍짚 
					switch (dwType) {
					case 6: // 째챈쨌짰짯 첬 +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // 쩌철쨍챠 첬 +14%
						if (dwValue <= 2) dwValue = 2;
						break; 

					case 11:
					case 12:
						// v2.04
						dwValue = (dwValue+1) / 2;
						if (dwValue < 1) dwValue = 1;
						if ((iGenLevel <= 3) && (dwValue > 2)) dwValue = 2;
						break;
					}
					// v2.03 912 쩐 쩌철 2쨋짠 짱쩌쨘징 쨈챘째짧쨘 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;
					
					if ((pItem->m_sIDnum == 402) && (dwValue == 8)) dwValue = 1;
					if ((pItem->m_sIDnum == 402) && (dwValue == 9)) dwValue = 1;

					// 쨔챈쩐챤짹쨍 Main 짱쩌쨘징, 째짧 쨌
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// 쨔챈쩐챤짹쨍 Sub 짱쩌쨘징째징 쨌쨉 짰쨌체쨘 40%
					if (iDice(1,10000) >= 6000) {

						// 챰짹 쩐 Sub 짱쩌쨘징 쩔째첬 쩐쨌첫: 
						//째징 쨉쨋쩌쨘첬(1), 째징 쨍챠째짧(2), 째징 쨔챈쩐챤째짧(3), HP 쨍쨘쨔쨌짰 째징(4), SP 쨍쨘쨔쨌짰 째징(5)
						//MP 쨍쨘쨔쨌짰 째징(6), 째징 쨍쨋쨔첵첬(7), 쨔째쨍짰 쨈챘쨔철 챠쩌철(8), 쨍쨋쨔첵 쨈챘쨔철 챠쩌철(9)
						//쩔짭쨍 쨈챘쨔철 째징(10), 쨈천 쨍쨔쨘 째챈챔징(11), 쨈천쨍쨔쨘 Gold(12)

						// 쨔챈쩐챤짹쨍 짹창 쨋짠쨔짰쩔징 
						// 째징쨔챈쩐챤째짧(10%) 째징쨉쨋쩌쨘첬(30%)    SP쨍쨘쨔째징(15%)  HP쨍쨘쨔째징(10%) 
						// MP쨍쨘쨔 째징(10%) 째징쨍쨋쨔첵첬(15%) 쨔째쨍짰쨈챘쨔철챠쩌철(3%) 쨍쨋쨔첵쨈챘쨔철챠쩌철(3%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 999))           dwType = 3;
						else if ((iResult >= 1000) && (iResult <= 3999))  dwType = 1;
						else if ((iResult >= 4000) && (iResult <= 5499))  dwType = 5;
						else if ((iResult >= 5500) && (iResult <= 6499))  dwType = 4;
						else if ((iResult >= 6500) && (iResult <= 7499))  dwType = 6;
						else if ((iResult >= 7500) && (iResult <= 9399))  dwType = 7;
						else if ((iResult >= 9400) && (iResult <= 9799))  dwType = 8;
						else if ((iResult >= 9800) && (iResult <= 10000)) dwType = 9;

						// 쩐 Sub 짱쩌쨘징 짚쨉쨉째짧 쨌 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29700))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29700) && (iResult < 29880))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29880) && (iResult < 29950))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29950) && (iResult < 29990))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29990) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

						// 쨔챈쩐챤짹쨍 Sub 짱쩌쨘징쩔징 쨉청쨋처 쩌철징 쨘쨍짚 
						switch (dwType) {
						case 1: // 쨉쨋쩌쨘첬 첬 +21%
						case 3: // 쨔째쨍짰쨔챈쩐챤 첬 +21%
						case 7: // 쨍쨋쨔첵 첬 첬 +21%
						case 8: // 쨔째쨍짰챠쩌철 첬 +9%
						case 9: // 쨍쨋쨔첵챠쩌철 첬 +9%
							if (dwValue <= 3) dwValue = 3;
							break; 
						}
						// v2.03 912 쩐 쩌철 2쨋짠 짱쩌쨘징 쨈챘째짧쨘 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						// 쩐 Sub 짱쩌쨘징 쨌
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				// 챘짠챙짠챘짠걘쩌챘징 챠쨔챙짹챙쨔챘짜쩌 챠쨔챙 챙™챙쨈챠┖챙 챘짠탑챗짼챘 챘쨀챗짼쩍 
				_AdjustRareItemValue(pItem);
			}
		}

		// 챙™챙쨈챠┖챙 챗쨀챙 챙쩍챘 챙탑┚ヂ짜 
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		//pItem->m_sTouchEffectValue3 = timeGetTime();
		// 챘짠챙짠챘짠 챙짬챙탑챘 챙™챙쨈챠┖ 챙챙짹 챙뷜, 챙쩌	
		SYSTEMTIME SysTime;
		char cTemp[256];
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);

		// 챙™챙쨈챠┖챙 챙챙탑챘 챙챙쨔챙 챘짢챙쨈챘짢챘짝째챘뮤. 
		m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, 
			m_pNpcList[iNpcH]->m_sY, 
			pItem);

		// 챘뮤ㅓヂΒ 챠쨈챘쩌챙쨈챙쨍챠쨍챙챗짼 챙™챙쨈챠┖챙쨈 챘짢챙쨈챙짠 챗짼챙 챙◑챘짝째챘뮤. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
			m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

		// 챘징챗쨌쨍 챘짢챗쨍쨈챘뮤.
		_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, NULL, pItem);
	}
}


BOOL CGame::NpcDeadItemGeneratorWithItemEvent(int iNpcH, short sAttackerH, char cAttackerType)
{
 class CItem * pItem;
 char  cTemp[20];
 int   i, j, iT1, iT2, iT3;
 int	iNumMob;
 SYSTEMTIME SysTime;

	// v2.04 아이템 이벤트용 특수 코드
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{
		GetLocalTime(&SysTime);
		for ( i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++ )
		if (// 날짜 같고,
			( SysTime.wMonth == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iMonth) &&
			( SysTime.wDay   == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDay) &&
			// 아이템 이벤트 개수가 남았으면.
			( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum )
		)
		{

			iNumMob = m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iNumMob;

			// item event의 대상이 되는 몬스터가 있는지 검색
			for( j=0; j<iNumMob; j++) {
				if( strcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cMob[j], m_pNpcList[iNpcH]->m_cNpcName) == 0)
					break;
			}

			// 리스트에 없는 몬스터다.
			if( j == iNumMob )
				continue;

			if (SysTime.wHour < 12 ) {
				if(iDice(1,9000) != 6433)
					continue;
			} else if (SysTime.wHour < 18 ) {
				if(iDice(1,3000) != 1433)  
					continue;
			} 


		// 날짜가 일치하고 만들어야할 수량이 남아 있는 상태라면
			// : 24시간을 분단위로 쪼개서 처리. 중복 생성을 막기 위해 주사위를 굴린다.
			iT1 = 1440 / m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum;
			iT2 = iT1 * m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum;
			iT3 = (SysTime.wHour*60) + SysTime.wMinute;

			// 첫 번째 아이템 생성 시기는 iT1 / 2 이후 시간이다.
			if ( (iT1 / 2) > iT3 )
				continue;

			if ( ((iT2 <= iT3) && (iT3 <= iT2 + iT1)) || (iT2+iT1 < iT3) ) {
				// 구간이 일치한다. 아이템 생성
				// 아이템을 만들고

				// 약간의 다이스
				// 300개 이상은 안된다.
				int	iT4 = iT1 / 4;
				if( (iT4 > 10) && iDice(1, iT4) != 5 )
					continue;

				pItem = new class CItem;
				if (_bInitItemAttr(pItem, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName) == FALSE) {
					delete pItem;
					pItem = NULL;
				}
				else {
					// 아이템에 고유 코드 입력 
					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
		
#ifdef DEF_LOGTIME
					pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
					// 마지막 숫자는 아이템 생성 월, 일
					ZeroMemory(cTemp, sizeof(cTemp));
//					wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
					wsprintf(cTemp, "%d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif
					
					// v2.181 2002-10-22 #1 3주년 이벤트 : 소원구
					/*
		.			if( pItem->m_sIDnum >= 651 &&  pItem->m_sIDnum <= 655 )
					{
						// 이벤트 기간 11월 1일 ~ 7일 (1주일)
						if(  SysTime.wYear == 2002 && SysTime.wMonth == 11 && (SysTime.wDay >= 1 && SysTime.wDay <=7 ) )
							pItem->m_sItemSpecEffectValue2 = 113; // 3주년 이벤트용 소원구
					}
					*/ // 2002-11-08 제거
					
					// 아이템을 서있는 위치에 떨어뜨린다.
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX,
								                                           m_pNpcList[iNpcH]->m_sY,
																		   pItem);

					// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
								                m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
										        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

					// 로그 남긴다.
					_bItemLog(DEF_ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
					wsprintf(G_cTxt,"Event Item (%s)",pItem->m_cName) ;
					PutDebugMsg(G_cTxt);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum++;

					return TRUE;
				}
				
				// return FALSE;
			}
		}
	} // 아이템 이벤트용

	return FALSE;
} // NpcDeadItemGeneratorWithItemEvent

// 2002-10-24 해당 아이템이 아이템 이벤트에 등록되어 있고 type이 0인지 검사한다.
// 수정 필요하다. 오류 내포(adamas)
BOOL CGame::bCheckInItemEventList(int iItemID, int iNpcH)
{
	int		i;
	char	cItemName[21];

	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{
		// item id로 item name을 가져 온다.
		for (i = 0; i < DEF_MAXITEMTYPES; i++ )
		{
			if( m_pItemConfigList[i] == NULL )
				continue;

			if( m_pItemConfigList[i]->m_sIDnum == iItemID ) {
				strcpy(cItemName, m_pItemConfigList[i]->m_cName);
				break;
			}
		}

		// 해당 item이 item event에 있는지 검사한다.
		for (i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++)
		{
			// type이 0이 아니면 건너 뛴다.
			if( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iType != 0 )
				continue;

			if( strcmp( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName, cItemName) == 0 )
				return TRUE;
		}
	}

	return FALSE;
} // bCheckInItemEventList()
BOOL CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// 스킬 번호 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pDupItemIDList[atoi(token)] != NULL) {
						// 이미 할당된 번호가 있다. 에러이다.
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate DupID number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[atoi(token)] = new class CItem;
					iIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 4;
					break;
				
				case 4:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete []pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	
	return TRUE;
}
					
BOOL CGame::bReadDupeConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
        PutLogList("(!) Cannot open Dupped file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Dupper List file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						m_pDupItemIDList[iIndex] = new class CItem;
						ZeroMemory(m_pDupItemIDList[iIndex]->m_cName, sizeof(m_pDupItemIDList[iIndex]->m_cName));
						memcpy(m_pDupItemIDList[iIndex]->m_cName, token, 21);
						cReadModeB = 2;
						break;

					case 2:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_pDupItemIDList[iIndex]->m_dwCount = atoi(token);
						cReadModeB = 3;
						break;
					
					case 3:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "[EOF]", 5) == 0) {
					break;
				} else {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}	

		delete pStrTok;
		delete []cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Dupped configuration file contents error!");
			return FALSE;
		}
	}
	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}


BOOL CGame::_bCheckDupItemID(CItem *pItem)
{
 int i;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) {
		if ((strcmp(pItem->m_cName, m_pDupItemIDList[i]->m_cName) == 0) &&
			(pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
			(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
			(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) ) {
			// 가격 정보를 갱신하고 리턴.
			pItem->m_dwCount = m_pDupItemIDList[i]->m_dwCount;
			return TRUE;
		}
	}
	
	return FALSE;
}

void CGame::_AdjustRareItemValue(CItem *pItem)
{
 DWORD dwSWEType, dwSWEValue;
 double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != NULL) {
		dwSWEType  = (pItem->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		// 희귀 아이템 효과 종류: 
		// 0-None 1-필살기대미지추가 2-중독효과 3-정의의 
		// 5-민첩의 6-가벼운 7-예리한 8-강화된 9-고대문명의
		switch (dwSWEType) {
		case 0: break;
		
		case 5: // 민첩의 
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6: // 가벼운 
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue*4);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: // 강화된 
		case 9: // 고대문명의 
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue*7);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
 char * cp, cData[120];
 int  * ip, iRet, iClientSize;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
		memcpy((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);
		
		dwp  = (DWORD *)(cp + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
	
		delete []cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}	
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
 char * cp;	
	
	cp = (pData);
	
	if (m_pNoticementData != NULL) {
		delete []m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(G_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(G_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
 int * ip, i, iLevel;
 char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
		// 같은 계정을 찾았다. 만약 패스워드나 레벨이 다르면 데이터 저장을 하지 않고 접속을 끊는다. 
		if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
			wsprintf(G_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
			PutLogList(G_cTxt);
			// 데이터 저장을 하지 않고 끊는다.
			DeleteClient(i, FALSE, TRUE);
			return;
		}
	}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
 int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
 short sOwnerH;
 char  cOwnerType;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;
	
	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; // 최대 범위는 8

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
	for (iY = dY - iRange; iY <= dY + iRange; iY++) {
		sOwnerH = NULL;
		if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) break;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				iTamingLevel = 10;
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 10:							// 슬라임  
				case 16: iTamingLevel = 1; break;	// 개미
				case 22: iTamingLevel = 2; break;	// 뱀
				case 17:							// 전갈
				case 14: iTamingLevel = 3; break;	// 오크
				case 18: iTamingLevel = 4; break;   // 좀비
				case 11: iTamingLevel = 5; break;	// 스켈레톤
				case 23:
				case 12: iTamingLevel = 6; break;	// 골렘
				case 28: iTamingLevel = 7; break;	// 트롤
				case 13:							// 싸이클롭스
				case 27: iTamingLevel = 8; break;	// 헬하운드
				case 29: iTamingLevel = 9; break;	// 오우거
				case 33: iTamingLevel = 9; break;	// 웨어울프
				case 30: iTamingLevel = 9; break;  // 리치
				case 31:
				case 32: iTamingLevel = 10; break;  // 데몬, 유니콘
					case 99: iTamingLevel = 10; break;
				}
				
				iResult = (iSkillLevel/10);
				
				// 스킬의 등급에 따라 길들일 수 있는 갯수가 달라진다.
				if (iResult < iTamingLevel) break;

				break;
			}
		}
	}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	// 마법 능력 스킬을 20으로 변경후 알려줌
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], NULL, NULL);
	// v1.4311 스킬의 총 합을 체크
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
 char  * cp, cDir, cData[3000];
 DWORD * dwp;
 WORD  * wp;
 short * sp, dX, dY;
 int   iRet, iSize;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + DEF_INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOVE_CONFIRM;
		
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
	sp  = (short *)cp;
	*sp = dX - 10; 
	cp += 2;
		
	sp  = (short *)cp;
	*sp = dY - 7; 
	cp += 2;
		
	*cp = cDir;
	cp++;
		
	iSize = iComposeMoveMapData(dX - 10, dY - 7, iClientH, cDir, cp);
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}
	RefreshPartyCoords(iClientH);
	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
		// 새 위치에 표시한다. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
	}
	else {
		// 현재 위치에서 지운다. 없어진 행위를 알려줘야 한다. 아직 미구현 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = TRUE;
	}
}

void CGame::RequestRestartHandler(int iClientH)
{
 char  cTmpMap[32];

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
		
		strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		// v2.181 2002-10-24 서버 속도 향상을 위해 스트링 비교를 줄인다.
		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
			// 여행자라면  default맵으로 간다.
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else {
			// 소속이 있다면 소속 마을의 부활존으로 간다.
			if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN ) { // 2002-11-14 사냥꾼 모드 추가
				if (m_bIsCrusadeMode == TRUE) {
					// 크루세이드 모드에서 사망한 경우: 마을 맵에서 일정시간 나갈 수 없다.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 30*1;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
					}
				}
				// v2.16 2002-5-31
				if (strcmp(cTmpMap, "elvine") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 30*1 ; // 3분 
				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
			}
			else {
				if (m_bIsCrusadeMode == TRUE) {
					// 크루세이드 모드에서 사망한 경우: 마을 맵에서 일정시간 나갈 수 없다.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime = 30*1;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 30*1; // v2.04 10분 안에 또 죽으면 마을에 갖힌다.
					}
				}
				if (strcmp(cTmpMap, "aresden") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 30*1 ; // 3분 

				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
			}
		}		
		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		m_pClientList[iClientH]->m_iHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)/2);
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		ZeroMemory(cTmpMap, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
	RefreshPartyStatus(iClientH);
}


void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cTemp[256], cAttribute[256], cValue[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iTemp, iEraseReq, iValue;
 DWORD * dwp;
 WORD  * wp, wTemp;
 double dV1, dV2, dV3;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2)	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	}

	ZeroMemory(cAttribute, sizeof(cAttribute));
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cAttribute, sizeof(cAttribute));
		strcpy(cAttribute, token);
	}

	// 01-12-10 완성도 
	ZeroMemory(cValue, sizeof(cValue));
	iValue = 0;
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cValue, sizeof(cValue));
		strcpy(cValue, token);
		iValue = atoi(cValue);
	}

	// 아이템을 만들고 
	pItem = new class CItem;
	// 기본 특성으로 아이템 생성 
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	// 01-12-10 특성치 입력 
	if (strlen(cAttribute) != 0) {
		pItem->m_dwAttribute = atoi(cAttribute);
		if (pItem->m_dwAttribute == 1) {
			if ((iValue >= 1) && (iValue <= 200)) {
				// 제작 아이템을 만든다.
				pItem->m_cItemColor = 2;
				pItem->m_sItemSpecEffectValue2 = iValue - 100;
								
				// 2. 새로운 최대 수명 계산 
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// 에러로 인해 너무 많은 수명값이 나옴을 막기위함 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;

			}
			else pItem->m_dwAttribute = NULL;
		}
		else {
			// 제작 아이템이 아니다. 특성치에 따라 색을 넣는다.
			if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 6:	pItem->m_cItemColor = 2; break;
				case 8: pItem->m_cItemColor = 3; break;
				case 1:	pItem->m_cItemColor = 5; break;
				case 5:	pItem->m_cItemColor = 1; break;
				case 3:	pItem->m_cItemColor = 7; break;
				case 2:	pItem->m_cItemColor = 4; break;
				case 7:	pItem->m_cItemColor = 6; break;
				case 9:	pItem->m_cItemColor = 8; break;
				}
			}
			else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 10: pItem->m_cItemColor = 5; break;
				}
			}
		}
	}

	// 아이템에 고유 코드 입력 혹은 날짜입력 
	switch (pItem->m_sIDnum) {
	case 511: // 입장권류다. 날짜입력
	case 513:
	case 515:
	case 517:
	case 530:
	case 531:
	case 532:
	case 533:
	case 534:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		// v1.4311-3 변경 운영자가 발급한 입장권은 그날은 항상 입장 가능 ..
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = 24 ;
		break;

	default:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		// 마지막 숫자는 아이템 생성 월, 일	
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		break;
	}
	
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// 아이템을 획득했다.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1개 획득했다. Amount가 아니다!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// 수량을 입력 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		
		*cp = (char)pItem->m_sItemSpecEffectValue3;
		cp++;

		// v2.15 로그 관련 수정
#ifdef DEF_TAIWANLOG 
		_bItemLog(DEF_ITEMLOG_CREATE, iClientH, (int) -1, pItem);
#endif
					
		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL ;
		}
		
		// 아이템 정보 전송 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
		

		// v2.14 Admin Log
		wsprintf(G_cTxt, "GM Order(%s): Create ItemName(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);

		return;
	}
	else {
		// 아이템을 소지할 수 없는 상황이다.		
		delete pItem;
		return;
	}
	if (pStrTok != NULL) delete pStrTok;
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
 int i, * ip, iAmount;
 char * cp, cIndex;
 struct {
	char cIndex;
	int  iAmount;
 } stTemp[12];

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}

	// 내용을 다 읽었다. 순서대로 팔아치운다.
	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;

		// cIndex에 해당하는 아이템을 판다.
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		// 이 루틴을 수행한 다음 클라이언트가 삭제되었을 수 있으니 주의!
		if (m_pClientList[iClientH] == NULL) return;
	}
}



void CGame::CreateNewPartyHandler(int iClientH)
{
 BOOL bFlag;

	if (m_pClientList[iClientH] == NULL) return;
   	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0&&m_pClientList[iClientH]->m_iAdminUserLevel < 3) return;// v2.23 22/04/06 15:24 AdminSecurity 

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, NULL, NULL, NULL);
}


void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
 char * cp, cData[120];
 short sAppr2;
 DWORD * dwp;
 WORD * wp;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0&&m_pClientList[iClientH]->m_iAdminUserLevel < 3) return; // v2.23 22/04/06 15:24 AdminSecurity 
	 
	switch (iV1) {
	case 0: // 파티 탈퇴 신청
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: // 파티 가입 신청
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
			// 이미 파티에 가입해 있다면 파티 가입 신청을 할 수 없다.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
			return;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
			// 같은 이름을 가진 플레이어를 찾았다.
			sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
			if (sAppr2 != 0) {
				// 전투 모드 상태의 상대에게는 파티 가입 신청을 할 수 없다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
			}
			else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				// 편이 다르면 파티에 들 수 없다.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
			}
			else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
				// 파티 가입을 신청한 대상이 이미 다른 파티 가입 관련 처리를 하고 있다. 신청 불가.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);

				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			}
			else {
				// 가입 승인 여부를 묻는다.
				m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
				ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
				strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
				SendNotifyMsg(NULL, i, DEF_NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
				
				// 신청한 측에는 파티 마스터가 될 캐릭터의 인덱스를 넣어줌. 취소할때 처리하기 위함임.
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
				strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
				// 파티 상태 세트
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
			}
			return;
		}
		break;

	case 2: // 파티 멤버 확인 명령 
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 6; // 파티 멤버 리스트 요청
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		break;
	}
}


BOOL CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
 int i, sX,sY, dX, dY, iGoalMapIndex;
 char cResult;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return FALSE;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 사투장에서는 적국 쪽에 골을 넣어도 페널티가 없다.
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// 클라이언트와의 메시지 착오로 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			// v2.05 자동 생성인 경우 에너지 스피어가 없어지자 마자 생성 
			if (m_pMapList[iGoalMapIndex]->m_bIsEnergySphereAutoCreation == TRUE) EnergySphereProcessor(TRUE, -1*iGoalMapIndex);
			return TRUE;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			// 엘바인 목표지점에 도착했다.
			// 현재 에너지 스피어 골 인덱스 저장 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 사투장에서는 적국 쪽에 골을 넣어도 페널티가 없다.
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			// v2.05 자동 생성인 경우 에너지 스피어가 없어지자 마자 생성 
			if (m_pMapList[iGoalMapIndex]->m_bIsEnergySphereAutoCreation == TRUE) EnergySphereProcessor(TRUE, -1*iGoalMapIndex);
			return TRUE;
		}

		return FALSE;
	}
	else {
		// 미들랜드 에너지 스피어.

		// 에너지 스피어의 현재 위치가 골과 거의 유사하면 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			// 아레스덴 목표지점에 도착했다.
			// 현재 에너지 스피어 골 인덱스 저장 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// 자신의 국가 포탈에 골을 넣은 경우 공헌도 +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 다른 국가에 골을 넣었을 경우 공헌도가 10 떨어진다.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// 클라이언트와의 메시지 착오로 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-1) && (sX <= dX+1) && (sY >= dY-1) && (sY <= dY+1)) {
			// 엘바인 목표지점에 도착했다.
			// 현재 에너지 스피어 골 인덱스 저장 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// 자신의 국가 포탈에 골을 넣은 경우 공헌도 +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// 로그 작성
					wsprintf(G_cTxt, "(!) 에너지 스피어 골인 (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// 다른 국가에 골을 넣었을 경우 공헌도가 10 떨어진다.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// 에너지 스피어가 골인 됐음을 모든 클라이언트에게 알려준다.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}
		return FALSE;
	}
}

void CGame::EnergySphereProcessor(BOOL bIsAdminCreate, int iClientH)
{
 int i, iNamingValue, iCIndex, iTemp, pX, pY, iMapIndex;
 char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != TRUE) {
		
		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == NULL) return;
		// 에너지 스피어가 만들어질 확률은 3초마다 2000분의 1
		if (iDice(1,2000) != 123) return; 
		// 에너지 스피어는 총 사용자 500명 이상일때만 만들어 진다.
		if (m_iTotalGameServerClients < 500) return;
	
		// 만약 이미 에너지 스피어의 골이 할당되어 있으면 만들면 안된다.
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// 에너지 스피어를 만들 위치를 결정 
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		// 에너지 스피어 시작 위치가 초기화가 안된 상태라면 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// 여기서 에너지 스피어 생성 
		cSA = 0;
 		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// 에너지 스피어 골 생성 
		iTemp  = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// 현재 에너지 스피어 골 인덱스 저장 
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// 에너지 스피어가 만들어 졌음을 모든 클라이언트에게 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	else {
		if (iClientH == 0)
			iMapIndex = 0;
		else if (iClientH < 0) // 음수인 경우에는 맵 인덱스 
			 iMapIndex = -1*iClientH;
		else iMapIndex = m_pClientList[iClientH]->m_cMapIndex;

		// 만약 이미 에너지 스피어의 골이 할당되어 있으면 만들면 안된다.
		if (m_pMapList[iMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// 에너지 스피어를 만들 위치를 결정 
		iCIndex = iDice(1, m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint);

		// 에너지 스피어 시작 위치가 초기화가 안된 상태라면 
		if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// 여기서 에너지 스피어 생성 
		cSA = 0;
 		pX = m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = iMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[iMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// 에너지 스피어 골 생성 
		iTemp  = iDice(1, m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// 현재 에너지 스피어 골 인덱스 저장 
		m_pMapList[iMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// 에너지 스피어가 만들어 졌음을 모든 클라이언트에게 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
 DWORD dwTime = timeGetTime();
 short sTemp;

	// 특수 능력을 사용했다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;

#ifdef DEF_GUILDWARMODE
	// 길드전 모드일때는 특수 능력 사용 불가 
	return;
#endif

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = TRUE;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	// 다음 사용 가능 시간을 입력한다.
	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	// 효과 비트 클리어
	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	// 효과 비트 설정 
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	// 클라이언트에게 통보한다. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
	// 외형이 바뀌었음을 알려준다.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	// 퀘스트 상태를 클리어한다.
	_ClearQuestStatus(iClientH);
	// 퀘스트가 취소되었음을 알려준다.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{
 int iWeight;
	// 아이템의 수량에 따른 무게를 계산한다. Gold인 경우 무게를 20분의 1로 변경 
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}

// NPC를 삭제할때 특수 아이템을 발생시킬 것인지의 여부를 계산한다.
BOOL CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType, int iItemprobability)
{

//-- NPC ITEM -----------------------------------------------------------------------------------------------------
// 2002-09-17 #1 NPCITEM 개선
// 2002-09-09 #1
#if		defined(DEF_NPCITEM) 

 class	CNpcItem CTempNpcItem;
 int	iResult;
 int	iNpcIndex;
 int	iNumNpcitem;
 int	iIndex;
 int	iDiceValue;
 BOOL	bFirstDice = FALSE, bSecondDice = FALSE;

	for ( iNpcIndex = 0; iNpcIndex < DEF_MAXNPCTYPES; iNpcIndex++) {
		if (m_pNpcConfigList[iNpcIndex] != NULL) {
			if(m_pNpcConfigList[iNpcIndex]->m_sType == sNpcType ) break; 
		}
	}

	if ( iNpcIndex == DEF_MAXNPCTYPES ) return FALSE;

	if( m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size() <=  0 )  return FALSE;

	switch( m_pNpcConfigList[iNpcIndex]->m_iNpcitemType )
	{
	case 1:
		// 설정 파일의 여러 개의 아이템 중 하나를 고른다.
		iResult = iDice( 1, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size() ) - 1;

		CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iResult);
		
		if ( iDice(1,CTempNpcItem.m_sFirstProbability  ) == CTempNpcItem.m_cFirstTargetValue ) bFirstDice  = TRUE;
		if ( iDice(1,CTempNpcItem.m_sSecondProbability ) == CTempNpcItem.m_cSecondTargetValue) bSecondDice = TRUE;

		if ( (bFirstDice == TRUE) && (bSecondDice == TRUE) )
		{
			iItemID = CTempNpcItem.m_sItemID;

			wsprintf(G_cTxt, "NpcType 1 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID, iItemID);
		//	PutDebugMsg(G_cTxt);

		}
		break;

	case 2:
		iNumNpcitem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size();
		iDiceValue  = iDice(1, m_pNpcConfigList[iNpcIndex]->m_iNpcitemMax);

		for(iIndex = 0; iIndex < iNumNpcitem; iIndex++) {
			CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iIndex);

			if( CTempNpcItem.m_sFirstProbability <= iDiceValue && iDiceValue < CTempNpcItem.m_sSecondProbability )
			{
				iItemID = CTempNpcItem.m_sItemID;

				wsprintf(G_cTxt, "NpcType 2 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID, iItemID);
				//PutDebugMsg(G_cTxt);

				break;
			}
		}
		break;

	} // switch

	if ( iItemID <= 0 )
		return FALSE;

	return TRUE;

#else	// !DEF_NPCITEM

//-- End : NPC ITEM -----------------------------------------------------------------------------------------------

 int iResult;
	// NPC를 삭제할때 특수 아이템을 발생시킬 것인지의 여부를 계산한다.
/*
	switch (sNpcType) {
	case 49: // Hellclaw
		iResult = iDice(1,22000);
		if ((iResult >= 1) && (iResult <  5000)) iItemID = 300 ;			// "MagicNecklace(RM10)"		5000
		else if ((iResult >= 5000) && (iResult <  20000)) iItemID = 259 ;	// "MagicWand(M.Shield)"		5000
		else if ((iResult >= 10000) && (iResult < 20000))  iItemID = 337 ;  // "RubyRing"				3000
		else if ((iResult >= 13000) && (iResult < 20000))  iItemID = 335 ;  // "EmeraldRing"			2000
		else if ((iResult >= 15000) && (iResult < 20000))  iItemID = 308 ;  // "MagicNecklace(MS10)"		2500
		else if ((iResult >= 17500) && (iResult < 20000))  iItemID = 311 ;  // "MagicNecklace(DF+10)"		1000
		else if ((iResult >= 18750) && (iResult < 20000))  iItemID = 305 ;  // "MagicNecklace(DM+1)"		 250
		else if ((iResult >= 19000) && (iResult < 20000))  iItemID = 634 ;  // "RingofWizard"			 700
		else if ((iResult >= 19700) && (iResult < 20000))  iItemID = 635 ;  // "RingofMage"			 144
		else if ((iResult >= 19844) && (iResult < 20000))  iItemID = 640 ;  // "KnecklaceOfSufferent"		  78
		else if ((iResult >= 19922) && (iResult < 20000))  iItemID = 637 ;  // "KnecklaceOfLightPro"		  39
		else if ((iResult >= 19961) && (iResult < 20000))  iItemID = 644 ;  // "KnecklaceOfAirEle"		  20
		else if ((iResult >= 19970) && (iResult < 20000))  iItemID = 620 ;  // "MerienShield"			  10
		else if ((iResult >= 19980) && (iResult < 20000))  iItemID = 643 ;  // "KnecklaceOfIceEle"	   5
		else if ((iResult >= 19988) && (iResult < 20000))  iItemID = 614 ;  // "SwordofIceElemental"		   3
		else if ((iResult >= 19994) && (iResult <= 20000)) iItemID = 636 ;  // "RingofGrandMage"		   2
		else if ((iResult >= 20000) && (iResult <= 22000)) iItemID = 916 ;	// Armor Dye Indigo
		else if ((iResult >= 21000) && (iResult <= 22000)) iItemID = 921 ;	// Armor Dye Violet
		else if ((iResult >= 21400) && (iResult <= 22000)) iItemID = 918 ;	// Armor Dye Gold
		return TRUE;*/

	switch (sNpcType) { 
		case 49: // Hellclaw 
		
		/*
		iResult = iDice(1,20000);
		if ((iResult >= 1) && (iResult <  5000)) iItemID = 300 ;			// "MagicNecklace(RM10)"		5000
		else if ((iResult >= 5000) && (iResult <  10000)) iItemID = 259 ;	// "MagicWand(M.Shield)"		5000
		else if ((iResult >= 10000) && (iResult < 13000))  iItemID = 337 ;  // "RubyRing"				3000
		else if ((iResult >= 13000) && (iResult < 15000))  iItemID = 335 ;  // "EmeraldRing"			2000
		else if ((iResult >= 15000) && (iResult < 17500))  iItemID = 308 ;  // "MagicNecklace(MS10)"		2500
		else if ((iResult >= 17500) && (iResult < 18750))  iItemID = 311 ;  // "MagicNecklace(DF+10)"		1000
		else if ((iResult >= 18750) && (iResult < 19000))  iItemID = 305 ;  // "MagicNecklace(DM+1)"		 250
		else if ((iResult >= 19000) && (iResult < 19700))  iItemID = 634 ;  // "RingofWizard"			 700
		else if ((iResult >= 19700) && (iResult < 19844))  iItemID = 635 ;  // "RingofMage"			 144
		else if ((iResult >= 19844) && (iResult < 19922))  iItemID = 640 ;  // "KnecklaceOfSufferent"		  78
		else if ((iResult >= 19922) && (iResult < 19961))  iItemID = 637 ;  // "KnecklaceOfLightPro"		  39
		else if ((iResult >= 19961) && (iResult < 19969))  iItemID = 644 ;  // "KnecklaceOfAirEle"		  20
		else if ((iResult >= 19970) && (iResult < 19979))  iItemID = 620 ;  // "MerienShield"			  10
		else if ((iResult >= 19980) && (iResult < 19987))  iItemID = 643 ;  // "KnecklaceOfIceEle"	   5
		else if ((iResult >= 19988) && (iResult < 19993))  iItemID = 614 ;  // "SwordofIceElemental"		   3
		else if ((iResult >= 19994) && (iResult <= 20000)) iItemID = 636 ;  // "RingofGrandMage"		   2
		*/

		iResult = iDice(1,1000);
		if 	((iResult >= 1) && (iResult <=  50))	iItemID = 300;	// "MagicNecklace(RM10)"	5%
		else if ((iResult > 50) && (iResult <=  100))	iItemID = 259 ;	// "MagicWand(M.Shield)"	5%10
		else if ((iResult > 100) && (iResult <= 150))	iItemID = 311 ;	// "MagicNecklace(DF+10)"	5%15
		else if ((iResult > 150) && (iResult <= 200))	iItemID = 308 ;	// "MagicNecklace(MS10)"	5%20
		else if ((iResult > 200) && (iResult <= 250))	iItemID = 305 ;	// "MagicNecklace(DM+1)"	5%25
		else if ((iResult > 250) && (iResult <= 300))	iItemID = 337;	// "RubyRing"			5%30
		else if ((iResult > 300) && (iResult <= 350))	iItemID = 335;	// "EmeraldRing"		5%35

		else if ((iResult > 1000) && (iResult <= 1500))  iItemID = 634 ;  // "RingofWizard"		5%40
		else if ((iResult > 1000) && (iResult <= 1500))  iItemID = 632 ;  // "RingofOgrePower"		5%45



		//else if ((iResult > 450) && (iResult <= 460))	iItemID = 3011;	// "RepPotionRestore"		1%46
	//else if ((iResult > 460) && (iResult <= 610))	iItemID = 2092;	// "ArmorDye(CrimsonRed)"		15%61
	//	else if ((iResult > 610) && (iResult <= 710))	iItemID = 2093;	// "ArmorDye(Gold)"		10%71
		else if ((iResult > 710) && (iResult <= 810))	iItemID = 3014;	// "RepPotion+5"		10%81
		else if ((iResult > 810) && (iResult <= 900))	iItemID = 3015;	// "RepPotion+7"		9%90
	//	else if ((iResult > 900) && (iResult <= 960))	iItemID = 858 ;	// "NecklaceOfMerien"	6%96
	//	else if ((iResult > 2000) && (iResult <= 2010))  iItemID = 616 ;  // "DarkExecutor"		2%
		else if ((iResult > 5000) && (iResult <= 5010))  iItemID = 865 ;  // "ResurWandMS30"		2%
		//FIXED
       	return TRUE;
		
		case 50: // Tigerworm
		
		iResult = iDice(1,1000);
		if 	((iResult >= 5) && (iResult <=  50))	iItemID = 300;	// "MagicNecklace(RM10)"	5%
		else if ((iResult > 5) && (iResult <=  50))	iItemID = 259 ;	// "MagicWand(M.Shield)"	5%10
		else if ((iResult > 5) && (iResult <= 50))	iItemID = 311 ;	// "MagicNecklace(DF+10)"	5%15
		else if ((iResult > 5) && (iResult <= 50))	iItemID = 308 ;	// "MagicNecklace(MS10)"	5%20
		else if ((iResult > 5) && (iResult <= 50))	iItemID = 305 ;	// "MagicNecklace(DM+1)"	5%25
		else if ((iResult > 5) && (iResult <= 30))	iItemID = 337;	// "RubyRing"			5%30
		else if ((iResult > 5) && (iResult <= 300))	iItemID = 335;	// "EmeraldRing"		5%35

		else if ((iResult > 2) && (iResult <= 80))  iItemID = 635 ;  // "RingofMage"		5%40
		else if ((iResult > 2) && (iResult <= 50))  iItemID = 633 ;  // "RingofDemonPower"		5%45

		//else if ((iResult > 450) && (iResult <= 460))	iItemID = 2092;	// "ArmorDye(CrimsonRed)"		1%46
		//else if ((iResult > 460) && (iResult <= 610))	iItemID = 2095;	// "ArmorDye(Pink)"		15%61
		//else if ((iResult > 610) && (iResult <= 710))	iItemID = 2097;	// "ArmorDye(Blue) "		10%71
		//else if ((iResult > 710) && (iResult <= 810))	iItemID = 2093;	// "ArmorDye(Gold) "		10%81
		else if ((iResult > 1) && (iResult <= 100))	iItemID = 490 ;	// "BloodSword"		9%90
		else if ((iResult > 1) && (iResult <= 200))	iItemID = 614 ;	// "SwordOfIceElemental"	6%96
	//	else if ((iResult > 960) && (iResult <= 980))  iItemID = 631 ;  // "RingoftheAbaddon"		2% acalablade
	//	else if ((iResult > 980) && (iResult <= 1000))  iItemID = 291 ;  // "MS30"		2%

	//	else if ((iResult > 1000) && (iResult <= 1020))  iItemID = 4968 ;  // "NeckPowerXelima"		2% acalablade
	//	else if ((iResult > 1020) && (iResult <= 1040))  iItemID = 4909 ;  // "MS60"		2%
	//	else if ((iResult > 1040) && (iResult <= 1060))  iItemID = 4966 ;  // "NeckPower(MS.30)"		2%
	//	else if ((iResult > 1080) && (iResult <= 1100))  iItemID = 643 ;  // "NeckofIceEle"		2% acalablade
	//	else if ((iResult > 1100) && (iResult <= 1120))  iItemID = 641  ;  // "MedusaNeck"		2%
	//	else if ((iResult > 1120) && (iResult <= 1140))  iItemID = 611  ;  // "XelimaAxe"		2%

		//FIXED

		case 70: // Spider nuevo npc


		iResult = iDice(1,1000);
	//	if 	((iResult >= 1) && (iResult <=  50))	iItemID = 4000;	// "WhiteWingsHelmM"	5%
	//	else if ((iResult > 50) && (iResult <=  100))	iItemID = 4001 ;	// "WhiteWingsHelm(W)"	5%10
	//	else if ((iResult > 100) && (iResult <= 150))	iItemID = 4002 ;	// "WhiteMageHat(M)"	5%15
	//	else if ((iResult > 150) && (iResult <= 200))	iItemID = 4003 ;	// "WhiteMageHat(W)"	5%20
	//	else if ((iResult > 200) && (iResult <= 250))	iItemID = 4004 ;	// "WhitePlateMail(M)"	5%25
	//	else if ((iResult > 250) && (iResult <= 300))	iItemID = 4005;	// "WhitePlateMail(W)"			5%30
	//	else if ((iResult > 300) && (iResult <= 350))	iItemID = 4006;	// "WhiteMageChain(M)"		5%35

	//	else if ((iResult > 350) && (iResult <= 400))  iItemID = 4007 ;  // "WhiteMageChain(W)"		5%40
	//	else if ((iResult > 400) && (iResult <= 450))  iItemID = 4008 ;  // "WhiteHauberk(M)"		5%45



	//	else if ((iResult > 450) && (iResult <= 460))	iItemID = 2092;	
	//	else if ((iResult > 460) && (iResult <= 610))	iItemID = 2095;	
	//	else if ((iResult > 610) && (iResult <= 710))	iItemID = 2097;	
	//	else if ((iResult > 710) && (iResult <= 810))	iItemID = 2093;	
	//	else if ((iResult > 810) && (iResult <= 900))	iItemID = 4968;	
	//	else if ((iResult > 900) && (iResult <= 960))	iItemID = 4909 ;
	//	else if ((iResult > 2000) && (iResult <= 2010))  iItemID = 4966 ;
		//FIXED
       	return TRUE;


		case 71: // Spectre nuevo npc


		iResult = iDice(1,1000);
	//	if 	((iResult >= 1) && (iResult <=  50))	iItemID = 2092;	// "WhiteWingsHelmM"	5%
	//	else if ((iResult > 50) && (iResult <=  100))	iItemID = 2095 ;	// "WhiteWingsHelm(W)"	5%10
	//	else if ((iResult > 100) && (iResult <= 150))	iItemID = 2097 ;	// "WhiteMageHat(M)"	5%15
	//	else if ((iResult > 150) && (iResult <= 200))	iItemID = 2093 ;	// "WhiteMageHat(W)"	5%20
	//	else if ((iResult > 200) && (iResult <= 250))	iItemID = 4968 ;	// "WhitePlateMail(M)"	5%25
	//	else if ((iResult > 250) && (iResult <= 300))	iItemID = 4909;	// "WhitePlateMail(W)"			5%30
	//	else if ((iResult > 300) && (iResult <= 350))	iItemID = 4966;	// "WhiteMageChain(M)"		5%35


	//	else if ((iResult > 450) && (iResult <= 460))	iItemID = 4008;	// "WhiteHauberk(W)"		1%46
	//	else if ((iResult > 460) && (iResult <= 610))	iItemID = 4010;	// "WhiteLeggings(M)"		15%61
	//	else if ((iResult > 610) && (iResult <= 710))	iItemID = 4011;	// "WhiteLeggings(W)"		10%71
	//	else if ((iResult > 710) && (iResult <= 810))	iItemID = 4012;	// "WhiteMageHauberk(M)"		10%81
	//	else if ((iResult > 810) && (iResult <= 900))	iItemID = 4013;	// "WhiteMageHauberk(W)"		9%90
	//	else if ((iResult > 900) && (iResult <= 960))	iItemID = 4014 ;	// "WhiteMageLeggs(M)"	6%96
	//	else if ((iResult > 2000) && (iResult <= 2010))  iItemID = 4015 ;  // "WhiteMageLeggs(W)"		2%
	//	else if ((iResult > 2000) && (iResult <= 2010))  iItemID = 4016 ;  // "WhiteMageRobe(M)"		2%
	//	else if ((iResult > 2000) && (iResult <= 2010))  iItemID = 4017 ;  // "WhiteMageHauberk(W)"		2%
		//FIXED
       	return TRUE;

		case 72: // Yeti nuevo npc

		iResult = iDice(1,1000);
		if 	((iResult >= 1) && (iResult <=  50))	iItemID = 1511;	// "Extreme set"
		else if ((iResult > 50) && (iResult <=  100))	iItemID = 3016 ;	// "Extreme set"
		else if ((iResult > 100) && (iResult <= 150))	iItemID = 1506 ;	// "Extreme set"
		else if ((iResult > 150) && (iResult <= 200))	iItemID = 616 ;	// "Extreme set"
		else if ((iResult > 200) && (iResult <= 250))	iItemID = 20 ;	// "Extreme set"

		else if ((iResult > 450) && (iResult <= 460))	iItemID = 4978;	// "Extreme set"
		else if ((iResult > 460) && (iResult <= 610))	iItemID = 4979;	// "Extreme set"
		else if ((iResult > 610) && (iResult <= 710))	iItemID = 4980;	// "Extreme set"
		else if ((iResult > 710) && (iResult <= 810))	iItemID = 4981;	// "Extreme set"
		else if ((iResult > 810) && (iResult <= 900))	iItemID = 4982;	// "Extreme set"
		else if ((iResult > 810) && (iResult <= 901))	iItemID = 4983;	// "Extreme set"
		else if ((iResult > 810) && (iResult <= 902))	iItemID = 4984;	// "Extreme set"
		else if ((iResult > 810) && (iResult <= 911))	iItemID = 4985;	// "Extreme set"
		//FIXED
       	return TRUE;		

		case 78: // PitLord nuevo npc
		iResult = iDice(1,1000);
		if 	((iResult >= 1) && (iResult <=  50))	iItemID = 4969;	// "Extreme set"
		else if ((iResult > 50) && (iResult <=  100))	iItemID = 4970 ;	// "Extreme set"
		else if ((iResult > 100) && (iResult <= 150))	iItemID = 4971 ;	// "Extreme set"
		else if ((iResult > 150) && (iResult <= 200))	iItemID = 4972 ;	// "Extreme set"
		else if ((iResult > 200) && (iResult <= 250))	iItemID = 4973 ;	// "Extreme set"
		else if ((iResult > 250) && (iResult <= 300))	iItemID = 4974;// "Extreme set"
		else if ((iResult > 300) && (iResult <= 350))	iItemID = 4975;	// "Extreme set"

		else if ((iResult > 350) && (iResult <= 400))  iItemID = 4976;  // "Extreme set"
		else if ((iResult > 400) && (iResult <= 450))  iItemID = 4977 ;  // "Extreme set"



		else if ((iResult > 450) && (iResult <= 460))	iItemID = 1511;	
		else if ((iResult > 460) && (iResult <= 610))	iItemID = 3016;	
		else if ((iResult > 610) && (iResult <= 710))	iItemID = 1506;	
		else if ((iResult > 710) && (iResult <= 810))	iItemID = 616;	
		else if ((iResult > 810) && (iResult <= 900))	iItemID = 20;	
		//FIXED
       	return TRUE;

		case 77: // Doomdemon nuevo npc


		iResult = iDice(1,1000);
		if 	((iResult >= 1) && (iResult <=  50))	iItemID = 1511;	// "maj ball +300"	5%
		else if ((iResult > 50) && (iResult <=  100))	iItemID = 3016 ;	// "contrib ball +700"	5%10
		else if ((iResult > 100) && (iResult <= 150))	iItemID = 744 ;	// "gold pocket"	5%15
		else if ((iResult > 150) && (iResult <= 200))	iItemID = 308 ;	// "MagicNecklace(MS10)"	5%20
		else if ((iResult > 200) && (iResult <= 250))	iItemID = 305 ;	// "MagicNecklace(DM+1)"	5%25
		else if ((iResult > 250) && (iResult <= 300))	iItemID = 337;	// "RubyRing"			5%30
		else if ((iResult > 300) && (iResult <= 350))	iItemID = 335;	// "EmeraldRing"		5%35

	//	else if ((iResult > 350) && (iResult <= 400))  iItemID = 4964 ;  // "RingofPowerWar"		5%40
	//	else if ((iResult > 400) && (iResult <= 450))  iItemID = 4965 ;  // "RingofPowermage"		5%45

	//	else if ((iResult > 450) && (iResult <= 460))	iItemID = 4966;	// "NeckPower(MS.30)"		1%46
	//	else if ((iResult > 460) && (iResult <= 610))	iItemID = 4967;	// "NeckPowerMerien"		15%61
	//	else if ((iResult > 610) && (iResult <= 710))	iItemID = 4968;	// "NeckPowerXelima"		10%71
		else if ((iResult > 710) && (iResult <= 810))	iItemID = 3014;	// "RepPotion+5"		10%81
		else if ((iResult > 810) && (iResult <= 900))	iItemID = 3015;	// "RepPotion+7"		9%90
	//	else if ((iResult > 900) && (iResult <= 960))	iItemID = 858 ;	// "NecklaceOfMerien"	6%96
		else if ((iResult > 2000) && (iResult <= 2010))  iItemID = 616 ;  // "DarkExecutor"		2%
		else if ((iResult > 2000) && (iResult <= 2011))  iItemID = 859 ;  // "EkBall(+100)"		2%
		//FIXED
       	return TRUE;

			default:
		   break; 
		}
	if (iDice(1,45) == 13) 
	{
		switch (sNpcType) 
		{
		case 11: if (iDice(1,550) != 11) return FALSE; break;	  // Skeleton   2 * 100	
		case 12: if (iDice(1,400) != 11) return FALSE; break;	  // Stone-Golem 2 * 100	
		case 13: if (iDice(1,100) != 11) return FALSE; break;	  // Cyclops  6 * 100	
		case 14: if (iDice(1,700) != 11) return FALSE; break;	  // Orc 4 * 100	
		case 17: if (iDice(1,600) != 11) return FALSE; break;	  // Scorpoin 5 * 100	
		case 18: if (iDice(1,850) != 11) return FALSE; break;	  // Zombie 1 * 100	
		case 22: if (iDice(1,600) != 11) return FALSE; break;	  // Amphis 5 * 100	
		case 23: if (iDice(1,400) != 11) return FALSE; break;	  // Clay-Golem 2 * 100	
		case 27: if (iDice(1,100) != 11) return FALSE; break;	  // Hellhound 7 * 100	
		case 28: if (iDice(1,100) != 11) return FALSE; break;	  // Troll 5 * 100	
		case 29: if (iDice(1,150) != 11) return FALSE; break;	  // Orge  7 * 100	
		case 30: if (iDice(1,120) != 11) return FALSE; break;	  // Liche 1 * 100   
		case 31: break; 	                                      // Demon 5 * 100	
		case 32: if (iDice(1,200) != 11) return FALSE; break;	  // Unicorn 5 * 100	
		case 99: if (iDice(1,200) != 11) return FALSE; break;	  // Unicorn 5 * 100	
		case 33: if (iDice(1,300) != 11) return FALSE; break;	  // WereWolf 7 * 100
		case 48: if (iDice(1,100) != 11) return FALSE; break;	  // Stalker 
		case 52: if (iDice(1,300) != 11) return FALSE; break;     // Gagoyle
		case 53: if (iDice(1,500) != 11) return FALSE; break;	  // Beholder
		case 54: if (iDice(1,200) != 11) return FALSE; break;	  // Dark-Elf
		case 57: if (iDice(1,400) != 11) return FALSE; break;	  // Giant-Frog
		case 63: if (iDice(1,300) != 11) return FALSE; break;	  // Frost
		case 79: if (iDice(1,200) != 11) return FALSE; break;	  // Nizie
		case 70: if (iDice(1,200) != 11) return FALSE; break;	  // Spider
		case 71: if (iDice(1,200) != 11) return FALSE; break;	  // Spectre
		case 72: if (iDice(1,200) != 11) return FALSE; break;	  // Yeti
		case 77: if (iDice(1,200) != 11) return FALSE; break;	  // DoomDemon
		case 78: if (iDice(1,200) != 11) return FALSE; break;	  // PitLord
		default: break;
		}
	}
	else return FALSE;

//http://www.helbreath.com/down/d_patch_v2.htm

	switch (sNpcType) {
	case 11: // Skeleton
	case 17: // Scorpoin
	case 14: // Orc
	case 28: // Troll
	case 57: // Giant-Frog
		switch (iDice(1,5)) {
		case 1: iItemID = 334 ; break; // LuckyGoldRing
		case 2: iItemID = 336 ; break; // SapphireRing
		case 3: if (iDice(1,15) == 3) iItemID = 335 ; break; // EmeraldRing
		case 4: iItemID = 337 ; break; // RubyRing
		case 5: iItemID = 333 ; break; // PlatinumRing
		}
		break;
	
	case 13: // Cyclops
	case 27: // Hellhound
	case 29: // Orge
		switch (iDice(1,7)) {
		case 1: iItemID = 311 ; break; // MagicNecklace(DF+10)
		case 2: if (iDice(1,20) == 13) iItemID = 308 ; break; // MagicNecklace(MS10)
		case 3: if (iDice(1,20) == 13) iItemID = 305 ; break; // MagicNecklace(DM+1)
		case 4: iItemID = 300 ; break; // MagicNecklace(RM10)
		case 5: if (iDice(1,20) == 13) iItemID = 632 ; break; // RingofOgrepower
		case 6: if (iDice(1,20) == 13) iItemID = 637 ; break; // KnecklaceOfLightPro
		case 7: if (iDice(1,20) == 13) iItemID = 638 ; break; //KnecklaceOfFirePro
			}
		break;

	case 18: // Zombie
	case 22: // Amphis
		switch (iDice(1,4)) {
		case 1: if (iDice(1,20) == 13) iItemID = 613 ; break; // SwordofMedusa
		case 2: if (iDice(1,50) == 13) iItemID = 639 ; break; // KnecklaceOfPoisonPro
		case 3: if (iDice(1,10) == 13) iItemID = 641 ; break; // KnecklaceOfMedusa
		case 4: if (iDice(1,50) == 13) iItemID = 361 ; break; // KnecklaceOfSufferent
		}
		break;

	case 12: // Stone-Golem
		switch (iDice(1,5)) {
		case 5: if (iDice(1,20) == 11) iItemID = 647 ; break; // KnecklaceOfStoneGolem
		}
		break;

	case 23: // Clay-Golem
		switch (iDice(1,4)) {
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		}
		break;

	case 32: // Unicorn
		break;case 99: // Unicorn
		break;
		
	case 33: // WereWolf
	case 48: // Stalker
		switch (iDice(1,2)) {
		case 1: if (iDice(1,30) == 3) iItemID = 290 ; break; // Flameberge+3(LLF)
		case 2: iItemID = 292 ; break; // GoldenAxe(LLF)
		}
		break;

	case 30: // Liche
		switch (iDice(1,5)) {
		case 1: if (iDice(1,20) == 3) iItemID = 380 ; break; // IceStormManual
		case 2: if (iDice(1,30) == 3) iItemID = 259 ; break; // MagicWand(M.Shield)
		case 3: if (iDice(1,20) == 3) iItemID = 291 ; break; // MagicWand(MS30-LLF)	
		case 4: if (iDice(1,20) == 3) iItemID = 636 ; break; // RingofGrandMage
		case 5: if (iDice(1,10) == 3) iItemID = 734 ; break; // RingOfArcmage
		}
		break;

	case 31: // Demon 
		switch (iDice(1,6)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // BloodyShockW.Manual
		case 2: if (iDice(1,20) == 3) iItemID = 491 ; break; // BloodAxe
		case 3: if (iDice(1,20) == 3) iItemID = 490 ; break; // BloodSword
		case 4: if (iDice(1,20) == 3) iItemID = 492 ; break; // BloodRapier
		case 5: if (iDice(1,10) == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,5) == 3) iItemID = 847 ; break; // DemonSlayer
		}
		break;

	case 52: // Gagoyle
		switch (iDice(1,12)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // BloodyShockW.Manual	
		case 2: if (iDice(1,15) == 3) iItemID = 610 ; break; // XelimaBlade	
		case 3: if (iDice(1,20) == 3) iItemID = 611 ; break; // XelimaAxe	
		case 4: if (iDice(1,20) == 3) iItemID = 612 ; break; // XelimaRapier
		case 5: if (iDice(1,20) == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,50) == 3) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,20) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,30) == 3) iItemID = 630 ; break; // RingoftheXelima	
	//	case 9: if (iDice(1,50) == 3) iItemID = 631 ; break; // RingoftheAbaddon
		case 10: if (iDice(1,50) == 3) iItemID = 735; break; // RingOfDragonpower
		case 11: if (iDice(1,30) == 3) iItemID = 20 ; break; // Excaliber
		//case 12: if (iDice(1,60) == 3) iItemID = 3080; break; // The_Devastator
		}
		break;

	case 53: // Beholder
		if (iDice(1,10) == 11) iItemID = 646; break; // KnecklaceOfBeholder	
		break;

	case 54: // Dark-Elf
		if (iDice(1,20) == 11) iItemID = 618; break; // DarkElfBow
		break;

	case 63: // Frost
		if (iDice(1,40) == 11) iItemID = 3080; break; // //ContribBall(+50000)	
		break;

	case 79: // Nizie
		if (iDice(1,40) == 11) iItemID = 3080; break; // //ContribBall(+50000)
		break;

/*	case 70: // Barlog
		if (iDice(1,40) == 11) iItemID = 3080; break; //ContribBall(+50000)
		break;

	case 71: // Centaurus
		if (iDice(1,20) == 11) iItemID = 3080; break; //ContribBall(+50000)
		break;*/

	} 
	
	if (iItemID == 0) 
		 return FALSE;
	else return TRUE;

#endif // !DEF_NPCITEM

} // bGetItemNameWhenDeleteNpc


void CGame::UpdateMapSectorInfo()
{
 int i, ix, iy;
 int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;
	
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
	
		iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;	
		m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
		m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
		m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

		// 그동안 저장했던 TempSectorInfo에서 정보를 얻어 SectorInfo에 저장한 다음 TempSectorInfo는 지운다.
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
				iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
				m_pMapList[i]->m_iMaxNx = ix;
				m_pMapList[i]->m_iMaxNy = iy;
			}
			
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
				iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
				m_pMapList[i]->m_iMaxAx = ix;
				m_pMapList[i]->m_iMaxAy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
				iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
				m_pMapList[i]->m_iMaxEx = ix;
				m_pMapList[i]->m_iMaxEy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
				iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
				m_pMapList[i]->m_iMaxMx = ix;
				m_pMapList[i]->m_iMaxMy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
				iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
				m_pMapList[i]->m_iMaxPx = ix;
				m_pMapList[i]->m_iMaxPy = iy;
			}
		}
	
		// TempSectorInfo 날린다.
		m_pMapList[i]->ClearTempSectorInfo();

		// Sector Info에 저장
		if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
		if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
		if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
		if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
		if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
	}
}


void CGame::AgingMapSectorInfo()
{
 int i, ix, iy;

	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;
			
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
		}
	}
}


BOOL CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
 int iNamingValue, ix, iy, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;

	// 크루세이드 모드가 아니거나 건설한 사람이 공병이 아니면 무시.
	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
		// 해당 맵에 크루세이드 건물 개수 제한에 걸리지 않는다면
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	// 해당 위치에 건축물 NPC를 생성.
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
	}
	else {

		// 먼저 설치하고자 하는 근처에 구조물이 없나 확인한다.
		for (ix = dX -3; ix <= dX +5; ix++)
		for (iy = dY -3; iy <= dY +5; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return FALSE;
		}

		// NPC를 생성한다.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return FALSE;
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// 실패했으므로 예약된 NameValue를 해제시킨다.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// 성공
			wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CGame::_bNpcBehavior_ManaCollector(int iNpcH)
{
 int dX, dY, iMaxMP, iTotal;
 short sOwnerH;
 char  cOwnerType;
 double dV1, dV2, dV3;
 BOOL bRet;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	bRet = FALSE;
	// NPC 주변에 있는 캐릭터들의 마나를 올려준다.
	for (dX = m_pNpcList[iNpcH]->m_sX-5; dX <= m_pNpcList[iNpcH]->m_sX+5; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-5; dY <= m_pNpcList[iNpcH]->m_sY+5; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				// 같은 편인 경우 마나를 올려준다.
				if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) {
					iMaxMP = (2*(m_pClientList[sOwnerH]->m_iMag+m_pClientList[sOwnerH]->m_iAngelicMag)) + (2*m_pClientList[sOwnerH]->m_iLevel) + ((m_pClientList[sOwnerH]->m_iInt+m_pClientList[sOwnerH]->m_iAngelicInt)/2); // v1.4
					if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) {
						iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag+m_pClientList[sOwnerH]->m_iAngelicMag) ); // Mana Point는 1D(Magic)씩 올라간다.
						if (m_pClientList[sOwnerH]->m_iAddMP != 0) {
							dV2 = (double)iTotal;
							dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
							dV1 = (dV3 / 100.0f)*dV2;
							iTotal += (int)dV1;
						}

						m_pClientList[sOwnerH]->m_iMP += iTotal;
		
						if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) 
							m_pClientList[sOwnerH]->m_iMP = iMaxMP;

						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				// 근처에 마나 스톤이 있나 찾는다.
				if (m_pNpcList[sOwnerH]->m_sType == 42) {
					// 마나 스톤이 있다. 마나 스톤이 갖고 있는 마나를 얻는다.
					if (m_pNpcList[sOwnerH]->m_iV1 > 0) {
						// 마나 콜렉터가 한번에 채집할 수 있는 최대량은 3 
						if (m_pNpcList[sOwnerH]->m_iV1 >= 3) {
							m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += 3; 
							m_pNpcList[sOwnerH]->m_iV1 -= 3;
							bRet = TRUE;
						}
						else {
							m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += m_pNpcList[sOwnerH]->m_iV1; 
							m_pNpcList[sOwnerH]->m_iV1 = 0;
							bRet = TRUE;
						}
					}
					else bRet = FALSE;
				}
				break;
			}
		}
	}

	return bRet;
}


BOOL CGame::_bNpcBehavior_Detector(int iNpcH)
{
int dX, dY;
 short sOwnerH;
 char  cOwnerType, cSide;
;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
 BOOL  bFlag = FALSE;
                       
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	// NPC 주변에 있는 적 캐릭터를 탐지해 경보를 울린다.
	for (dX = m_pNpcList[iNpcH]->m_sX-10; dX <= m_pNpcList[iNpcH]->m_sX+10; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-10; dY <= m_pNpcList[iNpcH]->m_sY+10; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		cSide = 0;
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				cSide = m_pClientList[sOwnerH]->m_cSide;
				break;

			case DEF_OWNERTYPE_NPC:
				cSide = m_pNpcList[sOwnerH]->m_cSide;
				break;
			}
		}

		if ((cSide != 0) && (cSide != m_pNpcList[iNpcH]->m_cSide)) {
			// 적이다. 투명상태라면 투명을 푼다.
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;
			}
			
			bFlag = TRUE;
		}
	}

	return bFlag;
}


void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	// 전면전이 종료되었고 전쟁 공헌도가 0이 아니라면 해당하는 처리를 해 주어야 한다.
	if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		// v2.15 최대 전쟁 공헌도 경험치 감소 
		if (m_pClientList[iClientH]->m_iWarContribution > 300000 ) m_pClientList[iClientH]->m_iWarContribution = 300000 ;
		
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				// 전쟁에서 비겼다. 양쪽 모두에게 원래 경험치 제공
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution/6);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);		

				_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution/6),NULL) ;
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					// 포상해야 한다.
					// 레벨만큼 기본 경험치 추가.
					// v2.15 전면전에 경험치를 준다.
					// v2.20 2002-2-22 전면전 기본 경험치 증가. 
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*30;

					// 경험치 누적
					m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution)*(1.2);

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,m_pClientList[iClientH]->m_iWarContribution,NULL) ;
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					// 전쟁에서 졌기때문에 포상이 없다.
					// 레벨만큼 기본 경험치 추가.
					// v2.15 전면전에서 져도 10분의 1의 경험치를 준다.
					// v2.20 2002-2-22 전면전 기본 경험치 증가. 
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*30;
					
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution/5 ;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, -1*m_pClientList[iClientH]->m_iWarContribution, NULL);	
					
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution/10),NULL) ;
				}
			}
		}
		else {
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
		// 속도 조작 체크 루틴에 걸리지 않게끔 처리.
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}


void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	m_bIsCrusadeMode = TRUE;
	m_iCrusadeWinnerSide = 0;

	if (dwCrusadeGUID != NULL) {
		// 크루세이드 GUID 파일을 만든다.
		_CreateCrusadeGUID(dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// 모든 클라이언트에게 전면전 모드가 시작되었음을 알려준다. 맡은 임무 클리어 후 통보함.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, NULL, NULL);
	}

	// 스트라이크 포인트 HP 초기화.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) m_pMapList[i]->RestoreStrikePoints();

	// 각각의 맵에 초기 건물 설치. (마나 스톤, 에너지 실드 제네레이터, 그레이트 매직 제네레이터, 가드타워등등)
	CreateCrusadeStructures();
	
	PutLogList("(!)Crusade Mode ON.");

	// v2.15 크루세이드 모드
	_bCrusadeLog(DEF_CRUSADELOG_STARTCRUSADE,NULL,NULL,NULL) ;
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
 int i;

	//testcode
	wsprintf(G_cTxt, "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == FALSE) return;
	m_bIsCrusadeMode = FALSE;

	PutLogList("(!)Crusade Mode OFF.");

	// 설치되었던 크루세이드 건축물 제거.
	RemoveCrusadeStructures();
	// 전쟁용 유닛 등 제거 
	KillCrusadeObjects();

	// 이긴쪽 사이드를 입력.
	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iWinnerSide = m_iCrusadeWinnerSide = iWinnerSide;  //v2.19 2002-11-15

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// 모든 클라이언트에게 전면전 모드가 끝났음을 알려준다. 맡은 임무 클리어 후 통보함.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
	}

	// v2.20 2002-12-28 전면전 종료후 민간인 마을로 강콜
	RecallHunterPlayer() ;

	// v2.15 크루세이드 모드
	if (iWinnerSide == 2)
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE,NULL,NULL,"Elvine Win!") ;
	else if (iWinnerSide == 1)
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE,NULL,NULL,"Aresden Win!") ;
	else 
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE,NULL,NULL,"Drawn!") ;

	HeldenianStarter();
}

void CGame::RemoveEventNpc(int iNpcH)
{
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = 0;
	m_pNpcList[iNpcH]->m_dwRegenTime = 0;
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC);
	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType = 0;
			
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, NULL, 1, NULL);
	if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	}
	else {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
	}
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pNpcList[iNpcH]->m_cBehavior = 4;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

}

void CGame::LocalStartApocalypseMode(DWORD dwApocalypseGUID)
{
	register int i, j, k;
	
	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;
	
	if (dwApocalypseGUID != NULL) {
		_CreateApocalypseGUID(dwApocalypseGUID);
		m_dwApocalypseGUID = dwApocalypseGUID;
	}

	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
		}
	}
	
	for (j = 0; j < DEF_MAXMAPS; j++) {
		if (m_pMapList[j] != NULL) {
			if (m_pMapList[j]->m_cDynamicGateType == 1) {
				m_pMapList[j]->m_bIsApocalypseMobSpawn = 0;
				m_pMapList[j]->m_bIsGateAvailable = TRUE;
				m_bIsApocalypseMode = TRUE;
				for (i = 0; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
					(m_pClientList[i]->m_cMapIndex == j)) {
						for (k = 0; k < m_pMapList[j]->m_iTotalDynamicGate; k++) {
							SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, m_pMapList[j]->m_sDynamicGateX1,
							m_pMapList[j]->m_sDynamicGateY1, NULL, m_pMapList[j]->m_cName, NULL);
						}
					}
				}
			}
			else if (m_pMapList[j]->m_cDynamicGateType == 2) {
				m_pMapList[j]->m_bIsInferniaAGate = FALSE;
				m_pMapList[j]->m_bIsInferniaBGate = FALSE;
				m_pMapList[j]->m_bIsProcellaGate = FALSE;
				if ((m_pMapList[j]->m_iApocalypseMobGenType == 1) || (m_pMapList[j]->m_iApocalypseMobGenType == 2)) {
					m_pMapList[j]->m_iMaximumObjectDefault = m_pMapList[j]->m_iMaximumObject;
					m_pMapList[j]->m_iMaximumObject = 0;
					m_bIsApocalypseMode = TRUE;
					if (m_pMapList[j]->m_bIsApocalypseMap == TRUE) {
						for (i = 0; i < DEF_MAXCLIENTS; i++) {
							if ((m_pClientList[i] != NULL) &&
							(m_pClientList[i]->m_bIsInitComplete == TRUE) &&
							(m_pClientList[i]->m_iAdminUserLevel == 0) && 
							(m_pClientList[i]->m_cMapIndex == j)) {
								SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCFORCERECALLPLAYERS, NULL, NULL, NULL, NULL);
								RequestTeleportHandler(i, "1   ");
							}
						}
					}
					m_pMapList[j]->m_bIsApocalypseMobSpawn = FALSE;
					m_pMapList[j]->m_bIsBossInMap = FALSE;
				}
			}
		}
	}
	
	PutLogList("(!) Apocalypse Mode ON");
}

void CGame::LocalEndApocalypseMode()
{
	register int i, j, u;
	
	if (m_bIsApocalypseMode == FALSE) return;
	m_bIsApocalypseMode = FALSE;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
	}
	
	for (j = 0; j < DEF_MAXMAPS; j++) {
		if (m_pMapList[j] != NULL) {
			
			if ((m_pMapList[j]->m_iApocalypseMobGenType != 0)&&(m_pMapList[j]->m_cDynamicGateType == 2)) {
				m_pMapList[j]->m_iMaximumObject = m_pMapList[j]->m_iMaximumObjectDefault;
			}
			if ((m_pMapList[j]->m_bIsGateAvailable == TRUE) || (m_pMapList[j]->m_bIsInferniaAGate == TRUE) ||
			(m_pMapList[j]->m_bIsInferniaBGate == TRUE) || (m_pMapList[j]->m_bIsProcellaGate == TRUE)) {
				m_pMapList[j]->m_bIsGateAvailable = FALSE;
				m_pMapList[j]->m_bIsInferniaAGate = FALSE;
				m_pMapList[j]->m_bIsInferniaBGate = FALSE;
				m_pMapList[j]->m_bIsProcellaGate = FALSE;

				for (i = 0; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
					(m_pClientList[i]->m_cMapIndex == j)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATECLOSE, m_pMapList[j]->m_sDynamicGateX1,
						m_pMapList[j]->m_sDynamicGateY1, NULL, m_pMapList[j]->m_cName);
					}
				}
			}
		}
	}
	
	for (u = 0; u < DEF_MAXNPCS; u++) // Remove Abaddon
	{
		if(m_bIsApocalypseStarter)
		{
			if ((m_pNpcList[u] != NULL) && (m_pNpcList[u]->m_bIsKilled == FALSE))
			{
				if (m_pNpcList[u]->m_sType==81) 
				{
					NpcKilledHandler(NULL, NULL, u, NULL,FALSE);
				}
			}
		}
	}
		
	PutLogList("(!) Apocalypse Mode OFF");
	_CreateApocalypseGUID(m_dwApocalypseGUID);
}

void CGame::SaveOccupyFlagData()
{
 char * pData;
 int iSize;
 FILE * pFile;

	return;

	PutLogList("(!) Middleland OccupyFlag data saved.");
		
	pData = new char[1000000+1];
	if (pData == NULL) return;
	ZeroMemory(pData, 1000000);
			
	iSize = _iComposeFlagStatusContents(pData);
	
	_mkdir("GameData");

	pFile = fopen("GameData\\OccupyFlag.txt", "wt");
	if (pFile == NULL) return;

	fwrite(pData, 1, iSize, pFile);
	fclose(pFile);

	delete []pData;
}


void CGame::CreateCrusadeStructures()
{
 int i, z, tX, tY, iNamingValue, iTotalMS, iMSIndex[100], iMSSelected[DEF_MAXCRUSADESTRUCTURES], iMSLeft;
 char cName[6], cNpcName[21], cNpcWayPoint[11];
 BOOL bFlag;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	// v2.05 마나 스톤의 인덱스를 따로 구한다.
	for (i = 0; i < 100; i++) iMSIndex[i] = -1;
	
	iTotalMS = 0;
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType == 42) {
		iMSIndex[iTotalMS] = i;
		iTotalMS++;
		iMSSelected[i] = -1;
	}

	if (iTotalMS <= 3) {
		// 정의된 마나 스톤의 갯수가 3개 이하라면 모두 다 선택 
		iMSSelected[ iMSIndex[0] ] = 1;
		iMSSelected[ iMSIndex[1] ] = 1;
		iMSSelected[ iMSIndex[2] ] = 1;
	}
	else {
		// 임의의 3개를 선택한다. 
		iMSLeft = 3;
		bFlag = FALSE;
		while (bFlag == FALSE) {
			i = iDice(1, iTotalMS) -1;
			if (iMSIndex[i] != -1) {
				iMSSelected[ iMSIndex[i] ] = 1;
				iMSIndex[i] = -1;
				iMSLeft--;
				if (iMSLeft <= 0) bFlag = TRUE;
			}
		}
	}
	// iMSSelected[DEF_MAXCRUSADESTRUCTURES] 배열에 선택된 마나 스톤에 1값이 들어가 있다.
	
	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType != NULL) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
			// 위치가 일치하는 맵에 건축물을 위치시킨다.
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
				// 이런 일이?
			}
			else {
				ZeroMemory(cName, sizeof(cName));
				ZeroMemory(cNpcName, sizeof(cNpcName));

				// NPC를 생성한다.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stCrusadeStructures[i].cType) {
				case 36:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "AGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "AGT-Elvine");
					break;

				case 37: 
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "CGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "CGT-Elvine");
					break;

				case 40:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "ESG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "ESG-Elvine");
					break;

				case 41:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "GMG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "GMG-Elvine");
					break;

				case 42:
					// v2.05
					if (iMSSelected[i] == 1) strcpy(cNpcName, "ManaStone");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stCrusadeStructures[i].dX;
				tY = (int)m_stCrusadeStructures[i].dY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
					PutLogList(G_cTxt);
				}
			}
		}
	}
}


void CGame::SendCollectedMana()
{
 char * cp, cData[120];
 WORD * wp;

        if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;

        wsprintf(G_cTxt, "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
        PutLogList(G_cTxt);

        ZeroMemory(cData, sizeof(cData));
        cp = (char *)(cData);
        *cp = GSM_COLLECTEDMANA;
        cp++;

        wp = (WORD *)cp;
        *wp = (WORD)m_iCollectedMana[1];
        cp += 2;

        wp = (WORD *)cp;
        *wp = (WORD)m_iCollectedMana[2];
        cp += 2;

        CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);

        bStockMsgToGateServer(cData, 5);
        
        m_iCollectedMana[0] = 0;
        m_iCollectedMana[1] = 0;
        m_iCollectedMana[2] = 0;
}


void CGame::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{
        if (m_iAresdenMapIndex != -1) {
                m_iAresdenMana += wAresdenMana;
                if (wAresdenMana > 0) {
                        wsprintf(G_cTxt, "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
                        PutLogList(G_cTxt);
                }
        }

        if (m_iElvineMapIndex != -1) {
                m_iElvineMana += wElvineMana;
                if (wElvineMana > 0) {
                        wsprintf(G_cTxt, "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
                        PutLogList(G_cTxt);
                }
        }
}


void CGame::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
	switch (m_pNpcList[iNpcH]->m_cSide) {
	case 1:
		if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
			// 마나를 흡수한다.
			m_iAresdenMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			// 만약 마법 공격을 하기에 충분한 마나가 찼다면 적국으로 마법 공격
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				// 메테오 스트라이트 시그널
				_GrandMagicLaunchMsgSend(1, 1);
				MeteorStrikeMsgHandler(1);
				// 마나 클리어
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iAresdenMana = 0;
				// 공격 동작을 한다.
			}
			//testcode
			wsprintf(G_cTxt, "(!) Aresden GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;

	case 2:
		if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
			// 마나를 흡수한다.
			m_iElvineMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			// 만약 마법 공격을 하기에 충분한 마나가 찼다면 적국으로 마법 공격
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				// 메테오 스트라이트 시그널
				_GrandMagicLaunchMsgSend(1, 2);
				MeteorStrikeMsgHandler(2);
				// 마나 클리어
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iElvineMana = 0;
				// 공격 동작을 한다.
			}
			//testcode
			wsprintf(G_cTxt, "(!) Elvine GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;
	}
}


void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
 int i;
 DWORD dwTime = timeGetTime();
	
	switch (cAttackerSide) {
	case 1:
		// 아레스덴 측의 폭격이다. 딜레이 이벤트에 등록
		if (m_iElvineMapIndex != -1) {
			// 현재 서버에 폭격 지점이 있다.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				// v2.19 2002-11-12 강콜 지역을 확대하기 위해 LocationName 을 m_cName 으로 변경함  Location Name을 강콜 지역으로 설정함 .
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvine") == 0) {
					// 엘바인에 소속된 맵의 모든 플레이어에게 메테오 스트라이크 공격이 임박했음을 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					// 다른 맵의 플레이어에게도 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			// 5초 후 메테오 스트라이크 공격 효과
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				// 다른 맵의 플레이어에게도 알려준다.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		// 엘바인 측의 폭격이다. 딜레이 이벤트에 등록
		if (m_iAresdenMapIndex != -1) {
			// 현재 서버에 폭격 지점이 있다.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				// v2.19 2002-11-12 강콜 지역을 확대하기 위해 LocationName 을 m_cName 으로 변경함  Location Name을 강콜 지역으로 설정함 .
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresden") == 0) {
					// 아레스덴에 소속된 맵의 모든 플레이어에게 메테오 스트라이크 공격이 임박했음을 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					// 다른 맵의 플레이어에게도 알려준다.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			// 5초 후 메테오 스트라이크 공격 효과
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				// 다른 맵의 플레이어에게도 알려준다.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

void CGame::_LinkStrikePointMapIndex()
{
 int i, z, x;

	// 마을과 건물 내부를 다른 서버에 띄우면 링크가 불가능하므로 다운된다!
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
		// 스트라이크 포인트가 정의된 맵이다. 각각의 스트라이크 포인트와 연계된 맵의 인덱스를 구해 저장한다.
		for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) 
		if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
			for (x = 0; x < DEF_MAXMAPS; x++) 
			if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
				// 인덱스를 구했다. 저장한다.
				m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
				//testcode
				wsprintf(G_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
				PutLogList(G_cTxt);

				goto LSPMI_LOOPBREAK;
			}
LSPMI_LOOPBREAK:;
		}
	}
}


void CGame::MeteorStrikeHandler(int iMapIndex)
{
 int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
 int iTargetArray[DEF_MAXSTRIKEPOINTS];
 short sOwnerH;
 char  cOwnerType;
 DWORD dwTime = timeGetTime();
	
	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}
	
	if (m_pMapList[iMapIndex] == NULL) {
		PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}
	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}
	
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i; // 스트라이크 포인트의 인덱스를 넣는다.
			iIndex++;
		}
	}

	//testcode
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	// 결과 보고용 스트럭춰 클리어
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		// 폭격할 건물이 없다. 모두 파괴되었다.
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
	else {

		// 해당 맵의 클라이언트들에게 메테오 공격 효과를 보여주라는 메시지 전송
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
		}
		
		for (i = 0; i < iIndex; i++) {
			// 모든 폭격 목표에 대해 동일한 공격을 가한다.
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY 위치 주위에 최소 2개 이상의 Energy Shield Generator가 존재하면 스트라이크 포인트는 무사하다. 그러나 1개 이하이면 공격받았을때 HP가 줄어든다.
			// NPC 주변에 있는 적 캐릭터를 탐지해 경보를 울린다.
			iTotalESG = 0;
			for (ix = dX-10; ix <= dX+10; ix++) 
			for (iy = dY-10; iy <= dY+10; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
					iTotalESG++;
				}
			}
			
			// testcode
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {
			
				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					// 건물이 파괴되었다.
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// 건물 기능 상실
					//m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = TRUE;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					// 건물이 대미지를 얻었다.
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					// 건물 대미지 입은 후 불타는 이미지 삽입 
					iEffect = iDice(1,5)-1;
					iAddDynamicObjectList(NULL, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex, 
						                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(iDice(1,3) -2), 
										  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(iDice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}

		// 1초 후 메테오 스트라이크 공격 대미지 효과
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 4초 후 메테오 스트라이크 공격 대미지 효과
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 4000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 6초 후 공격 결과 판단.
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;

	// v2.04 좌표 보정 
	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	// 게이트 서버 메시지 작성 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// 먼저 같은 GUID를 가진 길드 텔레포트 좌표가 설정되어 있는지 찾는다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// 내용 갱신후 
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				
			//게이트 서버를 통해 다른 서버로 정보 전송
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			//게이트 서버를 통해 다른 서버로 정보 전송  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;

	//게이트 서버를 통해 다른 서버로 정보 전송
	bStockMsgToGateServer(cData, 23);
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;

	// 게이트 서버 메시지 작성 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// 먼저 같은 GUID를 가진 길드 컨스트럭트 좌표가 설정되어 있는지 찾는다. 
	// 텔레포트 위치의 2번 변수들을 사용한다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// 내용 갱신후 
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				
			//게이트 서버를 통해 다른 서버로 정보 전송
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

			//게이트 서버를 통해 다른 서버로 정보 전송  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

	//게이트 서버를 통해 다른 서버로 정보 전송
	bStockMsgToGateServer(cData, 23);
}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
 register int i;
 char cMapName[11];
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
		// 맵에 갖혔다면 그 시간동안 텔레포트 불가능.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}
    if (memcmp(m_pClientList[iClientH]->m_cMapName, "middleland",10) == 0) return; 
    
	if (m_bIsCrusadeMode != TRUE) {
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	for (i = 0; i < DEF_MAXGUILDS; i++) 
	if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
		// 길드를 찾았다.
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

		//testcode
		wsprintf(G_cTxt, "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
		PutLogList(G_cTxt);

		// !!! RequestTeleportHandler내에서 m_cMapName을 쓰기 때문에 그대로 파라미터로 넘겨주면 오동작
		RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
		return;
	}
	
	// 길드에 할당된 텔레포트 좌표가 없다. 길드 소속이 아닌 경우
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: // 아레스덴 소속 
		break;
	case 2: // 엘바인 소속
		break;
	}
}

void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
 char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
 register int i, x;
 int iNamingValue, tX, tY, ix, iy;
 BOOL bRet;
 short sOwnerH;
 DWORD dwTime = timeGetTime();
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
    if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland", 10) != 0) 
		&&(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden", 7) != 0) 
		&&(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine", 6) != 0) )
		return;
	
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));
		
	// 에러 체크용 
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum  >  10) return;

	// 건설하기에 포인트가 모자란다.
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	// 건물 내부면 전쟁 유니트 소환 불가.
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)) return; 

	// 일단 에러방지용
	cNum = 1;

	// ConstructionPoint 제한을 계산하고 유니트 개수만큼 줄인다.
	for (x = 1; x <= cNum; x++) {
		// 개수만큼  전쟁 유니트 생성 
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
			// 이런 일이?
		}
		else {
			// NPC를 생성한다.
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			
			// 동일한 타입을 갖지만 다른 사이드를 갖는 경우 

			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;
			}

			//testcode
			wsprintf(G_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);
			
			tX = (int)dX;
			tY = (int)dY;
						
			// 만약 전쟁 건축물이라면 건축 위치로부터 인접해야 한다.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				// 건설 위치를 비교
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

				if (bRet == TRUE) {
					// 건설 위치와 너무 멀리 벗어나 있으면 건축 불가.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
					return;
				}

				// 길드에서 건설한 건축물의 갯수를 카운트한다. 일정 갯수 이상은 지을 수 없다.
				/////
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
						// 길드 건설 개수 초과. 지을수 없다.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);		
						return;
					}
					else {
						// 건설된 건물 갯수 증가.
						m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}

				// 길드 설정되어 있지 않음. 지을수 없다.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				break;

			// 2002-12-24 전면전시 소환할 수 있는 (건물 수를 제외한) NPC의 수를 제한한다.(대만 요청)
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iNumSummonNpc >= DEF_MAX_CRUSADESUMMONMOB) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 4, NULL, NULL, NULL);
					return;
				} else {
					m_pGuildTeleportLoc[i].m_iNumSummonNpc ++;
					goto RSWU_LOOPBREAK;
				}

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				break;	
			}
			
RSWU_LOOPBREAK:;

			// 만약 전쟁 건축물중 가드타워같이 공격형이라면 너무 인접해서 건설할 수 없다.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36:
						case 37:
							bRet = TRUE;
							break;
						}
					}
				}

				// 지을 수 없는 상위좌표
				if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
				break;
			}

			if (bRet == TRUE) {
				// 근처에 가드타워들이 있어서 건축불가.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
				return;
			}

			// 가드 모드인가 추종 모드인가 선택 
			if (cMode == NULL) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				
			if (bRet == FALSE) {
				// 실패했으므로 예약된 NameValue를 해제시킨다.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
			else {
				// 건설에 성공했으므로 건설 포인트 감소 시킨다.
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				// 지휘관에게 바로 통보.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);

#ifdef DEF_TAIWANLOG
				_bItemLog(DEF_ITEMLOG_SUMMONMONSTER,iClientH,cNpcName,NULL) ;
#endif
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
 char * cp;
 DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == NULL) return;
	
	dwTime = timeGetTime();
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwTimeRcv = *dwp;
	CheckDenialServiceAttack(iClientH, dwTimeRcv);

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);
		
		// 클라이언트에서 지나간 시간이 더 적다. 무시해도 된다. 속도를 사용한 경우는 서버보다 클라이언트가 시간이 더 간 경우.
		if (dwTimeGapClient < dwTimeGapServer) return;

		if ((abs(dwTimeGapClient - dwTimeGapServer)) >= (DEF_CLIENTTIMEOUT)) {
		/*	// v1.4334 
			wsprintf(G_cTxt, "(!) 캐릭터(%s) 속도 조작 %u %u %u %u %u %u 속도차이 %u", m_pClientList[iClientH]->m_cCharName, dwTimeRcv, m_pClientList[iClientH]->m_dwInitCCTimeRcv, dwTime, m_pClientList[iClientH]->m_dwInitCCTime,dwTimeGapClient,dwTimeGapServer,   dwTimeGapClient - dwTimeGapServer );
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			
			SYSTEMTIME SysTime;
			GetLocalTime(&SysTime);
						
			m_pClientList[iClientH]->m_iPenaltyBlockYear  = SysTime.wYear+1;
			m_pClientList[iClientH]->m_iPenaltyBlockMonth = SysTime.wMonth;
			m_pClientList[iClientH]->m_iPenaltyBlockDay   = SysTime.wDay;
		*/	
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}

}


void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{
	if (m_pClientList[iClientH] == NULL) return;
	// 길드 마스터가 아닌데 지휘관 역할을 맡겠다는 메시지가 수신되면 무시.
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	//v2.19 2002-11-15  전면전시 전에 전면전에 진쪽은 길드마스터들은 소환 포인트를 3000을 넣어 준다..
//	if(m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)

#ifdef DEF_V219

	if( (3 - m_iWinnerSide) == m_pClientList[iClientH]->m_cSide) 
	if(m_pClientList[iClientH]->m_iCrusadeDuty == 0)
	{
		if(3==iDuty)
		{
			m_pClientList[iClientH]->m_iConstructionPoint = 3000;
		}
	}
#endif

	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	
	if (iDuty == 1) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Fighter") ;
	else if (iDuty == 2) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Constructor") ;
	else
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Commander") ;
}

void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
				          NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
						  NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);	
			// 건설 위치를 저장해 놓는다.
			ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
			memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
			m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
			m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
			return;
		}

		// 길드 소속이 아닌 군인의 요청이다.
		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		// 데이터 캐시 구조체 초기화 
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			// 현재 사용자가 위치한 맵의 정보를 요구했다.
			// 맵 데이터를 요청할 당시의 내용을 그대로 카피한다.
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				// v2.15 사용자가 Commander 가 아니어도 건물의 위치를 보여준다.
				if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			// 다른 맵의 상황을 요청했다. 미들랜드의 경우는 가능 
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				// v2.15 사용자가 Commander 가 아니어도 건물의 위치를 보여준다.
					if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}								
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
				// 아직 지원되지 않는 기능이다.
			}
		}
	
		_SendMapStatus(iClientH);
		break;
	}
}


void CGame::_SendMapStatus(int iClientH)
{
 register int i, iDataSize;
 char *cp, cData[DEF_MAXCRUSADESTRUCTURES*6];
 short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;
	
	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	// 총 몇개의 데이터가 있는지 알리는 곳 띄움.
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

	// 100개씩 정보를 보낸다.
	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;
		// v2.15 보통 캐릭터는 마나 스톤만 보여준다.
		if ((m_pClientList[iClientH]->m_iCSIsendPoint >= 3) && (m_pClientList[iClientH]->m_iCrusadeDuty != 3) )  goto SMS_ENDOFDATA;
		
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	// 여기까지 왔다면 더 보낼 메시지가 있다는 의미.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;

	// 데이터가 다 전송 되었음을 의미.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;

	return;
}


void CGame::RemoveCrusadeStructures()
{
 register int i;

	for (i = 0 ; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		switch (m_pNpcList[i]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
			DeleteNpc(i);
			break;
		}
	}
}

// v2.20 2002-12-28 전면전 종료후 민간인 마을로 강콜
void CGame::RecallHunterPlayer()
{
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	{
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsWarLocation == TRUE) 
			&& (m_pClientList[i]->m_bIsHunter == TRUE) && (m_pClientList[i]->m_bIsInitComplete == TRUE) )
		{
			m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
		}
	}


}


void CGame::RequestHelpHandler(int iClientH)
{
 // 헬프 요청이다. 길드 마스터에게 좌표를 전달해 준다.
 register int i;	

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildRank == 0) && 
		(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
		// 같은 길드 마스터이고 지휘관 역활을 맡은 상태이다.
		SendNotifyMsg(NULL, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
		return;
	}

	// 현재 맵에 지휘관이 없음을 통보해 준다.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELPFAILED, NULL, NULL, NULL, NULL);
}


BOOL CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
 char * cp;

	//testcode
	//wsprintf(G_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	//PutLogList(G_cTxt);

	if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return FALSE;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return TRUE;
}


void CGame::SendStockMsgToGateServer()
{
 DWORD * dwp;
 WORD * wp;
 char * cp;

	// 그동안 모아놓았던 메시지를 게이트 서버로 전송.
	if (m_iIndexGSS > 6) {
		//testcode
		//wsprintf(G_cTxt, "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
		//PutLogList(G_cTxt);

		SendMsgToGateServer(MSGID_SERVERSTOCKMSG, NULL, m_cGateServerStockMsg);
	
		// 버퍼 클리어
		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		// 맨 앞부분에 메시지 삽입
		cp = (char *)m_cGateServerStockMsg;
		dwp = (DWORD *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (WORD *)cp;
		*wp = DEF_MSGTYPE_CONFIRM;
		cp += 2;

		m_iIndexGSS = 6;
	}
}


void CGame::ServerStockMsgHandler(char *pData)
{
 char * cp, * cp2, cTemp[120], cTemp2[120], cTemp3[120], cName[11], cBuffer[256];
 short * sp;
 WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4 , wV5;
 DWORD * dwp, dwV1;
 BOOL bFlag = FALSE;
 int * ip, i, iTotal, iV1, iV2, iV3, iRet;
 short sX, sY;
	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == FALSE) {
		iTotal++;
		switch (*cp) {
		case GSM_DISCONNECT:
			ZeroMemory(cName, sizeof(cName));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex != -1) && (strcmp(m_pClientList[i]->m_cWhisperPlayerName, cName) == 0)) {
				// 귓속말 상태가 해제되었음을 통보. 
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
				goto SSMH_LOOPBREAK; 
			}
			break;

		case GSM_WHISFERMSG:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			memcpy(cBuffer, cp, wV1);
			cp += wV1;
		
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
				if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
					char cTxt[200],cTmpName[12] ;
					ZeroMemory(cTxt,sizeof(cTxt)) ;
					ZeroMemory(cTmpName,sizeof(cTmpName)) ;

					memcpy(cTmpName,cBuffer+10,10) ;
					wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
					bSendMsgToLS(MSGID_GAMEMASTERLOG,i, FALSE,cTxt);
				}
				break;
			}

			break;
		
		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (WORD)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;
		
		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			// 구조체 클리어
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;
			// 정보 읽어들인다.
			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;	
			}
			break;
		
		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;
			
		case GSM_BEGINAPOCALYPSE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartApocalypseMode(*dwp);
			break;
			
		case GSM_ENDAPOCALYPSE:
			cp++;
			LocalEndApocalypseMode();
			cp += 16;
			break;
		
		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;
		
		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			CollectedManaHandler(wV1, wV2);
			break;
				
		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			switch (wV1) {
			case 1: // 메테오 스트라이크 
				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;
		
		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV3 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV4 = *wp;
			cp += 2;

			// v2.15 나중 확장을 위해 현재 건물의 갯수를 보냄 
			wp  = (WORD *)cp;
			wV5 = *wp;
			

		/*	cp++ ;

			// 4개 건물의 HP를 받는다.
			wp  = (WORD *)cp;
			wV5 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV6 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV7 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV8 = *wp;
			cp += 2; */ 

			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4,wV5,cp);
			break;
// pegalo aca

			case GSM_REQUEST_SUMMONALL:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			cp2 = (char *) cTemp + 10;
			
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			
			for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, cName) == 0)) {
			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
		}
		break;
		// v2.14 성후니 추가 유저 소환 
		case GSM_REQUEST_SUMMONPLAYER:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
				
				//testcode
		//		wsprintf(G_cTxt, "(!) Request Teleport (%s)(%d)(%d).", cTemp,wV1,wV2);
		//		PutLogList(G_cTxt);
#ifdef DEF_TAIWANLOG
				short sX = 0,sY = 0 ;
				char cMapName[22] ; 

				ZeroMemory(cMapName,sizeof(cMapName)) ;

				sX = m_pClientList[i]->m_sX ;
				sY = m_pClientList[i]->m_sY ;
				strcpy(cMapName, m_pClientList[i]->m_cMapName) ;

				m_pClientList[i]->m_sX = wV1;
				m_pClientList[i]->m_sY = wV2;
				strcpy(m_pClientList[i]->m_cMapName, cTemp) ;

				_bItemLog(DEF_ITEMLOG_SUMMONPLAYER, i, cTemp2,NULL) ;

				m_pClientList[i]->m_sY = sY ; 
				m_pClientList[i]->m_sX = sX ;

				strcpy(m_pClientList[i]->m_cMapName,cMapName) ;

#endif
				RequestTeleportHandler(i, "2   ", cTemp ,wV1, wV2);
				break;
			}
			break ;

		

			// v2.15 2002-5-21
		case GSM_REQUEST_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;
			
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);

			break ;
		case GSM_STARTHELDENIAN:

			cp++;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			dwp = (DWORD *)cp;
			cp += 4;

			LocalStartHeldenianMode(wV1, wV2, *dwp);
			break;

		case GSM_STARTHELDENIANFIGHT:

			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
		
			bHeldenianFight = iV1;
			break;

		case GSM_ENDHELDENIAN:
			cp++;
			
			dwp = (DWORD *)cp;
			dwV1 = *dwp;
			cp += 4;
			
			ip = (int *)cp;
            iV1 = *ip;
			cp += 4;
            
			m_sLastHeldenianWinner = iV1;
			CreateHeldenianGUID(dwV1, iV1); 
            HeldenianEnd();
			
		   // LocalEndHeldenianMode(); 
		  			
			break;
			
	case GSM_RESPONSE_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;


			if (wServerID == m_wServerID_GSS) {
				
				if ((m_pClientList[wClientH] != NULL)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
					SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERSHUTUP, wV1, NULL, NULL, cTemp);
					
				}
			}
			break;

		case GSM_REQUEST_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			GSM_RequestFindCharacter(wServerID, wClientH, cTemp,cTemp2);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			sX = -1;
			sY = -1;
			char cMapName[22];
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			ZeroMemory(cTemp3, sizeof(cTemp3));
			memcpy(cTemp3, cp, 14);

			if ((wServerID == m_wServerID_GSS) && m_pClientList[wClientH] != NULL) {
				if (m_pClientList[wClientH]->m_bIsAdminOrderGoto == TRUE) {
					m_pClientList[wClientH]->m_bIsAdminOrderGoto = FALSE;
					ZeroMemory(cMapName, sizeof(cMapName));
					memcpy(cMapName, cp, 10);
					cp += 10;

					wp = (WORD *)cp;
					sX = *wp;
					cp += 2;

					wp = (WORD *)cp;
					sY = *wp;
					cp += 2;

					if (m_pClientList[wClientH]->m_iAdminUserLevel > 0) {
						if(sX == -1 && sY == -1){
							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)",m_pClientList[wClientH]->m_cCharName, cMapName);
						}
						else{
							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[wClientH]->m_cCharName,
								cMapName, sX, sY);
						}
				//		bSendMsgToLS(MSGID_GAMEMASTERLOG, wClientH, FALSE, G_cTxt);
						RequestTeleportHandler(wClientH,"2   ", cMapName, sX, sY);
					}
				}
				else{
					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer == TRUE) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
						SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[wClientH]->m_cWhisperPlayerName);
					}
					else{
						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) {
							ZeroMemory(cTemp3, sizeof(cTemp3));
						}
						if (strcmp(m_pClientList[wClientH]->m_cCharName, cTemp2) == 0) {
							SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp,
								NULL, NULL, NULL, NULL, NULL, NULL, cTemp3);
						}
					}
				}
			}
			break;
		//2009-03-18
		case GSM_ENDCITYWAR:
			if (m_bCityWarStarter == TRUE) break;
			m_bCityWar = FALSE;
			cp++;

			m_cCityWarWinner = *cp;

			for(i=0;i<DEF_MAXCLIENTS;i++){
				if(m_pClientList[i] != NULL)
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CITYWAREND, m_cCityWarWinner, NULL, NULL, NULL);
			}
			_CreateCityWarGUID(m_cCityWarWinner);
			break;
		case GSM_BEGINCITYWAR:
			if (m_bCityWarStarter == TRUE) break;
			m_bCityWar = TRUE;
			cp++;

			for(i=0;i<DEF_MAXCLIENTS;i++){
				if(m_pClientList[i] != NULL)
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CITYWARBEGIN, m_iCityWarAresdenDead, m_iCityWarElvineDead, NULL, NULL);
			}
			break;

		case GSM_REQUEST_SETFORCERECALLTIME:
			cp++;
			wp = (WORD *)cp;
			m_sForceRecallTime = *wp;
			cp += 2;

			wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
			PutLogList(G_cTxt) ;

		default:
			bFlag = TRUE;
			break;
		}

SSMH_LOOPBREAK:;
	}

	//testcode
	//wsprintf(G_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(G_cTxt);
}

// v2.15 2002-5-21
void CGame::GSM_RequestShutupPlayer(char * pGMName,WORD wReqServerID, WORD wReqClientH, WORD wTime,char * pPlayer )
{
 char * cp, cTemp[120];
 WORD * wp;
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {
		// 찾았다.
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_SHUTUPPLAYER;
		cp++;

		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		
		memcpy(cp, pGMName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = (WORD) wTime;
		cp += 2;

		memcpy(cp, pPlayer, 10);
		cp += 10;

					// v2.14 셧업시간을 분으로 수정
		m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; // 1이 3초다. 20이면 1분 
		
		SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, wTime, NULL, NULL, pPlayer);

#ifdef DEF_TAIWANLOG

			_bItemLog(DEF_ITEMLOG_SHUTUP,i,pGMName,NULL) ;

			// Admin Log
			// v2.14 성후니 수정 
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min",pGMName, 
				     m_pClientList[i]->m_cCharName, wTime);

			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);
#endif

		bStockMsgToGateServer(cTemp, 27);
		return;	
	}
}

void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName, char * pFinder)
{
 char * cp, cTemp[120];
 WORD * wp;
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL)  && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
		// 짙쩐쨈.
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		
		memcpy(cp, pName, 10);
		cp += 10;

		memcpy(cp, pFinder, 10);
		cp += 10;

		memcpy(cp, m_pClientList[i]->m_cMapName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sX;
		cp += 2;

		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sY;
		cp += 2;

		bStockMsgToGateServer(cTemp, 39);
		return;	
	}
}

void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;

	// 해당 맵의 플레이어들의 HP를 일괄 삭감
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		if (m_pClientList[i]->m_iLevel < 80) 
			 iDamage = m_pClientList[i]->m_iLevel   +iDice(1,10);
		else iDamage = m_pClientList[i]->m_iLevel*2 +iDice(1,10);
		iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
		// 최대 255이상의 대미지는 받지 않는다.
		if (iDamage > 255) iDamage = 255;

		// v2.04 만약 마방이 걸려 있다면 대미지는 절반 
		if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) iDamage = iDamage / 2;

		// v2.14 운영자는 메테오 공격을 받았을때 데미지를 받지 않는다.
		if(m_pClientList[i]->m_iAdminUserLevel > 0 ) iDamage = 0 ;

		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			// 플레이어가 사망했다.
			ClientKilledHandler(i, NULL, NULL, iDamage);	
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				// 받은 대미지를 통보한다. <- HP를 그대로 알린다.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				// 충격을 받았다면 충격동작 전송 
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				// v1.4 죽은척하고 있는 경우는 Owner 위치를 옮긴다. 
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}
			
				if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person 되어 있었던 상태라면 풀린다. 마법공격 패럴라이즈 된 것도 풀린다.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}		
	}
}


// v2.15 메테오에 맞을때 남은 건물 HP 를 보여주기 위한 루틴 
// 주의 현재 건물이 4개인 경우에 맞춰서 루틴이 형성 되어 있다.
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
 int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS] ;
 char * cp, * cp2, cData[120], cWinnerSide, cTempData[120];
 WORD * wp;

	if (m_bIsCrusadeMode == FALSE) return;

	// 사용자에게 남은 건물의 HP를 보여주기 위한 변수 초기화 
	for(i = 0 ; i < DEF_MAXSTRIKEPOINTS; i++)
		iStructureHP[i] = 0 ;

	// 폭격의 효과를 계산한다. 모든 건물이 파괴되었다면 전면전 모드 종료. 그렇지 않으면 결과를 모든 서버에 리포트.
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	
	//testcode
	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);

	if (iActiveStructure == 0) {
		// 작동중인 건물이 없다. 크루세이드 모드 종료: 다른 서버에 알려준다.
		// 크루세이드 모드 종료됨을 현재 서버의 클라이언트들에게 바로 전달.
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); // 이긴 쪽은 엘바인
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); // 이긴 쪽은 아레스덴
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0); 
		}
		
		// 다른 서버에 크루세이드 종료를 알림.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;

		*cp = cWinnerSide;
		cp++;			

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		bStockMsgToGateServer(cData, 18);

	}
	else {
		// 피해 상황을 모든 서버로 리포트.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;
		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD) iActiveStructure;
		cp += 2;

		//v2.15 추가  토탈 건물의 갯수 
		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 

		wp = (WORD *)cp2;
		*wp = (WORD) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;

		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++){
			wp = (WORD *)cp2;
			*wp = (WORD) iStructureHP[i];
			cp2 += 2;
		}

		memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;

		// v2.15 
		bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );
		
		// 현재 서버에는 스톡 메시지가 오지 않으므로 직접 전달한다.
		// v2.15 건물의 갯수와 HP를 보낸다.
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure,m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}

	// 결과 보고용 스트럭춰 클리어
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}


// v2.15 건물의 HP를 보여주기 위해 변경함 
void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iSTcount,char * pData)
{
 int i;
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		SendNotifyMsg(NULL, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure,0,0,0,0,iSTcount,pData);
	}
}

void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
 char * cp, cBuff[120];
 WORD * wp;

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;
	
	bStockMsgToGateServer(cBuff, 5);
}

void CGame::SyncMiddlelandMapInfo()
{
 int i;
 char * cp;
 short * sp;

	// 미들랜드의 정보를 모든 서버에게 싱크시킨다. 미들랜드를 담당한 서버라면 바로 구조체를 업데이트 하고 나머지 서버들에게 정보 전송.
	if (m_iMiddlelandMapIndex != -1) {
		// 구조체 클리어
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		// 구조체 복사 및 전송 메시지 작성 
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;
				
		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;
			
			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}
		
		// 메시지 스톡.
		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//wsprintf(G_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(G_cTxt);
			bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// 클라이언트로부터의 요청이 아니라 다른 서버로부터의 텔레포트 좌표 설정 요청임. 응답할 필요 없음.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// 먼저 같은 GUID를 가진 길드 텔레포트 좌표가 설정되어 있는지 찾는다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// 내용 갱신
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// 클라이언트로부터의 요청이 아니라 다른 서버로부터의 텔레포트 좌표 설정 요청임. 응답할 필요 없음.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// 먼저 같은 GUID를 가진 길드 텔레포트 좌표가 설정되어 있는지 찾는다.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// 이미 길드가 있다.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// 내용이 일치한다. 타임 입력후 스킵.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// 내용 갱신
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
	}
	
	// 설정된 내용이 없다. 새로 설정한다.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// 가장 오랫동안 참조되지 않은 리스트의 인덱스를 찾는다.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// 캐시 공간이 다 찼다. 이런 경우 리스트 중 가장 오랫동안 사용하지 않은 리스트(iIndex)를 삭제하고 업데이트 한다.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstLocuct Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

void CGame::GlobalStartCrusadeMode()
{
 char * cp, cData[120];
 DWORD * dwp, dwCrusadeGUID;

	dwCrusadeGUID = timeGetTime();

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::GlobalStartApocalypseMode()
{
	char *cp, cData[120];
	DWORD *dwp, dwApocalypseGUID;
	
	dwApocalypseGUID = timeGetTime();
	
	ZeroMemory(cData, sizeof(cData));
	cp  = (char *)cData;
	*cp = GSM_BEGINAPOCALYPSE;
	cp++;
	
	dwp  = (DWORD *)cp;
	*dwp = dwApocalypseGUID;
	cp  += 4;
	
	bStockMsgToGateServer(cData, 5);
	
	LocalStartApocalypseMode(dwApocalypseGUID);
}

void CGame::GlobalEndApocalypseMode()
{
	char *cp, cData[120];
	
	ZeroMemory(cData, sizeof(cData));
	cp  = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;
	
	bStockMsgToGateServer(cData, 5);
	
	LocalEndApocalypseMode();
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
 char * cp, cData[120];
 int  * ip, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_bIsCrusadeMode == FALSE) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // 파이터
	case 2: // 건설자: 모아 놓은 포인트를 길드마스터 지휘관에게 전달한다.
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			// 현재 서버 내에 길드마스터 지휘관이 있다. 지휘관의 포인트를 높인 후 
			m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
			// v2.19 2002-12-4 길드 마스터의 경험치를 높힌다.
			m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 6);

			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
			if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
			m_pClientList[iClientH]->m_iConstructionPoint = 0; // 값 초기화 
			return;
		}

		// 다른 서버의 지휘관에게 알려야 한다.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);

		m_pClientList[iClientH]->m_iConstructionPoint = 0; // 값 초기화 
		break;

	case 3: // 지휘관: 보낼 필요 없음 
		
		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
		(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {
		// 해당 길드마스터 지휘관을 찾았다.
		// v2.19 2002-12-4 길드 마스터의 경험치를 높힌다.
		m_pClientList[i]->m_iConstructionPoint += iPoint;
		m_pClientList[i]->m_iWarContribution   += iPoint/6;

		
		if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
			m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
		if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
			m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

		SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "GSM_ConstructionPoint: %d %d", iGuildGUID, iPoint);
		PutLogList(G_cTxt);
		return;
	}
}

BOOL CGame::bAddClientShortCut(int iClientH)
{
 int i; 

	// 먼저 동일한 번호가 존재하는지 검색

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == iClientH) return FALSE;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == 0) {
		m_iClientShortCut[i] = iClientH;
		return TRUE;
	}

	return FALSE;
}

void CGame::RemoveClientShortCut(int iClientH)
{
 int i;

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
	if (m_iClientShortCut[i] == iClientH) {
		m_iClientShortCut[i] = 0;
		goto RCSC_LOOPBREAK;
	}

RCSC_LOOPBREAK:;

	// 빈 여백을 메꾼다.
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
		m_iClientShortCut[i] = m_iClientShortCut[i+1];
		m_iClientShortCut[i+1] = 0;
	}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		// 파일을 만들 수 없거나 사이즈가 지나치게 작은 경우는 . 
		wsprintf(cTxt, "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

BOOL CGame::bReadCrusadeGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		PutLogList("(!) Cannot open CrusadeGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					wsprintf(G_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iWinnerSide = m_iCrusadeWinnerSide = atoi(token);
					wsprintf(G_cTxt, "CrusadeWinnerSide = %d", m_iCrusadeWinnerSide);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete []cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::_CreateApocalypseGUID(DWORD dwApocalypseGUID)
{
	char *cp, cTxt[256], cFn[256], cTemp[1024];
	FILE *pFile;
	
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn, "GameData");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, "ApocalypseGUID.txt");
	
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create ApocalypseGUID(%d) file", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "ApocalypseGUID = %d\n", dwApocalypseGUID);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) ApocalypseGUID(%d) file created", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

BOOL CGame::bReadApocalypseGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Cannot open ApocalypseGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading ApocalypseGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwApocalypseGUID = atoi(token);
					wsprintf(G_cTxt, "ApocalypseGUID = %d", m_dwApocalypseGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "ApocalypseGUID", 11) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete []cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::ManualEndCrusadeMode(int iWinnerSide)
{
 char * cp, cData[256];
 WORD * wp;

	if (m_bIsCrusadeMode == FALSE) return;

	LocalEndCrusadeMode(iWinnerSide);

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)iWinnerSide;
	cp++;			

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;
		
	cp += 10;

	bStockMsgToGateServer(cData, 18);
}


int CGame::iGetMapLocationSide(char *pMapName)
{

	// 건물안 혹은 농경지만 검사할때는 필요 없다.

	if (strcmp(pMapName, "aresden") == 0) return 3 ;
	if (strcmp(pMapName, "elvine") == 0)  return 4 ;
	if (memcmp(pMapName, "arebrk11", 8) == 0) return 3 ;
	if (memcmp(pMapName, "elvbrk11", 8) == 0) return 4 ;


	if (memcmp(pMapName, "cityhall_1", 10) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "cityhall_2", 10) == 0)  return DEF_ELVINE ;

	if (memcmp(pMapName, "cath_1", 6) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "cath_2", 6) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "gshop_1", 7) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "gshop_2", 7) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "bsmith_1", 8) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "bsmith_2", 8) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "wrhus_1", 7) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "wrhus_2", 7) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "gldhall_1", 9) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "gldhall_2", 9) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "wzdtwr_1", 8) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "wzdtwr_2", 8) == 0) return DEF_ELVINE ;

	if (memcmp(pMapName, "arefarm", 7) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "elvfarm", 7) == 0) return DEF_ELVINE ;
	
	if (memcmp(pMapName, "arewrhus", 8) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "elvwrhus", 8) == 0) return DEF_ELVINE ;
	
	if (memcmp(pMapName, "CmdHall_1", 9) == 0) return DEF_ARESDEN ;
	if (memcmp(pMapName, "CmdHall_2", 9) == 0)  return DEF_ELVINE ;


	return 0;
}

BOOL CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return FALSE;
	if (pCopy == NULL) return FALSE;
	
	pCopy->m_sIDnum = pOriginal->m_sIDnum;					// 아이템의 고유 번호 
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
	
	//short m_sSM_HitRatio, m_sL_HitRatio;
	//v1.432 명중률 가감 사용 안한다. 대신 특수 능력 수치가 들어간다.
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;	
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;
	
	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;			

	return TRUE;
}

void CGame::CrusadeWarStarter()
{
 SYSTEMTIME SysTime;
 int i;
	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsCrusadeWarStarter == FALSE) return;
    if (m_bIsApocalypseMode == TRUE) GlobalEndApocalypseMode();
	GetLocalTime(&SysTime);	
	for (i = 0; i < DEF_MAXSCHEDULE; i++)
	if (m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) {
		if ((m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) && 
            (m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			GlobalStartCrusadeMode();
			return;
		}
	}
}




void CGame::PartyOperationResult_Create(int iClientH, char *pName, int iResult, int iPartyID)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD * wp;
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0: // 파티 생성 실패 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 0, NULL, NULL);
		break;

	case 1: // 파티 생성 성공 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 1, NULL, NULL);

		// 게임 서버의 파티 리스트에 등록.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
			goto PORC_LOOPBREAK1;
		}
PORC_LOOPBREAK1:;

		// 만약 파티 가입을 신청한 플레이어가 있다면 
		if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != NULL) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != NULL)) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // 파티 멤버 추가 요청
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			// 메시지를 보냈으니 클리어
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::PartyOperationResult_Join(int iClientH, char *pName, int iResult, int iPartyID)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;
	
	switch (iResult) {
	case 0: // 파티 조인 실패 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
		
		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 0, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // 파티 조인 성공 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		// 게임 서버의 파티 리스트에 등록.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
			m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
			goto PORC_LOOPBREAK1;
		}
PORC_LOOPBREAK1:;

		// 다른 파티원들에게도 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((i != iClientH) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);
		}
		break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char *pName, int iResult, int iPartyID)
{
 int i;
	// iClientH는 이미 사라지고 없는 캐릭터일수도 있다.
		
	switch (iResult) {
	case 0: // 파티 탈퇴 실패 ? 이런 일이?
		break;

	case 1: // 파티 탈퇴 성공 
		if (iClientH == NULL) {
			// iClientH 가 NULL이면 서버 이동중 접속 종료되어 강제 제거 요청된 것임.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
				iClientH = i;
				goto PORD_LOOPBREAK;
			}
PORD_LOOPBREAK:;

		   // 게임 서버의 파티 리스트에서 해제.
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[iPartyID].iIndex[i] = 0;
				m_stPartyInfo[iPartyID].iTotalMembers--;
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:;
			// 리스트 인덱스의 빈공간을 제거한다.
			for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
			if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
				m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
				m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
			}
		
			if (m_pClientList[iClientH] != NULL) {
				m_pClientList[iClientH]->m_iPartyID = NULL;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			}

			// 모든 파티원들에게 알려준다.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
			}
			return;
		}

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != NULL) && (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		// 모든 파티원들에게 알려준다.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
		}

		// 게임 서버의 파티 리스트에서 해제.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
		if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
			m_stPartyInfo[iPartyID].iIndex[i] = 0;
			m_stPartyInfo[iPartyID].iTotalMembers--;

			goto PORC_LOOPBREAK2;
		}
PORC_LOOPBREAK2:;
		// 리스트 인덱스의 빈공간을 제거한다.
		for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
		if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
			m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
			m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
		}
		
		if (m_pClientList[iClientH] != NULL) {
			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		}
		break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
 int i;

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}
	
	// 파티 해산됨 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
		SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 2, 0, NULL, NULL);
		m_pClientList[i]->m_iPartyID = NULL;
		m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[i]->m_iReqJoinPartyClientH = NULL;
	}
}



void CGame::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cData[120], cName[12];
 class  CStrTok * pStrTok;
 DWORD * dwp;
 WORD  * wp;
 int i;

	// 파티 가입 여부를 묻고 있다.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0&&m_pClientList[iClientH]->m_iAdminUserLevel < 3) return; // v2.23 22/04/06 15:24 AdminSecurity 
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}
	else {
		delete pStrTok;
		return;
	}
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
		// 게이트 서버로 파티 멤버 가입을 신청한다.
		if ((m_pClientList[i]->m_iPartyID == NULL) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
			// 파티에 가입하고자 한 캐릭터가 파티 마스터가 아니다.
			delete pStrTok;
			return;
		}
		
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 3; // 파티 멤버 추가 요청
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_iPartyID;
		cp += 2;
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		delete pStrTok;
		return;
	}

	// 가입하고자 하는 파티 마스터가 현재 서버에 존재하지 않는다.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	delete pStrTok;
}

void CGame::RequestDismissPartyHandler(int iClientH)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 4; // 멤버 제거 요청
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 6; // 파티 정보 요청
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}


void CGame::PartyOperationResult_Info(int iClientH, char * pName, int iTotal, char *pNameList)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;
	
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
 char * cp, cData[120];
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 4; // 멤버 제거 요청
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		// 상태 변환
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
 char *cp, cData[120];
 DWORD * dwp;
 WORD * wp;
 int iH;

	if (m_pClientList[iClientH] == NULL) return;
	
	switch (iResult) {
	case 0: // 파티 가입 신청 거부되었음을 알려준다.
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == NULL) {
			// 가입을 신청했던 플레이어가 서버상에 없다.
			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			// 가입을 신청했던 플레이어가 서버상에 없다.
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			// 가입을 신청했던 플레이어의 상태가 변경되었다.
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			// 가입을 신청했던 그때 그 플레이어가 아니다.
			return;
		}

		SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);

		m_pClientList[iH]->m_iPartyID = NULL;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // 파티 가입 신청 승인
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != NULL)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// 가입을 신청했던 플레이어의 상태가 변경되었다.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// 가입을 신청했던 그때 그 플레이어가 아니다.
				return;
			}

			// 가입 처리 한다.
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // 파티 멤버 추가 요청
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// 가입을 신청했던 플레이어가 서버상에 없다.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// 가입을 신청했던 플레이어의 상태가 변경되었다.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// 가입을 신청했던 그때 그 플레이어가 아니다.
				return;
			}
			
			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) {
				// 신청 받은 플레이어가 아무런 파티에도 가입하고 있지 않다. 이 캐릭터를 파티 마스터로 신청한다.
				RequestCreatePartyHandler(iClientH);
			}
			else {
				// 처리 불가
			}
		}
		break;

	case 2: // 파티 가입 신청 취소
		// 이 메시지를 받기 전에 이미 파티에 가입되었다면 탈퇴 처리를 한다.
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			// 멤버 제거를 요청한다.
			RequestDismissPartyHandler(iClientH);
		}
		else {
			// 가입 신청 상태였던 값들을 초기화 한다.
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			// 신청했던 캐릭터가 접속을 끊은 상태라면 NULL일 수 있다.
			if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) && 
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
				// 신청했던 캐릭터의 파티 아이디와 상태는 건드리지 않는다.
				m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
			}

			m_pClientList[iClientH]->m_iPartyID = NULL;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::GetExp(int iClientH, int iExp, BOOL bIsAttackerOwn)
{
	double dV1, dV2, dV3;
	int i, iH, iUnitValue;
	DWORD dwTime = timeGetTime();
	int iTotalPartyMembers;
	int iStruckLevel;

	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (int)dV1;
	}
	else { //Lower exp
		if 
			((m_pClientList[iClientH]->m_iLevel >= 100) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0))) {
				iExp = (iExp*15) ;
			}
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0)) {
				iExp = (iExp*15) ;
			}
	}

	//nose pasa de lvl 
	iStruckLevel = m_pClientList[iClientH]->m_iLevel - DEF_PLAYERMAXLEVEL; // By Mkintosh
        if ((m_pClientList[iClientH]->m_iLevel > DEF_PLAYERMAXLEVEL) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
            m_pClientList[iClientH]->m_iLevel = DEF_PLAYERMAXLEVEL;
            m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (iStruckLevel*3);
        }
	//nose pasa de lvl//
	if (m_pClientList[iClientH]->m_iLevel == 200) iExp = (iExp*2) ;
	//Check for party status, else give exp to player
	//if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && 
	//	((dwTime - m_pClientList[iClientH]->m_dwLastActionTime) < 1000*60*5)) {
	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			//Only divide exp if > 1 person and exp > 10
			if(iExp >= 10 && m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0){

				//Calc total ppl in party
				iTotalPartyMembers = 0;
				for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++){
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0)) {
						//Newly added, Only players on same map get exp
						if(m_pClientList[iH]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
							iTotalPartyMembers++;
					}
				}

				//Check for party bug
				if(iTotalPartyMembers > 8){
					wsprintf(G_cTxt, "(X) Party Bug !! partyMember %d XXXXXXXXXX", iTotalPartyMembers);
					PutLogFileList(G_cTxt);
					iTotalPartyMembers = 8;
				}

				//Figure out how much exp a player gets
				dV1 = (double)iExp;

				switch(iTotalPartyMembers){
				case 1:
					dV2 = dV1;
					break;
				case 2:
					dV2 = (dV1 + (dV1 * 2.0e-2)) / 2.0;
					break;
				case 3:
					dV2 = (dV1 + (dV1 * 5.0e-2)) / 3.0;
					break;
				case 4:
					dV2 = (dV1 + (dV1 * 7.000000000000001e-2)) / 4.0;
					break;
				case 5:
					dV2 = (dV1 + (dV1 * 1.0e-1)) / 5.0;
					break;
				case 6:
					dV2 = (dV1 + (dV1 * 1.4e-1)) / 6.0;
					break;
				case 7:
					dV2 = (dV1 + (dV1 * 1.7e-1)) / 7.0;
					break;
				case 8:
					dV2 = (dV1 + (dV1 * 2.0e-1)) / 8.0;
					break;
				}

				dV3 = dV2 + 5.0e-1;
				iUnitValue = (int)dV3;

				//Divide exp among party members
				for(i = 0; i < iTotalPartyMembers; i++){
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					//Player who kills monster gets more exp
					if(iH == iClientH){
						if(m_pClientList[iH] != NULL){ // Is player alive ??
							//Exp gain based on lvl
							if((m_pClientList[iH]->m_iStatus & 0x10000) != 0) iUnitValue *= 3;
							MultiplicadorExp(iH, iUnitValue);
							}
					}
					else{
						//Other players get normal exp :P
						if((m_pClientList[iH] != NULL) && m_pClientList[iH]->m_iHP > 0)
							if(m_pClientList[iH]->m_bSkillUsingStatus[19] != 1)
								//Only players on same map get exp
								if(m_pClientList[iH]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
							    MultiplicadorExp(iH, iUnitValue);
								}
				}

				if (bIsAttackerOwn == TRUE)
					if(iTotalPartyMembers > 1)
						m_pClientList[iClientH]->m_iExpStock += (iUnitValue/10);
			}
			else{
				if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) iExp *= 3;
					
				MultiplicadorExp(iClientH, iExp);
			}
		}
		else{
			if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) iExp *= 3;
			MultiplicadorExp(iClientH, iExp);
		}
}

BOOL CGame::bSerchMaster(int iNpcH)
{
 int ix, iy, rX, rY;
 short sOwnerH, sMasterH;
 char cOwnerType;

	// 인덱스 iNpcH에 해당하는 NPC가 Master를 찾는다.
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;

	sMasterH = NULL;

	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		switch (cOwnerType) {
		case DEF_OWNERTYPE_NPC:
			if ((sOwnerH != iNpcH) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == m_pNpcList[iNpcH]->m_sType) &&
				(m_pNpcList[sOwnerH]->m_cMoveType == DEF_MOVETYPE_RANDOM)) {
				// 타입이 같고 랜덤하게 움직이고 있는 몹이 있었다면 
				m_pNpcList[sOwnerH]->m_bIsMaster = TRUE;
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
				m_pNpcList[iNpcH]->m_cFollowOwnerType = DEF_OWNERTYPE_NPC; 
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = sOwnerH;
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int i, iItemX,iItemY, iSoM, iSoX, iSomH, iSoxH, iCheckHeroCape, iValue1, iValue2; // v2.172
	DWORD dwTemp, dwSWEType, iValue;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;
	/////////////////////
	short *sp;
	WORD *wp;
	DWORD *dwp;
	char cData[512], *cp;
	/////////////////////

	if (m_pClientList[iClientH] == NULL) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
	if (HeroItemChecker(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum, 0, 0, 0) != 0) {
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
		}
		iCheckHeroCape = iUpgradeHeroCapeRequirements(iClientH, iItemIndex);
		if (iCheckHeroCape == 1) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_UPGRADEHEROCAPE, iItemIndex, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		}
		else {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		}
		return;
	}
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 717) && (iValue >= 7) && (iValue < 0)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
		return;
	}
	/////////////////////////////////////////
	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
			case 46: // Pendants are category 46
				 if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1) {
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
				 return; // Pendants are type 1
  }
  if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11) 
  { SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
   return; // Pendants are left finger or more
  }
  if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14) 
  { SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
   return; // Pendants are EffectType 14
  }
  switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) {
  default: // Other items are not upgradable
   SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
   return; // Pendants are EffectType 14

  case 16: // AngelicPandent(STR)
  case 17: // AngelicPandent(DEX)
  case 18: // AngelicPandent(INT)
  case 19: // AngelicPandent(MAG)
   if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
   { SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
    return;
   }
   if((iValue+m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3) >= 20)
   { SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
    return;
   }
   iValue2 = iValue+m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3;
   switch (iValue2) {
   case 0: sItemUpgrade = 10; break;
   case 1: sItemUpgrade = 11; break;
   case 2: sItemUpgrade = 13; break;
   case 3: sItemUpgrade = 16; break;
   case 4: sItemUpgrade = 20; break;
   case 5: sItemUpgrade = 25; break;
   case 6: sItemUpgrade = 31; break;
   case 7: sItemUpgrade = 38; break;
   case 8: sItemUpgrade = 46; break;
   case 9: sItemUpgrade = 55; break;
   case 10: sItemUpgrade = 57; break;
   case 11: sItemUpgrade = 59; break;
   case 12: sItemUpgrade = 61; break;
   case 13: sItemUpgrade = 63; break;
   case 14: sItemUpgrade = 65; break;
   case 15: sItemUpgrade = 67; break;
   case 16: sItemUpgrade = 69; break;
   case 17: sItemUpgrade = 71; break;
   case 18: sItemUpgrade = 73; break;
   case 19: sItemUpgrade = 75; break;
   default:
    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
    return;
    break;
   }
   if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
   { SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
    return; 
   }
  int iDicePTA = iDice(1,100);
  if(iDicePTA <= 70)
   {
	   m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
	   SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	   iValue1 = (iValue+m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3);
	   iValue1++;
	if (iValue1 <= 15){
       dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
       dwTemp = dwTemp & 0x0FFFFFFF;
       m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue1 << 28);
	} else if (iValue1 <= 20){ 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3++;
	} 	{
		ZeroMemory(cData, sizeof(cData));
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
		*wp  = DEF_NOTIFY_ITEMATTRIBUTECHANGEANGEL;

		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = (short)iItemIndex;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
		cp += 4;

		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3;
		cp += 2;
		m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 14);
	}
	
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);}
   else { 
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
   }     
   return;
   break;
  }
 break;
}
	if (iValue >= 15 || iValue < 0 ) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
		return;
	}
	///////////////////////////////////////
	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
case 1:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 703: // SangAhFlameberge
		case 709: // DarkKnightFlameberge
		case 718: // DarkKnightGreatSword
		case 727: // DarkKnightFlamebergW
		case 736: // SangAhGiantSword
		case 737: // DarkKnightGiantSword
		case 745: // BlackKnightTemple
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) { 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
					return;
				}
			}
			sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) { 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703)) { // SangAhFlameberge 
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 736) == FALSE) { // SangAhGiantSword 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else if ((iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 727))) { // DarkKnightFlameberge DarkKnightFlamebergW
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 737) == FALSE) { // DarkKnightGiantSword
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else if ((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 737)) { // DarkKnightGiantSword
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 745) == FALSE) { // BlackKnightTemple
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);				
			}
			else if ((iValue >=	12) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 745)) { // BlackKnightTemple 
				iValue += 2;
				if (iValue > 15) iValue = 15;
				if (iValue == 15) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = 9;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);				
			}
			else {
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);

				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			break;

		case 717: // DarkKnightRapier
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			sItemUpgrade = (iValue*(iValue+6)/8) + 2;
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))	{
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) { 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue++;
			if (iValue > 7) iValue = 7;
			dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
			dwTemp = dwTemp & 0x0FFFFFFF;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			break;

		case 2011: // DarkKnightHammer			
		case 2012: // DarkKnightBHammer			
		case 2013: // DarkKnightBBHammer			
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;
			
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

			
			
			if ((iValue >= 2) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 2011)) 
			{ // DarkKnightFlameberge
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , 2012) == FALSE) { // DarkKnightGiantSword
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			
			else if ((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 2012)) 
			{ // DarkKnightGiantSword
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 2013) == FALSE) { // BlackKnightTemple
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);				
			}


			else if ((iValue >=	14) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 2013))
			{ // BlackKnightTemple 
				iValue += 2;
				if (iValue > 15) iValue = 15;
				if (iValue == 15) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = 9;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);				
			}

			else 
			{
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
		break;
		
		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 9) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break;
				case 657: iSoM++; iSomH = i; break;
				}
			}
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 10)
					ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
					ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);	
					return;
				}
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
					iValue++;
					if (iValue > 15) {
						iValue = 15;
					}
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
					}
				}
				else {
					iValue++;
					if (iValue > 15) {
						iValue = 15;
					}
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
					}
				}
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		return;

	case 3:
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 9) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
			}
		}
		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 656: iSoX++; iSoxH = i; break;
			case 657: iSoM++; iSomH = i; break;
			}
		}
		if (iSoX > 0) {
			if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue >= 10) 
				ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
				ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);	
				return;
			}
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				iValue++;
				if (iValue > 15) {
					iValue = 15;
				}
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
				}
			}
			else {
				iValue++;
				if (iValue > 15) {
					iValue = 15;
				}
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
				}
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		return;

	case 5:
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 623:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
		default: 
			break;
		}
		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break;
				case 657: iSoM++; iSomH = i; break;
			}
		}
		if (iSoM > 0) {
			if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue >= 10) 
				ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
				ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
				return;
			}
			iValue++;
			if (iValue > 15) {
				iValue = 15;
			}
			else {
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.2f * dV1;
					dV3 = dV1 + dV2;
				}
				else {
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.15f * dV1;
					dV3 = dV1 + dV2;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan += dV2;
				ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
		return;
	
	case  6:
	case 15:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 621: // MerienPlateMailM
		case 622: // MerienPlateMailW 
		case 700: // SangAhHauberk 
		case 701: // SangAhFullHel
		case 702: // SangAhLeggings  
		case 704: // SangAhPlateMail 
		case 706: // DarkKnightHauberk
		case 707: // DarkKnightFullHelm 
		case 708: // DarkKnightLeggings  
		case 710: // DarkKnightPlateMail 
		case 711: // DarkMageHauberk 
		case 712: // DarkMageChainMail
		case 713: // DarkMageLeggings  
		case 716: // DarkMageLedderArmor
		case 719: // DarkMageScaleMail
		case 724: // DarkKnightHauberkW
		case 725: // DarkKnightFullHelmW 
		case 726: // DarkKnightLeggingsW 
		case 728: // DarkKnightPlateMailW 
		case 729: // DarkMageHauberkW 
		case 730: // DarkMageChainMailW 
		case 731: // DarkMageLeggingsW 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
				}
			}
			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 10) 
					ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
					ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
					return;
				}
				iValue++;
				if (iValue > 15) {
					iValue = 15;
				}
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan += dV2;
					ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);	
				}
			}
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
		return;

	case 8:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 291: // MagicWand(MS30-LLF) 
			case 714: // DarkMageMagicStaff 
			case 732: // DarkMageMagicStaffW 
			case 738: // DarkMageMagicWand
			case 746: // BlackMageTemple
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return; 
				}
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) { 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
					return; 
				}
				sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;
				if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) { 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
					return; 
				}
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
				if (iValue == 0 ) {
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				}
				if((iValue >= 4) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 732))) {
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 738) == FALSE) { // DarkMageMagicWand
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
					iValue += 2;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				} 
				if((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738)) {
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 746) == FALSE) { // BlackMageTemple 
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
					iValue += 2;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				} 
				if((iValue >= 12) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 746)) {
					iValue += 2;
					if (iValue > 15) iValue = 15;
					if (iValue == 15) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = 9;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				}
				else {
					iValue += 2;
					if (iValue > 15) iValue = 15; 
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // 쨘챰짰 짭쨍짰쩐챤 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 쩐첨짹쨌쨔쨉책쨉 쨘챰짰째짧 쨌
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				}

			default:
				// 쨔 쩐
				// v2.16 2002-5-21 째챠짹짚철쩌철짚
				iSoX = iSoM = 0;
				for (i = 0; i < DEF_MAXITEMS; i++)
					if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 656: iSoX++; iSoxH = i; break; // 쩍쨘챈 쩔쨘챗 짝쨍짰쨍쨋 
							case 657: iSoM++; iSomH = i; break; // 쩍쨘챈 쩔쨘챗 쨍쨍짰쩔짙 
						}
					}
					// 쩍쨘챈 쩔쨘챗 짝쨍짰쨍쨋째징 쨈.
					if (iSoX > 0) {
						// 쩐첨짹쨌쨔쨉책 쩌쨘째첩 짰쨌체 째챔쨩챗.
						if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
							// 쩐첨짹쨌쨔쨉책 쩍 
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
							if (iValue >= 10) 
							ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE); // v2.172 +1 -> +2 쨈째챔쩔징쩌짯 쩍쨍챕 쨩챌쨋처체 
							ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);	
							return;
						}

						iValue++;
						if (iValue > 15) 
							iValue = 15;
						else {
							// 쩐첨짹쨌쨔쨉책 쩌쨘째첩. 쩐 짱쩌쨘 쨔짼째챠
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF; // 쨘챰짰 짭쨍짰쩐챤 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // 쩐첨짹쨌쨔쨉책쨉 쨘챰짰째짧 쨌	
							// 쩍쨘챈 쩔쨘챗 짝쨍짰쨍쨋 쩐첩쩐쨈.
							ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
						}
					}

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);

					break;
		}
		break;

	default:
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
	}
}
// v2.16 2002-5-21 고광현 추가
BOOL CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, BOOL bBonus)
{
 int iValue, iProb, iResult;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return FALSE;
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 99; break;  // +1 :90%     +1~+2(제작 아이템 완성도 200%일때 보너스 성공률 +10%)
	case 1: iProb = 99; break;  // +2 :80%      +3
	case 2: iProb = 99; break;  // +3 :48%      +4 
	case 3: iProb =  35; break;  // +4 :24%      +5
	case 4: iProb =  30; break;  // +5 :9.6%     +6
	case 5: iProb =  20; break;  // +6 :2.8%     +7
	case 6: iProb =  10; break;  // +7 :0.57%    +8
	case 7: iProb =  5; break;  // +8 :0.05%    +9
	case 8: iProb =  3; break;  // +9 :0.004%   +10
	case 9: iProb =  2; break;  // +10:0.00016%
	default: iProb = 0; break;
	}
	
	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {	
		// 제작된 무기라면 성공 확률 ItemSpecialEffectValue2가 100이상일때 증가된다. 최대 10%
		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus == TRUE) iProb *=2 ;

	iProb *= 100;
	iResult = iDice(1,10000);

	if (iProb >= iResult) { 
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return TRUE;
	}

	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return FALSE;
}

void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
	int iTemp;

	if (m_pClientList[iAttackerH] == NULL) return;
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
	 if (m_pClientList[iTargetH] == NULL) return;
	 break;

	case DEF_OWNERTYPE_NPC: return;
	default: return;
	}

	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return;

	if (m_pClientList[iTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) return;

	switch (iDice(1,13)) {

case 1: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	   m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
		}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 50) m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
		
break;
}
case 2: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)){
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
		}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
break;
		}
case 3:{
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	   m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
break;
	   }
case 4:{
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	   m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
	   }
case 5: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	   m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 6: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	   m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50;
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 7: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	   m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	 m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 8: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	 m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 9: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 10: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 11: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	 m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 12: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	 m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
case 13: {
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
	 m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {


	 if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
		 m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 50; 
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
}
	 if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
	  m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
	  SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
	  ReleaseItemHandler(iTargetH, iTemp, TRUE);  
	 }
	}
	break;
		}
}
}
// v2.171 2002-6-14
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == NULL) {
		// 요청 받은 Object가 없다.
		
	}
	else {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);
	}
}

//v2.171
BOOL CGame::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;

		if (dwTimeGap < 250) {
			wsprintf(G_cTxt, "(!) Speed hack suspectA(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(G_cTxt);
			PutHackLog(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}

	}

	return FALSE;
}


// v2.171
BOOL CGame::bCheckClientMagicFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if (dwTimeGap < 1500) {
			wsprintf(G_cTxt, "(!) Speed hack suspectM(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(G_cTxt);
			PutHackLog(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}

	}

	return FALSE;
}

// v2.171
BOOL CGame::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMoveFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
			return FALSE;
		}

		// v2.172 Tab키 연타로 인한 튕김을 막기 위함
		if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
			return FALSE;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;

		if (dwTimeGap < 250) {
			wsprintf(G_cTxt, "(!) Speed hack suspectMO(%s)", m_pClientList[iClientH]->m_cCharName);
			PutLogList(G_cTxt);
			PutHackLog(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}

	}

	return FALSE;
}

void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0 ;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return ;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {


		if (m_sForceRecallTime > 0 ) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sForceRecallTime ;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			// v2.19 2002-11-28
#ifndef DEF_CONSULTATION
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //월요일  1 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //화요일  1 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //수요일  1 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*3 ; break;  //목요일  1분 
#else 
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //월요일  1 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //화요일  1 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //수요일  1 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*1 ; break;  //목요일  1분 

#endif 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*15; break; //금요일 15분
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*45; break; //토요일 45분 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //일요일 60분
			}
		}
	}
	else { // if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
		if (m_sForceRecallTime > 0 ) {
			iTL_ =  20*m_sForceRecallTime ;
		}
		else {

			// 잔존시간이 있다. 요일별 잔존시간보다 크면 1로 초기화 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20*1; break;  //월요일  1분 2002-09-10 #1
			case 2:	iTL_ = 20*1; break;  //화요일  1분
			case 3:	iTL_ = 20*1; break;  //수요일  1분
			case 4:	iTL_ = 20*1; break;  //목요일  1분
			case 5:	iTL_ = 20*15; break; //금요일 15분
			case 6:	iTL_ = 20*45; break; //토요일 45분 
			case 0:	iTL_ = 20*60; break; //일요일 60분
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;

	}

	return ;
}

// 2002-11-14 사냥꾼 모드 추가
void CGame::RequestHuntmode(int iClientH)
{
#ifndef DEF_V219
	return;
#endif

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0 ) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE ) return;
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall",8) != 0) return ;
	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == FALSE) ) return;


	if( memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "arehunter" );
	}
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0 ) 
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "elvhunter" );
	}
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "aresden" );
	}	
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "elvine" );
	}

	if (m_pClientList[iClientH]->m_bIsHunter == TRUE)
		m_pClientList[iClientH]->m_bIsHunter = FALSE ;
	else 
		m_pClientList[iClientH]->m_bIsHunter = TRUE ;


	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_HUNTMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);

	// 특성이 바뀌므로 외양을 새로 보낸다. 
	SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::SetNoHunterMode(int iClientH,BOOL bSendMsg) 	// v2.20 2002-12-31 민간인 모드 레벨 제한 과 이동지역 제한 추가 
{
#ifndef DEF_V219
	return;
#endif

	if (m_pClientList[iClientH] == NULL) return;

	if( memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "aresden" );
	}	
	else if( memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0 )
	{
		strcpy( m_pClientList[iClientH]->m_cLocation, "elvine" );
	}

	if (m_pClientList[iClientH]->m_bIsHunter == TRUE)
		m_pClientList[iClientH]->m_bIsHunter = FALSE ;

	if (bSendMsg == TRUE)
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_HUNTMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);

		// 특성이 바뀌므로 외양을 새로 보낸다. 
		SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	}

}

int CGame::iSetSide(int iClientH)
{
	if ( m_pClientList[iClientH] == NULL ) return -1;

	char	cLocationName[12], cMapLocationName[12];

	ZeroMemory(cLocationName, sizeof(cLocationName));
	ZeroMemory(cMapLocationName, sizeof(cMapLocationName));

	strcpy(cLocationName, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapLocationName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);


	// 플레이어의 소속에 따라 Side를 결정한다. 여행자라면 0을 유지하고 Aresden이면 1, Elvine이면 2를 할당한다.
	// v2.181 2002-10-24 중립 공격 받는 버그 수정
	m_pClientList[iClientH]->m_cSide = DEF_NETURAL ; // v2.172
	m_pClientList[iClientH]->m_iIsOnTown = DEF_PK;
	m_pClientList[iClientH]->m_bIsHunter = FALSE;

	// v2.17 2002-7-21 마을과 농경지에서만 같은 편에게 공격 받지 않게 설정함 
	// v2.19 2002-11-12 캐릭터끼리 공격 불가능한 지역 설정 (aresden으로 설정된 모든 부분..m_cLocationName)
	
	// are[sden], are[hunter] 와 같이 앞의 3글자가 일반 모드와 사냥꾼 모드가 같다는 것을 이용
	if (memcmp(cLocationName,cMapLocationName,3) == 0)
		m_pClientList[iClientH]->m_iIsOnTown = DEF_NONPK;

	if (memcmp(cLocationName, "are", 3) == 0) {
		m_pClientList[iClientH]->m_cSide = DEF_ARESDEN;
	} else if (memcmp(cLocationName, "elv", 3) == 0) {
		m_pClientList[iClientH]->m_cSide = DEF_ELVINE;
	}
    else {
		if ((strcmp(cMapLocationName, "elvine") == 0)
			|| (strcmp(cMapLocationName, "aresden") == 0))
		{
			m_pClientList[iClientH]->m_iIsOnTown = DEF_NONPK;
		}
		m_pClientList[iClientH]->m_bIsNeutral = TRUE ;
	}

#ifdef DEF_V219
	if ((memcmp(cLocationName, "arehunter", 9) == 0)  ||  (memcmp(cLocationName, "elvhunter", 9) == 0)) {
		m_pClientList[iClientH]->m_bIsHunter = TRUE ;
	}
#endif
	
	// 불리딩에서는 민간인 모드가 활성화 되지 않는다.
	if((memcmp(m_pClientList[iClientH]->m_cMapName, "bisle",5) == 0))
	{
		m_pClientList[iClientH]->m_bIsHunter = FALSE ;
	}

	if((memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith",6) == 0) ||
		#ifdef DEF_HIGH
		(memcmp(m_pClientList[iClientH]->m_cMapName, "FenixVip",8) == 0) ||
        #endif
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall",7) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "Whouse",6) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gshop",5) == 0) )
		m_pClientList[iClientH]->m_bIsOnShop = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnShop = FALSE;

	if((memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus",5) == 0) 
		|| (memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus",8) == 0)
		|| (memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus",8) == 0)
		)
		m_pClientList[iClientH]->m_bIsOnWarehouse = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnWarehouse = TRUE;

	// v2.20 2002-12-23 마법을 배울수 있는곳인지 체크 한다.
	if(memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr",6) == 0 )
		m_pClientList[iClientH]->m_bIsOnTower = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnTower = TRUE;
		
	// v3.2
	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "2ndmiddle", 9) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "abaddon", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "aresdend", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "areuni", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "druncncity", 10) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "elvined", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "elvuni", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "huntzone", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "icebound", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "infernia", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "maze", 4) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "middle", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "procella", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "toh", 3) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "Isla", 4) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "Extreme", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "PVP", 3) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "MBarracks", 9) == 0))
			m_pClientList[iClientH]->m_bIsOnCombatantZone = TRUE;
	else
		m_pClientList[iClientH]->m_bIsOnCombatantZone = FALSE;

#ifdef DEF_ALLPLAYERPROTECT
	// v2.19 2002-11-12 캐릭터끼리 공격 불가능한 지역 설정 마을과 같은 룰이 적용된다.
	if(memcmp(cMapLocationName, "2ndmiddle",9)== 0)
	{
		m_pClientList[iClientH]->m_iIsOnTown = DEF_NEVERNONPK;
	}
#endif

	return m_pClientList[iClientH]->m_cSide;
}


//v2.19 2002-12-16 농사스킬..
BOOL CGame::__bSetAgricultureItem(int iMapIndex, int dX, int dY, int iType,int iSsn, int iClientH)  
{
 int iNamingValue, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;
 BOOL	iRet;


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= DEF_MAXAGRICULTURE) {

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	if(iSsn > m_pClientList[iClientH]->m_cSkillMastery[2]) //쓸수가 없다.. 스킬 제한에 걸린다..
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);  //??
		return FALSE;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
	}
	else {

	
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5))
		{
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
			return FALSE;
		}
// 		}

		//농사를 지을수 있는 자리가 아니다.
		if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX,dY) == FALSE)
		{
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
			return FALSE;
		}
		// NPC를 생성한다.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Crops");
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		
		iRet = bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, FALSE, 0 /*중립*/, FALSE, TRUE);

		if ( iRet == FALSE) {
			
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
		
			if(m_pNpcList[iRet] == NULL)
			{
				return FALSE;
			}
			
			m_pNpcList[iRet]->m_iNpcCrops = iType;
			
			// 이렇게 할필요가 없지만..
			switch (iType) 
			{
			case 1: //WaterMelon
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 2: //Pumpkin
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 3: //Garlic
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 4: //Barley
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 5: //Carrot
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 6: //Radish
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 7: //Corn
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 8: //CBellflower
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 9: //Melone
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 10: //Tommato
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 11: //Grapes
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 12: //BlueGrapes
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 13: //Mushroom
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			case 14: //Ginseng
				m_pNpcList[iRet]->m_iCropsSkillLV = iSsn;
				break;
			default: //없는 작물...
				m_pNpcList[iRet]->m_iCropsSkillLV = 100;
				break;
			}

			m_pNpcList[iRet]->m_sAppr2 = iType << 8 | 1;

			SendEventToNearClient_TypeA(iRet, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

			// 성공
			wsprintf(G_cTxt, "plant(%s) Agriculture begin(%d,%d) sum(%d)!", cNpcName, tX, tY,
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
			PutLogList(G_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CGame::bCropsItemDrop(int iClientH, short iTargetH,BOOL bMobDropPos)  
{
	class CItem * pItem;
	int	  iItemID = 0 ;
	int	  iSeedID = 0 ;

	iSeedID = m_pNpcList[iTargetH]->m_iNpcCrops;

	switch (iSeedID) 
	{
	case 1: //WaterMelon
		iItemID = 820;
		GetExp(iClientH, iDice(3, 10));
		break;
	case 2: //Pumpkin
		iItemID = 821;
		GetExp(iClientH, iDice(3, 10));
		break;
	case 3: //Garlic
		iItemID = 822;
		GetExp(iClientH, iDice(4, 10));
		break;
	case 4: //Barley
		iItemID = 823;
		GetExp(iClientH, iDice(4, 10));
		break;
	case 5: //Carrot
		iItemID = 824;
		GetExp(iClientH, iDice(5, 10));
		break;
	case 6: //Radish
		iItemID = 825;
		GetExp(iClientH, iDice(5,10));
		break;
	case 7: //Corn
		iItemID = 826;
		GetExp(iClientH, iDice(6,10));
		break;
	case 8: //CBellflower
		iItemID = 827;
		GetExp(iClientH, iDice(6,10));
		break;
	case 9: //Melone
		iItemID = 828;
		GetExp(iClientH, iDice(7,10));
		break;
	case 10: //Tommato
		iItemID = 829;
		GetExp(iClientH, iDice(7,10));
		break;
	case 11: //Grapes
		iItemID = 830;
		GetExp(iClientH, iDice(8,10));
		break;
	case 12: //BlueGrapes
		iItemID = 831;
		GetExp(iClientH, iDice(8,10));
		break;
	case 13: //Mushroom
		iItemID = 832;
		GetExp(iClientH, iDice(9,10));
		break;
	case 14: //Ginseng
		iItemID = 721;
		GetExp(iClientH, iDice(10,10));
		break;
	default:
		iItemID = 0;
		break;
	}

	
	if(iItemID == 0) return FALSE;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
		return FALSE;
	}
	else {
		
		if( bMobDropPos == FALSE)
		{
			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
		}
		else
		{
			//농작물 위에 버린다.
			m_pMapList[ m_pNpcList[iTargetH]->m_cMapIndex ]->bSetItem(m_pNpcList[iTargetH]->m_sX, 
				m_pNpcList[iTargetH]->m_sY, 
				pItem);
			
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iTargetH]->m_cMapIndex,
				m_pNpcList[iTargetH]->m_sX, m_pNpcList[iTargetH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
			
		}


	}

	return TRUE;
}

//v2.19 2002-12-16 스킬 레벨과 농작물 레벨에 따른 타격 성공 확률
int SKILLCROPSTABLE[9][9] = 
// 20  30  40  50  60  70  80  90 100
{
   42, 34, 27, 21, 16, 12,  9,  7,  6,  //20
   43, 40, 33, 27, 22, 18, 15, 13, 10,	//30
   44, 41, 38, 32, 27, 23, 20, 18, 13,  //40
   45, 42, 39, 36, 31, 27, 24, 22, 15,  //50
   46, 43, 40, 37, 34, 30, 27, 25, 16,  //60
   47, 44, 41, 38, 35, 32, 29, 27, 20,  //70
   48, 45, 42, 39, 36, 33, 30, 28, 23,  //80
   49, 46, 43, 40, 37, 34, 31, 28, 25,  //90
   50, 47, 44, 41, 38, 35, 32, 29, 26  //100
};

//v2.19 2002-12-16 스킬 레벨과 농작물 레벨에 따른 농작물 드롭 확률
int CROPSDROPTABLE[9][9] = 
// 20  30  40  50  60  70  80  90 100
{
   40,  0,  0,  0,  0,  0,  0,  0,  0,  //20
   41, 38,  0,  0,  0,  0,  0,  0,  0,	//30
   43, 40, 36,  0,  0,  0,  0,  0,  0,  //40
   46, 42, 38, 35,  0,  0,  0,  0,  0,  //50
   50, 45, 41, 37, 33,  0,  0,  0,  0,  //60
   55, 49, 44, 40, 35, 31,  0,  0,  0,  //70
   61, 54, 48, 43, 38, 33, 30,  0,  0,  //80
   68, 60, 53, 47, 42, 37, 32, 28,  0,  //90
   76, 67, 59, 52, 46, 41, 35, 29, 24  //100
};

int CGame::bProbabilityTable(int x,int y,int iTable) 
{
	int iProb;
	int iX,iY;

	iX = (x - 20) / 10;
	iY = (y - 20) / 10;
	
	if( iX < 0 || iX > 8) return 0;
	if( iY < 0 || iY > 8) return 0;

	iProb = iDice(1,100);

	if(iTable == 1){
		if( SKILLCROPSTABLE[iX][iY] >= iProb )
			return SKILLCROPSTABLE[iX][iY];
		else
			return 0;
	}
	else if(iTable == 2){
		if( CROPSDROPTABLE[iX][iY] >= iProb )
			return CROPSDROPTABLE[iX][iY];
		else
			return 0;
	}
	else return 0;
}


// v2.23 18/02/06 17:52 
int CGame::CheckHeroItemEquipHandler(int iClientH)
{
	short sLeggings, sHauberk, sHelm, sArmor;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	
	sLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	sHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	sArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	sHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	
	if ((sLeggings < 0) || (sHauberk < 0) || (sArmor < 0) || (sHelm < 0)) return 0;
	
	if (m_pClientList[iClientH]->m_pItemList[sLeggings] == NULL) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHauberk] == NULL) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sArmor] == NULL) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHelm] == NULL) return 0;
	
	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 403) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 411) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 423)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 407) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 415) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 423)) return 2;
	
	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 404) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 412) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 424)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 408) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 416) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 424)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 405) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 413) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 425)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 409) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 417) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 425)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 406) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 414) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 426)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 410) &&
		(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 418) &&
		(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 426)) return 2;
		
	return 0;
}



int ITEMSPREAD_FIEXD_COORD [25][2] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};

BOOL CGame::bGetMultipleItemNamesWhenDeleteNpc(short sNpcType, int iProbability, int iMin, int iMax, short sBaseX, short sBaseY,
											   int iItemSpreadType, int iSpreadRange,
											   int *iItemIDs, POINT *BasePos, int *iNumItem)
{
	int		iProb = 100;
	float	fProb, fProbA, fProbB, fProbC;
	int		iItemID;
	int		iNum = 0;
	int iResult;

	//PutLogProcessList("PROCESS #355");

	
	for(int i=0; i<iMax; i++ )
	{

		if( i>iMin ) iProb = iProbability;

		fProb = (float)(100 - iProb) / 10.0;	//Wyvern?? ?챵짹? 50
		if( fProb < 1.0 ) fProb = 1.0;

		fProbA = fProbB = fProbC = fProb;

		fProbA = fProbA * 8.0f;
		fProbB = fProbB * 4.0f;
		fProbC = fProbC;

		iItemID = 0;

		switch(sNpcType)
		{
		case 66: // Wyvern...stupid koreans
		case 73: // Fire-Wyvern
			// 쨩처짹


		iResult = iDice(1,3000);
		if 	((iResult >= 1) && (iResult <=  50))	iItemID = 300;	// "MagicNecklace(RM10)"	5%
		else if ((iResult > 50) && (iResult <=  100))	iItemID = 259 ;	// "MagicWand(M.Shield)"	5%10
		else if ((iResult > 100) && (iResult <= 150))	iItemID = 311 ;	// "MagicNecklace(DF+10)"	5%15
		else if ((iResult > 150) && (iResult <= 200))	iItemID = 308 ;	// "MagicNecklace(MS10)"	5%20
		else if ((iResult > 200) && (iResult <= 250))	iItemID = 305 ;	// "MagicNecklace(DM+1)"	5%25
		else if ((iResult > 250) && (iResult <= 300))	iItemID = 3012;	// "RepPotion+1"			5%30
		else if ((iResult > 300) && (iResult <= 350))	iItemID = 3013;	// "RepPotion+3"		5%35

		else if ((iResult > 350) && (iResult <= 400))  iItemID = 636 ;  // "RingofGrandMage"		5%40
		else if ((iResult > 400) && (iResult <= 450))  iItemID = 735 ;  // "RingofDragonPower"		5%45

	//	else if ((iResult > 450) && (iResult <= 460))	iItemID = 3011;	// "RepPotionRestore"		1%46
	//	else if ((iResult > 460) && (iResult <= 610))	iItemID = 3014;	// "RepPotion+5"		15%61
	//	else if ((iResult > 610) && (iResult <= 710))	iItemID = 3015;	// "RepPotion+7"		10%71
	//	else if ((iResult > 710) && (iResult <= 810))	iItemID = 361 ;	// "Dye(CrimsonRed)"		10%81
	//	else if ((iResult > 810) && (iResult <= 900))	iItemID = 363 ;	// "Dye(Gold)"		9%90
		//else if ((iResult > 900) && (iResult <= 1000))	iItemID = 616 ;	// "DarkExecutor"	6%96

	//	else if ((iResult > 1000) && (iResult <= 1020))  iItemID = 2097 ;  // "ArmorDye(blue)        "		2% acalablade
	//	else if ((iResult > 1020) && (iResult <= 1040))  iItemID = 2095 ;  // "ArmorDye(Pink)"		2%
	//	else if ((iResult > 1040) && (iResult <= 1060))  iItemID = 2092 ;  // "ArmorDye(CrimsonRed)"		2%
	//	else if ((iResult > 1060) && (iResult <= 1080))  iItemID = 2093 ;  // "ArmorDye(Gold) "		2%
	//	else if ((iResult > 1080) && (iResult <= 1100))  iItemID = 374 ;  // "Dye(black)"		2%

		else if ((iResult > 2000) && (iResult <= 2010))  iItemID = 381 ;  // "MassFireStrikeManual"		2%
		else if ((iResult > 5000) && (iResult <= 5010))  iItemID = 612  ;  // "XelimaRapier   "		2%
		//FIXED


			if( iItemID == 0 )
			{
				switch( iDice(1,8) ) 
				{	
					case 1:
						switch( iDice(1,4) ) 
						{	
							case  1: iItemID = 868; break; // AcientTablet(1)
							case  2: iItemID = 869; break; // AcientTablet(2)
							case  3: iItemID = 870; break; // AcientTablet(3)
							case  4: iItemID = 871; break; // AcientTablet(4)
						}

					case  2: iItemID = 650; break; // ZemstoneOfSacrifice
					case  3: iItemID = 656; break; // StoneOfXelima
					case  4: iItemID = 657; break; // StoneOfMerien
				}
			}
		break; 

		case 81: //Abaddon drop
		
		iResult = iDice(1,2000);
		if 	((iResult >= 1) && (iResult <=  50))	iItemID = 631;	// " war ring"	5%
		else if ((iResult > 50) && (iResult <=  100))	iItemID = 630 ;	// "war neck"	5%10
		else if ((iResult > 100) && (iResult <= 150))	iItemID = 636;	// "mage ring"		5%15
		else if ((iResult > 150) && (iResult <= 200))	iItemID = 858;	// "mage neck"		5%20
		else if ((iResult > 200) && (iResult <= 250))	iItemID = 1601;	// "maj balls +500"		5%25
		else if ((iResult > 250) && (iResult <= 300))	iItemID = 1501;	// "rep balls +300"			5%30
		else if ((iResult > 300) && (iResult <= 350))	iItemID = 3016;	// "contrib balls +700"		5%35

		else if ((iResult > 350) && (iResult <= 400))  iItemID = 1508 ;  // "ek balls 300"		5%40
	//	else if ((iResult > 400) && (iResult <= 450))  iItemID = 4965 ;  // "power ring mage"		5%45

	//	else if ((iResult > 450) && (iResult <= 460))	iItemID = 4964;	// "power ring war"		1%46
	//	else if ((iResult > 460) && (iResult <= 610))	iItemID = 4967;	// "power neck mage"		15%61
	//	else if ((iResult > 610) && (iResult <= 710))	iItemID = 4968;	// "power neck war"
		else if ((iResult > 710) && (iResult <= 810))	iItemID = 4966 ;	// "neck power ms"		10%81
		else if ((iResult > 810) && (iResult <= 900))	iItemID = 1505 ;	// "merien stone"		9%90
		else if ((iResult > 900) && (iResult <= 960))	iItemID = 3081 ;	// "xelima stone"	6%96
		else if ((iResult > 600) && (iResult <= 900))  iItemID = 850 ;  // "KlonessAxe"		2%
		else if ((iResult > 560) && (iResult <= 900))  iItemID = 4986 ;  // "FastNpcKillHammer"		2%
		else if ((iResult > 460) && (iResult <= 920))  iItemID = 291 ;  // "MagicWand(MS30-LLF)"		2% 
		//FIXED

			if( iItemID == 0 )
			{
				switch( iDice(1,6) ) 
				{	
					case 1:
						switch( iDice(1,4) ) 
						{	
							case  1: iItemID = 868; break; // AcientTablet(1)
							case  2: iItemID = 869; break; // AcientTablet(2)
							case  3: iItemID = 870; break; // AcientTablet(3)
							case  4: iItemID = 871; break; // AcientTablet(4)
						}

					case  2: iItemID = 650; break; // ZemstoneOfSacrifice
					case  3: iItemID = 656; break; // StoneOfXelima
					case  4: iItemID = 657; break; // StoneOfMerien
				}
			}


		break;
	}


		// 짰쨌체 100 쨉짜 쩐쨔짬 째쨉쨉 쨀짧쩔철 쩐쩐쨈.
		// Gold 쨈. retarded koreans -_-
		if( iItemID == 0) iItemID = 90; // Gold

		if( iItemID != 0 )
		{
			// item id
			iItemIDs[iNum] = iItemID;

			// item position
			switch(iItemSpreadType)
			{
			case DEF_ITEMSPREAD_RANDOM:
				BasePos[iNum].x = sBaseX + iSpreadRange - iDice(1, iSpreadRange * 2 );
				BasePos[iNum].y = sBaseY + iSpreadRange - iDice(1, iSpreadRange * 2 );
				break;

			case DEF_ITEMSPREAD_FIXED:
				BasePos[iNum].x = sBaseX + ITEMSPREAD_FIEXD_COORD[iNum][0];
				BasePos[iNum].y = sBaseY + ITEMSPREAD_FIEXD_COORD[iNum][1];
				break;
			}
			iNum++;
		}

	} // for

	*iNumItem = iNum;

	return TRUE;

} // bGetMultipleItemNamesWhenDeleteNpc... duh...korean morons

// Change Set. 11/04/06 17:01 
// Sirve para cambiar los stats con majestics points
void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cStateChange1, cStateChange2, cStateChange3;
 char cStr, cVit, cDex, cInt, cMag, cChar;
 int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
 int iRestHP;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;
	
	cStr = cVit = cDex = cInt = cMag = cChar = 0;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStateChange1 = *cp;
	cp++;

	cStateChange2 = *cp;
	cp++;

	cStateChange3 = *cp;
	cp++;

	iOldStr	= m_pClientList[iClientH]->m_iStr;
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;
	
	if (!bChangeState(cStateChange1,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if (!bChangeState(cStateChange2,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if (!bChangeState(cStateChange3,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iGuildRank == 0) {
		if (m_pClientList[iClientH]->m_iCharisma - cChar < 20) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
	}

	if (iOldStr + iOldVit	+ iOldDex + iOldInt + iOldMag + iOldChar != ((DEF_PLAYERMAXLEVEL-1)*3 + 70)) {
		return;
	}

	if ((cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0) || 
			(cStr + cVit + cDex + cInt + cMag + cChar != 3)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	
	if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT) 
			|| (m_pClientList[iClientH]->m_iStr - cStr < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	
	if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iDex - cDex < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}	

	if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iInt - cInt < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iMag - cMag < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
		 || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	
	m_pClientList[iClientH]->m_iLU_Pool += 3;

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
	
	m_pClientList[iClientH]->m_iStr -= cStr;
	m_pClientList[iClientH]->m_iVit -= cVit;
	m_pClientList[iClientH]->m_iDex -= cDex;
	m_pClientList[iClientH]->m_iInt -= cInt;
	m_pClientList[iClientH]->m_iMag  -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;
	AutoSkill(iClientH);
	
	if (cInt > 0) {
		bCheckMagicInt(iClientH);
	}

	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) {
		iRestHP = m_pClientList[iClientH]->m_iHP - iGetMaxHP(iClientH);
		m_pClientList[iClientH]->m_iHP -= iRestHP;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}
	
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
}

BOOL CGame::bCheckMagicInt(int iClientH)
{

	for(int i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if(m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->m_iInt)
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
		}
	}

	return TRUE;
}

BOOL CGame::bChangeState(char cStateChange, char *cStr, char *cVit, char *cDex, char *cInt, char *cMag, char *cChar)
{
	
	if (cStateChange == DEF_STR) {
		*cStr += 1;
	}
	else if (cStateChange == DEF_VIT) {
		*cVit += 1;
	}
	else if (cStateChange == DEF_DEX) {
		*cDex += 1;
	}
	else if (cStateChange == DEF_INT) {
		*cInt += 1;
	}
	else if (cStateChange == DEF_MAG) {
		*cMag += 1;
	}
	else if (cStateChange == DEF_CHR) {
		*cChar += 1;
	}
	else {
		return 0;
	}
	
	return cStateChange;
}

int CGame::HeroItemChecker(int iItemID, short sEnemyKill, char cContribution, char cSide)
{
	switch(iItemID) {

	case 400: // AresdenHeroCape 
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 0;  
		if (cSide != 0) cSide = 1; 
		break;

	case 401: // ElvineHeroCape 
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 0;  
		if (cSide != 0) cSide = 2; 
		break;

	// eHeroHelm
	case 403: // aHeroHelm(M)
	case 404: // aHeroHelm(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 1; 
		break;
	case 405: // aHeroHelm(M)
	case 406: // aHeroHelm(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 2; 
		break;

	// eHeroCap
	case 407: // aHeroCap(M)
	case 408: // aHeroCap(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 1; 
		break;
	case 409: // aHeroCap(M)
	case 410: // aHeroCap(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 2; 
		break;

	// eHeroArmor
	case 411: // eHeroArmor(M)
	case 412: // eHeroArmor(W)
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 30; 
		if (cSide != 0) cSide = 1; 
		break;
	case 413: // eHeroArmor(M)
	case 414: // eHeroArmor(W)
		if (sEnemyKill != 0) sEnemyKill = 300; 
		if (cContribution != 0) cContribution = 30; 
		if (cSide != 0) cSide = 2; 
		break;

	// aHeroRobe
	case 415: // aHeroRobe(M)
	case 416: // aHeroRobe(W)
		if (sEnemyKill != 0) sEnemyKill = 200; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 1; 
		break;
	case 417: // aHeroRobe(M)
	case 418: // aHeroRobe(W)
		if (sEnemyKill != 0) sEnemyKill = 200; 
		if (cContribution != 0) cContribution = 20; 
		if (cSide != 0) cSide = 2; 
		break;

	// aHeroHauberk
	case 419: // aHeroHauberk(M)
	case 420: // aHeroHauberk(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 10; 
		if (cSide != 0) cSide = 1; 
		break;
	case 421: // eHeroHauberk(M)
	case 422: // eHeroHauberk(W)
		if (sEnemyKill != 0) sEnemyKill = 100; 
		if (cContribution != 0) cContribution = 10; 
		if (cSide != 0) cSide = 2; break;

	// aHeroLeggings
	case 423: // aHeroLeggings(M)
	case 424: // aHeroLeggings(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 15; 
		if (cSide != 0) cSide = 1; 
		break;
	case 425: // eHeroLeggings(M)
	case 426: // eHeroLeggings(W)
		if (sEnemyKill != 0) sEnemyKill = 150; 
		if (cContribution != 0) cContribution = 15; 
		if (cSide != 0) cSide = 2; 
		break;
	
	case 427: // AresdenHeroCape+1 
		if (cSide != 0) cSide = 1; 
		break;

	case 428: // ElvineHeroCape+1
		if (cSide != 0) cSide = 2; 
		break;

	default: 
		return 0;
	}
	return iItemID;

}

int CGame::iUpgradeHeroCapeRequirements(int iClientH, int iItemIndex)
{
 int iViejoItemID, iNuevoItemID, iRequiredEnemyKills, iRequiredContribution, iStoneNumber, i;
	
	iViejoItemID = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum;
	if (iViejoItemID == 400) {
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		iNuevoItemID = 427;
		iRequiredEnemyKills = 30;
		iRequiredContribution = 50;
		iStoneNumber = 657;
	}
	else if (iViejoItemID == 401) {
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
		iNuevoItemID = 428;
		iRequiredEnemyKills = 30;
		iRequiredContribution = 50;
		iStoneNumber = 657;
	}
	else {
		return 0;
	}
	if ((m_pClientList[iClientH]->m_iEnemyKillCount < iRequiredEnemyKills)||(m_pClientList[iClientH]->m_iContribution < iRequiredContribution)) return 0;
	for (i = 0; i < DEF_MAXITEMS; i++) {
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == iStoneNumber)) break;
	}
	if (i == 50) return 0;
	if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], iNuevoItemID) == FALSE) return 0;
	else {
	m_pClientList[iClientH]->m_iEnemyKillCount -= iRequiredEnemyKills;
	m_pClientList[iClientH]->m_iContribution -= iRequiredContribution;
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) ItemDepleteHandler(iClientH, i, FALSE, TRUE);
	return 1;
	}
	return 0;
}

void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00200000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFDFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

void CGame::RequestResurrectPlayer(int iClientH, BOOL bResurrect)
{
short sX, sY;
char buff[100];

	if (m_pClientList[iClientH] == NULL) return;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;
	if  (memcmp(m_pClientList[iClientH]->m_cMapName, "deathmach", 9) == 0)
	{
		
		if (m_pClientList[iClientH]->m_bIsBeingResurrected == FALSE) {
			DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
			return;
		}
		
		wsprintf(buff, "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
		PutLogList(buff);
		
		
		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		// Player's HP becomes half of the Max HP. 
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH); 
		// Player's MP
		m_pClientList[iClientH]->m_iMP = (((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag)*2)+(m_pClientList[iClientH]->m_iLevel/2))+(m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt)/2;
		// Player's SP
		m_pClientList[iClientH]->m_iSP = ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)*2)+(m_pClientList[iClientH]->m_iLevel/2);
		// Player's Hunger
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		
		m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
		
		if (bResurrect == FALSE) {	
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			RequestTeleportHandler(iClientH, "1   ");
			return;
		}
		else {
			RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, -1, -1);
			m_pClientList[iClientH]->m_iSuperAttackLeft = (m_pClientList[iClientH]->m_iLevel / 10)*2;;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL); 
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 0;
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 0;
		}
	}
	else {

		if (bResurrect == FALSE) {
			m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
			return;
		}

		if (m_pClientList[iClientH]->m_bIsBeingResurrected == FALSE) {
			wsprintf(buff, "(!!!) Player(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName);
			DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
			return;
		}

		wsprintf(buff, "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
		PutLogList(buff);


		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		// Player's HP becomes half of the Max HP. 
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH)/2; 
		// Player's MP
		m_pClientList[iClientH]->m_iMP = (((m_pClientList[iClientH]->m_iMag+m_pClientList[iClientH]->m_iAngelicMag)*2)+(m_pClientList[iClientH]->m_iLevel/2))+(m_pClientList[iClientH]->m_iInt+m_pClientList[iClientH]->m_iAngelicInt)/2;
		// Player's SP
		m_pClientList[iClientH]->m_iSP = ((m_pClientList[iClientH]->m_iStr+m_pClientList[iClientH]->m_iAngelicStr)*2)+(m_pClientList[iClientH]->m_iLevel/2);
		// Player's Hunger
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;

		// !!! RequestTeleportHandler내에서 m_cMapName을 쓰기 때문에 그대로 파라미터로 넘겨주면 오동작
		RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	}
}

void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int i, iRet;
	short *sp;
	char cItemID[4], ctr[4];
	char *cp, cSlateColour, cData[120];
	BOOL bIsSlatePresent = FALSE;
	CItem * pItem;
	int iSlateType, iEraseReq;
	DWORD *dwp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	for(i = 0; i < 4; i++){
		cItemID[i] = 0;
		ctr[i] = 0;
	}

	cp = (char *)pData;
	cp += 11;

	// 14% chance of creating slates
	if (iDice(1,100) <= 40) bIsSlatePresent = TRUE;

    try{
	// make sure slates really exist
	for(i = 0; i < 4; i++){
		cItemID[i] = *cp;
		cp++;

		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] == NULL || cItemID[i] >DEF_MAXITEMS){ 
			bIsSlatePresent = FALSE;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  			
			return; 
		}

		//No duping
		if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868) // LU
			ctr[0] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869) // LD
			ctr[1] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870) // RU
			ctr[2] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871) // RD
			ctr[3] = 1;
	}
     }
     catch(...){
	//Crash Hacker Caught
	bIsSlatePresent = FALSE;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
	wsprintf(G_cTxt, "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
	PutLogList(G_cTxt);
	DeleteClient(iClientH, TRUE, TRUE);
	return;
     }

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = FALSE;
		return; 
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = TRUE;

	// if we failed, kill everything
	if (!bIsSlatePresent) { 
		for(i = 0; i < 4; i++){ 
			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
				ItemDepleteHandler(iClientH,cItemID[i], FALSE, FALSE);
			}
		} 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL); 
		return; 
	}

	// make the slates
	for(i = 0; i < 4; i++){
		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
			ItemDepleteHandler(iClientH,cItemID[i], FALSE, FALSE);
		}
	}

	pItem = new class CItem;

	i = iDice(1,1000);

	if (i < 50) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Bezerk slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Exp slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i <  1001) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATESUCCESS, iSlateType, NULL, NULL, NULL);

	ZeroMemory(cData,sizeof(cData));

	// Create slates
	if (_bInitItemAttr(pItem, 867) == FALSE) {
		delete pItem;
		return;
	}
	else{
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		pItem->m_sTouchEffectValue3 = (short)timeGetTime();

		_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if(_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE){
			ZeroMemory(cData,sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // ??|?????e便????
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp ++;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			*cp = (char)pItem->m_sItemSpecEffectValue3;
			cp++;

			if (iEraseReq == 1) delete pItem;

			// |??d보 |?
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ?a?보낼때 에러가 ???┛???
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
		else{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_MAGICCONFIGURATIONCONTENTS, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
										m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame,
										pItem->m_cItemColor);
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ?a?보낼때 에러가 ???┛???
						DeleteClient(iClientH, TRUE, TRUE);
						break;
			}
		}
	}
	return;
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (sType == DEF_NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		return;
	}

	if (bFlag == TRUE) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_iStatus |= 0x400000;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_iStatus |= 0x800000;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_iStatus |= 0x10000;
		}
	}
	else{
		if ((m_pClientList[iClientH]->m_iStatus & 0x400000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		}
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::AbaddonThunder()
{ 
	int iResult;
	register int i, j;
	DWORD dwTime = timeGetTime();

	if (iDice(1, 15) != 13) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
			if (memcmp(m_pClientList[i]->m_cMapName, "abaddon", 7) == 0) {
				switch (iDice(1,4)) {
					case 1:
					for (j = 0; j < 10; j++) {
						SendThunder(i, m_pClientList[i]->m_sX-iDice(1,7), m_pClientList[i]->m_sY+iDice(1,5), 253, m_pClientList[i]->m_sType);
						//SendThunder(i, m_pClientList[i]->m_sX-iDice(1,7), m_pClientList[i]->m_sY+iDice(1,5), 253, m_pClientList[i]->m_sType);
						//SendThunder(i, m_pClientList[i]->m_sX-iDice(1,10), m_pClientList[i]->m_sY+iDice(1,8), 253, m_pClientList[i]->m_sType);
					}
					break;
					
					case 2:
						SendThunder(i, m_pClientList[i]->m_sX+iDice(1,7), m_pClientList[i]->m_sY-iDice(1,5), 253, m_pClientList[i]->m_sType);
					break;
					
					case 3:
						SendThunder(i, m_pClientList[i]->m_sX+iDice(1,7), m_pClientList[i]->m_sY+5-iDice(1,9), 253, m_pClientList[i]->m_sType);
					break;
					
					case 4:
						SendThunder(i, m_pClientList[i]->m_sX+5-iDice(1,9), m_pClientList[i]->m_sY+7-iDice(1,4), 253, m_pClientList[i]->m_sType);
					break;
				}
			
				if (m_pClientList[i]->m_iAdminUserLevel > 0) continue; 
			
				iResult = iDice(1,20) + 100;
				if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) {
					iResult /= 2;
				}
				m_pClientList[i]->m_iHP -= iResult;
				if (m_pClientList[i]->m_iHP <= 0) {
					ClientKilledHandler(i, NULL, NULL, iResult);
				}
				else if (iResult > 0) {
					m_pClientList[i]->m_iLastDamage = dwTime;     
					SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iResult, NULL, NULL);
					if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
						m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}
					if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);      
						m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					}
				}
			}
		}
	}
}

void CGame::SendThunder(int iClient, short sX, short sY, short sV3, short sV4)
{
	char  * cp, cData[100];
	DWORD * dwp;
	WORD * wp;
	short * sp;
	int iRet;
	
	ZeroMemory(cData, sizeof(cData)); 
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_COMMON;
	
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_COMMONTYPE_MAGIC; 
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	
	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;
	
	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;
	
	iRet = m_pClientList[iClient]->m_pXSock->iSendMsg(cData, 18);
}

BOOL CGame::bApocalypseMobGenerator(int iMapIndex)
{
	char cNpcName[21], cName[11], cSA, cNpcWaypointIndex[11];
	int iProbSA, iKindSA, dX, dY, iNamingValue;	
	BOOL bFirmBerserk = FALSE, bRet;
	register int i;

	if (m_pMapList[iMapIndex]->m_bIsBossInMap == TRUE) return FALSE;
	iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
	
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if (iNamingValue == -1) {
	}
	else {
		ZeroMemory(cName, sizeof(cName));
		switch(m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID) {
			case 10:  strcpy(cNpcName,"Slime");        iProbSA = 5;  iKindSA = 1; break;
			case 16:  strcpy(cNpcName,"Giant-Ant");    iProbSA = 10; iKindSA = 2; break;
			case 14:  strcpy(cNpcName,"Orc");          iProbSA = 15; iKindSA = 1; break;
			case 18:  strcpy(cNpcName,"Zombie");       iProbSA = 15; iKindSA = 3; break;
			case 11:  strcpy(cNpcName,"Skeleton");     iProbSA = 35; iKindSA = 8; break;
			case 6:   strcpy(cNpcName,"Orc-Mage");     iProbSA = 30; iKindSA = 7; break;
			case 17:  strcpy(cNpcName,"Scorpion");     iProbSA = 15; iKindSA = 3; break;
			case 12:  strcpy(cNpcName,"Stone-Golem");  iProbSA = 25; iKindSA = 5; break;
			case 13:  strcpy(cNpcName,"Cyclops");      iProbSA = 35; iKindSA = 8; break;
			case 22:  strcpy(cNpcName,"Amphis");       iProbSA = 20; iKindSA = 3; break;
			case 23:  strcpy(cNpcName,"Clay-Golem");   iProbSA = 20; iKindSA = 5; break;
			case 24:  strcpy(cNpcName,"Guard-Aresden");iProbSA = 20; iKindSA = 1; break;
			case 25:  strcpy(cNpcName,"Guard-Elvine"); iProbSA = 20; iKindSA = 1; break;
			case 26:  strcpy(cNpcName,"Guard-Neutral");iProbSA = 20; iKindSA = 1; break;
			case 27:  strcpy(cNpcName,"Hellbound");    iProbSA = 20; iKindSA = 1; break;
			case 29:  strcpy(cNpcName,"Orge");         iProbSA = 20; iKindSA = 1; break;
			case 30:  strcpy(cNpcName,"Liche");        iProbSA = 30; iKindSA = 8; break;
			case 31:  strcpy(cNpcName,"Demon");        iProbSA = 20; iKindSA = 8; break;
			case 32:  strcpy(cNpcName,"Unicorn");      iProbSA = 35; iKindSA = 7; break;
			case 33:  strcpy(cNpcName,"WereWolf");     iProbSA = 25; iKindSA = 1; break;
			case 34:  strcpy(cNpcName,"Dummy");        iProbSA = 5;  iKindSA = 1; break;
			case 35:  strcpy(cNpcName,"Attack-Dummy"); iProbSA = 5;  iKindSA = 1; break;
			case 48:  strcpy(cNpcName,"Stalker");      iProbSA = 20; iKindSA = 3; break;
			case 49:  strcpy(cNpcName,"Hellclaw");		 iProbSA = 20; iKindSA = 8;	break;
			case 50:  strcpy(cNpcName,"Tigerworm");    iProbSA = 20; iKindSA = 8; break;
			case 53:  strcpy(cNpcName,"Dark-Elf");      iProbSA = 20; iKindSA = 8; break;
			case 54:  strcpy(cNpcName,"Beholder");      iProbSA = 20; iKindSA = 8; break;
			case 55:  strcpy(cNpcName,"Gagoyle");       iProbSA = 20; iKindSA = 8; break;
			case 57:   strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2; break;
			case 58:   strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1; break;
			case 59:   strcpy(cNpcName,"Ettin");			iProbSA = 20; iKindSA = 8; break;
			case 60:   strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5; break;
			case 61:   strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1; break;
			case 62:   strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1; break;
			case 63:   strcpy(cNpcName,"Frost");			iProbSA = 20; iKindSA = 8; break;
			case 65:   strcpy(cNpcName,"Ice-Golem");		iProbSA = 20; iKindSA = 8; break;
			case 66:   strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 1; break;
			case 5:    strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1; break;
			case 67:   strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1; break;
			case 68:   strcpy(cNpcName,"Perry");			iProbSA = 20; iKindSA = 1; break;
			case 69:   strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1; break;
			case 70:   strcpy(cNpcName,"Spider");     iProbSA = 20; iKindSA = 1; break;
			case 71:   strcpy(cNpcName,"Spectre");  iProbSA = 20; iKindSA = 1; break;
			case 72:   strcpy(cNpcName,"Yeti"); iProbSA = 20; iKindSA = 1; break;
			case 73:   strcpy(cNpcName,"Fire-Wyvern"); iProbSA = 20; iKindSA = 1; break;
			case 74:   strcpy(cNpcName,"Giant-Crayfish"); iProbSA = 20; iKindSA = 1; break;
			case 75:   strcpy(cNpcName,"Giant-Lizard"); iProbSA = 20; iKindSA = 1; break;
			case 76:   strcpy(cNpcName,"Giant-Plant"); iProbSA = 20; iKindSA = 1; break;
			case 77:   strcpy(cNpcName,"Doomdemon"); iProbSA = 20; iKindSA = 1; break;
			case 78:   strcpy(cNpcName,"PitLord"); iProbSA = 20; iKindSA = 1; break;
			case 79:   strcpy(cNpcName,"Nizie"); iProbSA = 20; iKindSA = 1; break;
			case 80:   strcpy(cNpcName,"Tentocle"); iProbSA = 20; iKindSA = 1; break;
			case 81:   strcpy(cNpcName,"Abaddon"); iProbSA = 20; iKindSA = 1; break;
			default:   strcpy(cNpcName, "Orc"); iProbSA = 15; iKindSA = 1; break;
		}
		
		cSA = _cGetSpecialAbility(iKindSA);
		if (iDice(1,5) == 1) {
			bFirmBerserk = TRUE;
		}
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = i + 65;
		bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 53, cSA, DEF_MOVETYPE_RANDOMAREA, &dX, &dY, cNpcWaypointIndex, &m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect, i, -1, FALSE, FALSE, bFirmBerserk, FALSE, FALSE);
		
		if (bRet == FALSE) {
			m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
			return FALSE;
		} 
		
		else{
			m_pNpcList[bRet]->m_bIsBossMob = TRUE;
			m_pMapList[iMapIndex]->m_bIsBossInMap = TRUE;
			return TRUE;
			}
		}
	}
	return FALSE;
}


		// Ovl 17:36 -- 21/02/2007
void CGame::Desbug(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token;
 CStrTok * pStrTok;
 char cBuff[256], cName[11], cTargetName[11], cFileNamex[255], cFileName[255], cDir[63];
    /**********************************************************/
	
    ZeroMemory(cTargetName, sizeof(cTargetName));

    /**********************************************************/
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}


	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));


    /***************************************************************/
	ZeroMemory(cFileName, sizeof(cFileName));
	ZeroMemory(cDir, sizeof(cDir));
	wsprintf(cDir, "..\\..\\Character\\AscII%d\\%s.bak", *cTargetName, cTargetName);
	strcat(cFileName, cDir);

	/***************************************************************/

	ZeroMemory(cFileNamex, sizeof(cFileNamex));
	ZeroMemory(cDir, sizeof(cDir));
	wsprintf(cDir, "..\\..\\Character\\AscII%d\\%s.txt", *cTargetName, cTargetName);
    strcat(cFileNamex, cDir);
	/**************************************************************/
    DeleteFile(cFileNamex);
	CopyFile(cFileName,cFileNamex, FALSE);
    /**************************************************************/
	delete pStrTok;
	return;
	}
}

void CGame::AdminOrder_banjail(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName[11], cTargetName[11];
  CStrTok * pStrTok;
 register int tiempo;
 register int i;
 BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tiempo = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
            bFlag = TRUE;
			//Defines I as Max clients
				if (bFlag == TRUE)
					tiempo = (tiempo * 60);
				if (m_pClientList[i]->m_cSide == 1){
				ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
				strcpy(m_pClientList[i]->m_cLockedMapName, "arejail");
				m_pClientList[i]->m_iLockedMapTime = tiempo;
				RequestTeleportHandler(i, "2   ", "arejail", -1, -1);
				}
				else {
				ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
				strcpy(m_pClientList[i]->m_cLockedMapName, "elvjail");
				m_pClientList[i]->m_iLockedMapTime = tiempo;
				RequestTeleportHandler(i, "2   ", "elvjail", -1, -1);
				}
				
				DeleteClient(i, TRUE, TRUE);
				delete pStrTok;
				return;
			}
	}
	delete pStrTok;
}


void CGame::AdminOrder_ban(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName[11], cTargetName[11];
  CStrTok * pStrTok;
 register int dia, mes, year;
 register int i;
 BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dia = mes = 00;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		year = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		mes = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dia = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

	if (strlen(token) > 10) 
		memcpy(cTargetName, token, 10);
		else 
			memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				bFlag = TRUE;
			//Defines I as Max clients
				if (bFlag == TRUE) {
					m_pClientList[i]->m_iPenaltyBlockYear = year;
				    m_pClientList[i]->m_iPenaltyBlockMonth = mes;
					m_pClientList[i]->m_iPenaltyBlockDay = dia;
					DeleteClient(i, TRUE, TRUE);
					delete pStrTok;
					return;
				}
		}
	}
	delete pStrTok;
}


void CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp) 
{
int iMaxHP, iMaxMP, iMaxSP;
	if (cOwnerType != DEF_OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == NULL) return;
	switch (iStatus) {
	case 1: // STR Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00001000;		
		break;
	case 2: // DEX Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00002000;
		break;
	case 3: // INT Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00004000;
		bAddMagicAngelInt(sOwnerH);
		SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
		break;
	case 4: // MAG Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00008000;
		break;
	default:
	case 0: // Remove all Angels
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF00FF;
		iMaxHP = iGetMaxHP(sOwnerH);
		iMaxMP = (2*m_pClientList[sOwnerH]->m_iMag) + (2*m_pClientList[sOwnerH]->m_iLevel) + (m_pClientList[sOwnerH]->m_iInt/2);
		iMaxSP = (2*m_pClientList[sOwnerH]->m_iStr) + (2*m_pClientList[sOwnerH]->m_iLevel);
		
		if(m_pClientList[sOwnerH]->m_iHP > iMaxHP)
			m_pClientList[sOwnerH]->m_iHP = iMaxHP;
		if(m_pClientList[sOwnerH]->m_iMP > iMaxMP)
			m_pClientList[sOwnerH]->m_iMP = iMaxMP;
		if(m_pClientList[sOwnerH]->m_iSP > iMaxSP)
			m_pClientList[sOwnerH]->m_iSP = iMaxSP;


		break;
	}
	iTemp -= 5;
	if (iTemp > 9)
	{	int iAngelicStars = (iTemp/3)*(iTemp/5);
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | (iAngelicStars << 8);
	}
	SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}
void CGame::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char  *cp, cData[256], cTmpName[21];
 int   iAngel;
 class CItem * pItem;
 int   iRet, iEraseReq, iRequiredMagesty;
 char  cItemName[21];
 short * sp;
 WORD  * wp;
 int   * ip;
 DWORD * dwp;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int *)cp;
	iAngel = (int) *ip;
	cp += 2;
	switch (iAngel) {
	case 1:
		wsprintf(cItemName, "AngelicPandent(STR)");
		iRequiredMagesty = 5;
		break;
	case 2:
		wsprintf(cItemName, "AngelicPandent(DEX)");
		iRequiredMagesty = 5;
		break;
	case 3:
		wsprintf(cItemName, "AngelicPandent(INT)");
		iRequiredMagesty = 5;
		break;
	case 4:
		wsprintf(cItemName, "AngelicPandent(MAG)");
		iRequiredMagesty = 5;
		break;
	default:
		PutLogList("Gail asked to create a wrong item!");	
		break;
	}
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, cItemName) == TRUE)) 
	{	pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	
			ZeroMemory(cData, sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;				
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);				
			*cp = 1;
			cp++;				
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;				
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;				
			*cp = pItem->m_cItemType;
			cp++;				
			*cp = pItem->m_cEquipPos;
			cp++;				
			*cp = (char)0; 
			cp++;				
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;				
			*cp = pItem->m_cGenderLimit;
			cp++;				
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;				
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2; 
			cp++;				

			if (iEraseReq == 1) delete pItem;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			switch (iRet) 
			{
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= iRequiredMagesty; 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
		}
		else 
		{	
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);		
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) 
			{
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}	
		}
	}
	else 
	{	
		delete pItem;
		pItem = NULL;
	}
}


void CGame::ReqCreateCraftingHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cCraftingName[21], cData[120];
 int    iRet, i, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
 short * sp, sTemp;
 short  sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag, bNeedLog;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) 
	{	cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	cp = (char *)(pData + 11);
	cp += 20;
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;

	for (i = 0; i < 6; i++) 
	{	if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) 
	{	bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) 
		{	sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) 
		{	for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) 
			{	sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;	
	}	}

	
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) 
	{	if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
		sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum == 657)
		{	sItemPurity[i] = 100; // Merien stones considered 100% purity.
		}		
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
		{	sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
		}
		if (sItemNumber[i] > 1) // No purity for stacked items
		{	sItemPurity[i] = -1;
		}

		if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == DEF_EQUIPPOS_NECK))
		{	iNeededContrib = 10; // Necks Crafting requires 10 contrib
	}	}

	// Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) 
	{	bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) 
		{	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) 
			{	sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemPurity[i+1];
				sItemPurity[i+1] = sItemPurity[i];
				sItemPurity[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
	}	}	}
	j = 0;
	for (i = 0; i < 6; i++)
	{	if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	ZeroMemory(cCraftingName, sizeof(cCraftingName));
	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pCraftingConfigList[i] != NULL) 
	{	bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		{	if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE; // one item mismatch	
		}
		if (bFlag == FALSE) // good Crafting receipe
		{	ZeroMemory(cCraftingName, sizeof(cCraftingName));
			memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
			iRiskLevel  = m_pCraftingConfigList[i]->m_iSkillLimit;			// % to loose item if crafting fails
			iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
	}	}


	// Check if recipe is OK
	if (strlen(cCraftingName) == 0) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 1, NULL, NULL, NULL); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 2, NULL, NULL, NULL); // "There is not enough Contribution Point"	
		return;
	}
	// Check possible Failure
	if (iDice(1,100) > iDifficulty) 
	{	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 3, NULL, NULL, NULL); // "Crafting failed"
		// Remove parts...
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) 
		{	// Deplete any Merien Stone
			if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
			{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
			}else 
			// Risk to deplete any other items (not stackable ones) // DEF_ITEMTYPE_CONSUME
			if (   (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
				|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_MATERIAL))
			{	if (iDice(1,100) < iRiskLevel)	
				{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
		}	}	}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for (i = 0; i < 6; i++) 
	{	if (sItemIndex[i] != -1) 
		{	if (sItemPurity[i] != -1) 
			{	iTot += sItemPurity[i];
				iCount ++;
	}	}	}
	if (iCount == 0 ) 
	{	iPurity = 20 + iDice(1,80);			// Wares have random purity (20%..100%)
		bNeedLog = FALSE;
	}else 
	{	iPurity = iTot/iCount;
		iTot    = (iPurity*4)/5;
		iCount  = iPurity - iTot;
		iPurity = iTot + iDice(1,iCount);	// Jewel completion depends off Wares purity
		bNeedLog = TRUE;
	}
	if (iNeededContrib != 0) 
	{	iPurity = 0;						// Necks require contribution but no purity/completion
		bNeedLog = TRUE;
	}
	//CalculateSSN_SkillIndex(iClientH, 12, 1);

	if (strlen(cCraftingName) != 0) 
	{	pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		{	if (sItemIndex[i] != -1) 
			{	if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				{	SetItemCount(iClientH, sItemIndex[i], 
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);					
				}else // So if item is not Type 5 (stackable items), you deplete item
				{	ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
		}	}	}
		if (iNeededContrib !=0)
		{	m_pClientList[iClientH]->m_iContribution -= iNeededContrib;   
			// No known msg to send info to client, so client will compute shown Contrib himself.		
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRAFTING_SUCCESS, NULL, NULL, NULL, NULL);

		m_pClientList[iClientH]->m_iExpStock += iDice(2, 100);

		if ((_bInitItemAttr(pItem, cCraftingName) == TRUE)) 
		{	// // Snoopy: Added Purity to Oils/Elixirs
			if (iPurity != 0) 
			{	
                pItem->m_sItemSpecEffectValue1 = 300;
				pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			pItem->m_wMaxLifeSpan = 300;
			// pItem->m_sTouchEffectValue3 = timeGetTime();	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			// SNOOPY log anything above WAREs
		/*	if (bNeedLog) 		
			{
		wsprintf(G_cTxt, "PC(%s) Crafting (%s) Purity(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_cName, pItem->m_sItemSpecEffectValue2);			
		PutLogList(G_cTxt);*/
					//}*/
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
			{	ZeroMemory(cData, sizeof(cData));
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);	
				*cp = 1;
				cp++;				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;				
				*cp = pItem->m_cItemType;
				cp++;				
				*cp = pItem->m_cEquipPos;
				cp++;				
				*cp = (char)0; 
				cp++;				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;				
				*cp = pItem->m_cGenderLimit;
				cp++;				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				
				/**cp = (char)pItem->m_sItemSpecEffectValue1; // v1.41 
				cp++;*/
				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				
				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;
				/*	*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item
				cp++;	*/				
				if (iEraseReq == 1) delete pItem;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}else 
			{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
			}	}
		}else 
		{	delete pItem;
			pItem = NULL;	
	}	}
}


void CGame::AdminOrder_SetStatus(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * token2, cBuff[256];
	int    iPass;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel <= 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token2 = pStrTok->pGet();

	iPass = (int)token;
	if (token != NULL) {
		//  째짧 쨔짰 '1'쨍챕 천쨍챠쨍쨌 쩌쩌짰. '0'쨍챕 짝 

		if (token[0]=='0') {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
//			SetEXPSlateFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
//			SetHPSlateFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		}
		if (token[0]=='1') {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='2') {
			SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='3') {
			SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='4') {
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='5') {
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='6') {
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='7') {
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='8') {
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='9') {
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0] == '1' && token[1] == '0') {
			SetInhibitionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0] == '1' && token[1] == '1') {
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
	}
	}
	delete pStrTok;
}

void CGame::SetInhibitionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

void CGame::ShowVersion(int iClientH)
{
	char cVerMessage[256];

	if (m_pClientList[iClientH] == NULL) return;
	ZeroMemory(cVerMessage, sizeof(cVerMessage));
	wsprintf(cVerMessage, "Helbreath Return", DEF_UPPERVERSION, DEF_LOWERVERSION, DEF_BUILD);
	ShowClientMsg(iClientH, cVerMessage);
}


void CGame::GetDkSet(int iClientH) 
{
char cVerMessage[256];	
class CItem * pItem;
int dkM[]={706,707,708,710,714};
int dkW[]={724,725,726,728,732};
int dmM[]={711,712,713,717,913};
int dmW[]={729,730,731,717,912};
int weapon, iItemID, i, iEraseReq;
if(m_pClientList[iClientH] == NULL) return;
if(m_pClientList[iClientH]->m_iLevel < 200) return;
if (((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cityhall_1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "cityhall_2") == 0))) {
for (i = 0; i <= 5; i++)
{
 pItem = new class CItem;
 iItemID=-1;
 if (m_pClientList[iClientH]->m_cSex == 1)
 {
  if (m_pClientList[iClientH]->m_iStr > 100)
  {
   iItemID=dkM[i];
  }
  else
  {
   iItemID=dmM[i];
  }
 }
 else
 {
  if (m_pClientList[iClientH]->m_iStr > 100)
  {
   iItemID=dkW[i];
  }
  else
  {
   iItemID=dmW[i];
  }
 }
 if (i == 5)
 {
  if (m_pClientList[iClientH]->m_iStr > 129)
  { if (m_pClientList[iClientH]->m_cSex == 1){
   weapon=709;
  } 
  else if (m_pClientList[iClientH]->m_cSex == 2){
   weapon=727;
  }
  }
  else
  { if (m_pClientList[iClientH]->m_cSex == 1){
   weapon=714;
  } 
  else if (m_pClientList[iClientH]->m_cSex == 2){
   weapon=732;
  }
  }
  iItemID = weapon;
 }
 if (iItemID != -1) 
 {
  _bInitItemAttr(pItem, iItemID);
  pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
  pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
  pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
  pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
  _bAddClientItemList(iClientH, pItem, &iEraseReq);
  SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
  
 }
}
} 
else
{
		ZeroMemory(cVerMessage, sizeof(cVerMessage));
		wsprintf(cVerMessage, "Tienes que ir al Cityhall para pedir el DKset");
		ShowClientMsg(iClientH, cVerMessage);
}
}

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char * cp, cTemp[256];
	DWORD * dwp, dwMsgSize;
	WORD * wp;
	short * sp;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	memcpy(cp, "HGServer", 8); 
	cp += 10;

	*cp = 10; 
	cp++;

	dwMsgSize = strlen(pMsg);
	if(dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::ShowClientMsg2(int iClientH, char* pMsg, int iChatType)
{
char * cp, cTemp[256];
DWORD * dwp, dwMsgSize;
WORD * wp;
short * sp;

ZeroMemory(cTemp, sizeof(cTemp));

dwp = (DWORD *)cTemp;
*dwp = MSGID_COMMAND_CHATMSG;

wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
*wp = NULL;

cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
sp  = (short *)cp;
*sp = NULL;
cp += 2;

sp  = (short *)cp;
*sp = NULL;
cp += 2;

memcpy(cp, "HGServer", 0);
cp += 10;

*cp = iChatType; // chat type
cp++;

dwMsgSize = strlen(pMsg);
if(dwMsgSize > 50) dwMsgSize = 50;
memcpy(cp, pMsg, dwMsgSize);
cp += dwMsgSize;

m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::AdminOrder_CleanMap(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	CStrTok * pStrTok;
	char   * token, cMapName[11], cBuff[256];
	BOOL bFlag = FALSE;	//Used to check if we are on the map we wanna clear
	int i;
	CItem *pItem;
	short sRemainItemSprite, sRemainItemSpriteFrame, dX, dY;
	char cRemainItemColor, len;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		memcpy(cMapName, token, 10);

		for (i = 0; i < DEF_MAXMAPS; i++)	//Enum all maps
			if (m_pMapList[i] != NULL) {	//Is allocated map
				if (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) {	//is map same name
					bFlag = TRUE; //Set flag
					//Get X and Y coords
					int m_x = m_pMapList[i]->m_sSizeX;
					int m_y = m_pMapList[i]->m_sSizeY;
					for(int j = 1; j < m_x; j++)
						for(int k = 1; k < m_y; k++){
							do {	//Delete all items on current tile
								pItem = m_pMapList[i]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
								if (pItem != NULL) {
									delete pItem;	//Delete item;
								}
							} while(pItem != NULL);
						}
					break;	//Break outo f loop
				}
			}

		if (!bFlag) {	//Notify GM he has to be on the map he clears
		}
		else{	//Notify GM that all items have been cleared
			for(int i = 1; i < DEF_MAXCLIENTS; i++){
				if (m_pClientList[i] != NULL) {
				len = strlen(cMapName);
				if(len > 10) len = 10;
				if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cMapName, len) != 0) return;
				dX = m_pClientList[i]->m_sX;
				dY = m_pClientList[i]->m_sY;
				ZeroMemory(cMapName,sizeof(cMapName));
				strcpy(cMapName, m_pClientList[i]->m_cMapName);
				RequestTeleportHandler(i,"2   ", cMapName, dX, dY);
				}
			}
		}
	}

	delete pStrTok;
	return;
}

///////////////////HELDENIAN////////////////////////////////////

void CGame::NotifyStartHeldenianFightMode() 
{ 
register int i, x; 

if ((m_bIsHeldenianMode != TRUE) && (m_bHeldenianInitiated != TRUE)) return; 
PutLogList("Heldenian Fight Start"); 
m_bHeldenianInitiated = FALSE; 
for (i = 0; i < DEF_MAXMAPS; i++) { 
if (m_pMapList[i] != NULL) { 
if (m_pMapList[i]->m_bIsHeldenianMap == TRUE) { 
for (x = 0; x < DEF_MAXCLIENTS; x++) { 
if (m_pClientList[x] != NULL) { 
if (m_pClientList[x]->m_bIsInitComplete == TRUE) { 
if (m_pClientList[x]->m_cMapIndex == i) { 
SendNotifyMsg(NULL, x, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL); 
} 
} 
} 
} 
} 
} 
} 
}  


void CGame::RequestHeldenianScroll(int iClientH, char * pData, DWORD dwMsgSize)
{

 char  *cp, cData[256], cTmpName[21];
 int   iNumeroItem;
 class CItem * pItem;
 int   iRet, iEraseReq, iPuntos;
 short * sp;
 WORD  * wp;
 DWORD * dwp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsHeldenianMode == FALSE) return;
	
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	wp = (WORD *)cp;
	iNumeroItem = (int) *wp;
	cp += 2;

	switch (iNumeroItem) {
    case 875: // Sorceress
		iPuntos = 2000;
		break;
	case 876: // Ancient Temple Knight
		iPuntos = 3000;
		break;
	case 877: // Elf Master
		iPuntos = 1500;
		break;
	case 878: // DarkShadow Knight
		iPuntos = 3000;
		break;
	case 879: // Heavy Battle Tank
		iPuntos = 4000;
		break;
	case 880: // Barbarian
		iPuntos = 3000;
		break;
	default:
		PutLogList("Numero Invalido HScroll!");
		return;
		break;
		//si tenes los puntos solo dar el item
	}
	if (m_pClientList[iClientH]->m_iConstructionPoint < iPuntos)
	{
		
	}else
	{	// de lo contrario dar scroll con msg de abajo a la izq
		m_pClientList[iClientH]->m_iConstructionPoint -= iPuntos;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, NULL); // 0:tell client
	}
	

	//poner id
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((_bInitItemAttr(pItem, iNumeroItem) == TRUE)) 
	{	pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		memcpy(&pItem->m_sItemSpecEffectValue1, &m_dwHeldenianGUID, 4);
//burbuja de datos encriptados
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) 
		{	ZeroMemory(cData, sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;				
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);				
			*cp = 1;
			cp++;				
			memcpy(cp, pItem->m_cName, 20);
			cp += 20;				
			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;				
			*cp = pItem->m_cItemType;
			cp++;				
			*cp = pItem->m_cEquipPos;
			cp++;				
			*cp = (char)0; 
			cp++;				
			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;				
			*cp = pItem->m_cGenderLimit;
			cp++;				
			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;				
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;				
			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;
			*cp = pItem->m_cItemColor;
			cp++;
			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp++;				
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			
			*cp = (char)pItem->m_sItemSpecEffectValue3;
			cp++;
			if (iEraseReq == 1) delete pItem;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
		}else 
		{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				                                                         m_pClientList[iClientH]->m_sY, pItem);			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;				
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				break;
		}	}
	}else 
	{	delete pItem;
		pItem = NULL;
	}
}
//cerrarado todo

//8/01/07  Compilado y echo por Ovl Synapsys Corp
void CGame::GlobalEndHeldenianMode() 
{

LocalEndHeldenianMode(TRUE, m_sLastHeldenianWinner);
} 
//Ovl 02:13 23/01/07
void CGame::HeldenianEnd()
{
	m_bIsHeldenianMode = FALSE; 
	bHeldenianFight = FALSE;
	wsprintf(G_cTxt, "(!) HELDENIAN Ends. Winner %d", m_sLastHeldenianWinner); 
	PutLogList(G_cTxt); 
}

void CGame::LocalEndHeldenianMode(int iClientH, int iSide) 
{ 
DWORD dwTime = timeGetTime(); 
register int i, x; 

if (m_bIsHeldenianMode == FALSE) return; 
m_bIsHeldenianMode = FALSE; 
bHeldenianFight = FALSE; 
m_dwHeldenianFTime = -1; //schedule
m_dwHeldenianSafeTime = timeGetTime() + 1*60;
m_bHeldSafe = TRUE;

if (m_cHeldenianModeType == 1) { //1
if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) { //2
m_cHeldenianVictoryType = 1; 
} //2
else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) {//3 
m_cHeldenianVictoryType = 2; 
} //3
else if (m_iHeldenianAresdenDead < m_iHeldenianElvineDead) { //4
m_cHeldenianVictoryType = 1; 
} //4
else if (m_iHeldenianAresdenDead > m_iHeldenianElvineDead) { //5
m_cHeldenianVictoryType = 2; 
} //5
else { 
m_sLastHeldenianWinner = iSide; 
} 
} //1
else if (m_cHeldenianModeType == 2) { 

	if (bHFlag == FALSE) {
	m_cHeldenianVictoryType = iSide; 
	} else {
    m_cHeldenianVictoryType = m_sLastHeldenianWinner;
	}
	} 
m_sLastHeldenianWinner = m_cHeldenianVictoryType; 
if (bNotifyHeldenianWinner() == FALSE) { 
wsprintf(G_cTxt, "(!) HELDENIAN End. Winner %d", m_sLastHeldenianWinner); 
PutLogList(G_cTxt); 
} 
for (i = 0; i < DEF_MAXMAPS; i++) { 
if ((i < 0) || (i > 100) || (m_pMapList[i] != NULL)) { 
for (x = 0; x < DEF_MAXCLIENTS; x++) { 
if ((m_pClientList[x] != NULL) && (m_pClientList[x]->m_bIsInitComplete == TRUE)) { 
SendNotifyMsg(NULL, x, DEF_NOTIFY_HELDENIANVICTORY, m_sLastHeldenianWinner, NULL, NULL, NULL); 
SendNotifyMsg(NULL, x, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL); // Victory defeat screen 

} 
} 
Timeheldenianfinal();
//m_sLastHeldenianWinner
LimpiarNpcHeldenian(iClientH);
bUpdateHeldenianStatus(iClientH); 
} 
} 
CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianVictoryType); 


char * cp, cData[32]; 
DWORD * dwp; 
int * ip;

ZeroMemory(cData, sizeof(cData)); 
cp = (char *)cData; 
*cp = GSM_ENDHELDENIAN; 
cp++; 
dwp = (DWORD *)cp; 
*dwp = m_dwHeldenianGUID; 
cp += 4; 
ip = (int *)cp; 
*ip = m_sLastHeldenianWinner; 
cp += 4; 
bStockMsgToGateServer(cData, 9);
 

//LocalEndHeldenianMode();
} 
void CGame::Timeheldenianfinal()
{
int Ovl; 
        for (Ovl = 1; Ovl < DEF_MAXCLIENTS; Ovl++) { 
      if (m_pClientList[Ovl] == NULL) return; 
       			{
	m_pClientList[Ovl]->m_iTimeLeft_ForceRecall = 90;	
	m_pClientList[Ovl]->m_b5MinutosFinales = TRUE;
			}
		}

}
void CGame::RemoveOccupyFlags(int iMapIndex)
{DWORD dwTime = timeGetTime();
 register int i;
 short dX, dY;
 int iDynamicObjectIndex;
 class CTile * pTile;
 int iy, ix;
	if (m_pMapList[iMapIndex] == NULL) return;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	{	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] == NULL)
		{	continue;
		}else // remove this OccupyFlag
		{	dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			delete m_pMapList[iMapIndex]->m_pOccupyFlag[i];
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;			
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;

			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) continue;
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT
				, iMapIndex, dX, dY, m_pDynamicObjectList[iDynamicObjectIndex]->m_sType
				, iDynamicObjectIndex, NULL);
			m_pMapList[iMapIndex]->SetDynamicObject(NULL, NULL, dX, dY, dwTime);

			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) 
			{	for (ix = dX - 2; ix <= dX + 2; ix++)
				for (iy = dY - 2; iy <= dY + 2; iy++) 
				{	pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + ix + iy*m_pMapList[iMapIndex]->m_sSizeY);
					pTile->m_sOwner = NULL;
	}	}	}	}
register int j;
	for (i = 0; i < m_pMapList[iMapIndex]->m_sSizeX; i++) // Then remove all m_iOccupyStatus
	for (j = 0; j < m_pMapList[iMapIndex]->m_sSizeY; j++)  	
	{	pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + i + j*m_pMapList[iMapIndex]->m_sSizeY);
		pTile->m_iOccupyStatus = 0; 
	}
}

void CGame::RequestHeldenianTeleport(int iClientH, char * pData, DWORD dwMsgSize) 
{ 
 char cTmpName[21], * cp, cData[512], cMapName[11]; 
 WORD wResult; 
 int iRet, iWhyReturn, iProcessed, tX, tY, cLoc, * ip; 
 DWORD *dwp; 

	iProcessed = 1; 
	if (m_pClientList[iClientH] == NULL) return; 

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2); 
	ZeroMemory(cTmpName, sizeof(cTmpName)); 
	strcpy(cTmpName, cp); 

	if (strcmp(cTmpName, "Gail") == 0) { 
		ZeroMemory(cData, sizeof(cData)); 
		dwp = (DWORD *)(cData); 
		*dwp = MSGID_REQUEST_GAILTELEPORT; 
		wResult = DEF_MSGTYPE_CONFIRM; 
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 

		if ((m_bIsHeldenianMode == 1) && (m_pClientList[iClientH]->m_bIsHunter != TRUE) && ((m_pClientList[iClientH]->m_cSide == 2 || (m_pClientList[iClientH]->m_cSide == 1)))) { 
			if (m_cHeldenianModeType == 1) { 
				ZeroMemory(cMapName, sizeof(cMapName)); 
				memcpy(cMapName, "BtField", 10); 
				if (m_pClientList[iClientH]->m_cSide == 1) { 
					tX = 68; 
					tY = 225; 
					cLoc = 1; 
				} 
				else if (m_pClientList[iClientH]->m_cSide == 2) { 
					tX = 202; 
					tY = 70; 
					cLoc = 2; 
				} 
			} 
			else if (m_cHeldenianModeType == 2) { 
				ZeroMemory(cMapName, sizeof(cMapName)); 
				memcpy(cMapName, "HRampart", 10); 
				if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) { 
					tX = 81; 
					tY = 42; 
					cLoc = 3; 
				} 
				else { 
					tX = 156; 
					tY = 153; 
					cLoc = 4; 
				} 
			} 
			wResult = DEF_MSGTYPE_CONFIRM; 
			iProcessed = 1; 
			iWhyReturn = 0; 
			goto SENDPLAYER; 
		} else if((m_bCityWar == TRUE) && (m_pClientList[iClientH]->m_bIsHunter != TRUE) && ((m_pClientList[iClientH]->m_cSide == 2 || (m_pClientList[iClientH]->m_cSide == 1)))) { 
			ZeroMemory(cMapName, sizeof(cMapName)); 
			memcpy(cMapName, "HRampart", 10); 
			if (m_pClientList[iClientH]->m_cSide == m_cCityWarWinner) { 
				tX = 81; 
				tY = 42; 
				cLoc = 3; 
			} 
			else { 
				tX = 156; 
				tY = 153; 
				cLoc = 4; 
			} 
			wResult = DEF_MSGTYPE_CONFIRM; 
			iProcessed = 1; 
			iWhyReturn = 0; 
			goto SENDPLAYER; 
		}
		wResult = DEF_MSGTYPE_REJECT; 
		iProcessed = 0; 
		iWhyReturn = 0; 
	} 

SENDPLAYER:; 
	ip = (int *)cp; 
	*ip = iProcessed; 
	cp += 4; 

	ip = (int *)cp; 
	*ip = cLoc; 
	cp += 4; 

	memcpy((char *)cp, cMapName, 10); 
	cp += 10; 

	ip = (int *)cp; 
	*ip = tX; 
	cp += 4; 

	ip = (int *)cp; 
	*ip = tY; 
	cp += 4; 

	ip = (int *)cp; 
	*ip = iWhyReturn; 
	cp += 4; 

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 36);
	switch (iRet) { 
	case DEF_XSOCKEVENT_QUENEFULL: 
	case DEF_XSOCKEVENT_SOCKETERROR: 
	case DEF_XSOCKEVENT_CRITICALERROR: 
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE); 
		break; 
	} 
} 

void CGame::HeldenianWarStarter() 
{SYSTEMTIME SysTime; 
int i; 
GetLocalTime(&SysTime); 
if (var_89C == TRUE) return; 
if (var_8A0 == FALSE) return; 
for (i = 0; i < DEF_MAXSCHEDULE; i++) 
if (m_bIsApocalypseMode == TRUE) return; 
if (m_bIsCrusadeMode == TRUE) return; 
if ((m_stHeldenianSchedule[i].iDay != SysTime.wDayOfWeek) && 
(m_stHeldenianSchedule[i].StartiHour != SysTime.wHour) && 
(m_stHeldenianSchedule[i].StartiMinute != SysTime.wMinute)) { 
wsprintf(G_cTxt,"Heldenian Start : time(%d %d:%d), index(%d)",SysTime.wDayOfWeek, SysTime.wHour, SysTime.wMinute, i); 
PutLogList(G_cTxt); 
PutLogFileList(G_cTxt); 
var_8A0 = TRUE; 
GlobalStartHeldenianMode(); 
} 
} 
void CGame::HeldenianWarEnder() 
{} 

void CGame::GlobalStartHeldenianMode() 
{ 
char cData[120], * cp; 
DWORD dwTime, * dwp; 
WORD * wp; 
if (m_cHeldenianModeType == 1)m_dwHeldenianWTime = timeGetTime()+45*60*1000;
else m_dwHeldenianWTime = timeGetTime()+30*60*1000;
dwTime = timeGetTime(); 
ZeroMemory(cData,sizeof(cData)); 

cp = (char *)cData; 
*cp = GSM_STARTHELDENIAN; // 21 
cp++; 

wp = (WORD *)cp; 
*wp = m_cHeldenianModeType; 
cp += 2; 

wp = (WORD *)cp; 
*wp = m_sLastHeldenianWinner; 
cp += 2; 

dwp = (DWORD *)cp; 
*dwp = dwTime; 
cp += 4; 

bStockMsgToGateServer(cData, 9); 
LocalStartHeldenianMode(m_cHeldenianModeType, m_sLastHeldenianWinner, dwTime); 

} 

void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID) 
{ 
int i, x, iNamingValue; 
char cName[11], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType; 
short sOwnerH; 
BOOL bRet; 
int dX, dY; 
if (m_bIsHeldenianMode == TRUE) return; 
m_cHeldenianModeType = sV1; 
m_sLastHeldenianWinner = sV2; 
m_cHeldenianWinner = 0; 
bHeldenianFight = FALSE; 
m_dwHeldenianFTime = timeGetTime() + 5*60*1000;

m_iHeldenianAresdenLeftTower = 46; 
m_iHeldenianElvineLeftTower = 46; 
m_iHeldenianAresdenDead = 0; 
m_iHeldenianElvineDead = 0; 
m_dwHeldenianGUID = dwHeldenianGUID; 
CreateHeldenianGUID(m_dwHeldenianGUID, m_sLastHeldenianWinner); 


	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	if (m_pClientList[i]->m_bIsInitComplete != TRUE) break;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANTELEPORT,  NULL , NULL, NULL, NULL); // You can now, go to the battle field
			m_pClientList[i]->m_dwHeldenianGUID    = m_dwHeldenianGUID;				
			m_pClientList[i]->m_iWarContribution   = 0;
			m_pClientList[i]->m_iConstructionPoint = m_pClientList[i]->m_iCharisma * 300;
			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXHELDENIANSUMMONPOINT) m_pClientList[i]->m_iConstructionPoint = DEF_MAXHELDENIANSUMMONPOINT;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, NULL); //0: Tell player of acquired points
			bUpdateHeldenianStatus(i);
	}	}
	// Recall clients already on battlefield; remove any Heldenian mob, and create current war towers/gates
	for (x = 0; x < DEF_MAXMAPS; x++) 
	{	if (m_pMapList[x] == NULL) break;
		if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) 
		{	RemoveOccupyFlags(x);
			for (i = 0; i < DEF_MAXCLIENTS; i++) // Tell everybody on Heldenian map and recall them
			{	if (   (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) 
					&& (m_pClientList[i]->m_cMapIndex == x)	)
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ", NULL, -1, -1);
			}	}
			for (i = 0; i < DEF_MAXNPCS; i++) // Remove summons from last Heldenian
			{	if (   (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_bIsKilled == FALSE) 
					&& (m_pNpcList[i]->m_cMapIndex == x))
				{	if (m_pNpcList[i]->m_bIsSummoned == TRUE) 
					{	NpcKilledHandler(NULL, NULL, i, NULL,FALSE);
					}else
					{	// Remove most mobs, and other Mobs become neutral
						// All mobs become neutral as players don't have spells or attacks...
                           	m_pNpcList[i]->m_bIsUnsummoned = TRUE; 	
							NpcKilledHandler(i, DEF_OWNERTYPE_NPC, i, 0,FALSE);
							DeleteNpc(i,FALSE);
						 
			}	}	}		
			if (m_cHeldenianModeType == 1)
							{	
					if (strcmp(m_pMapList[x]->m_cName, "BtField") == 0)  { 
						CreateHeldenianStructures();
						CreateHeldenianStructures1();
wsprintf(G_cTxt,"HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower); 
PutLogList(G_cTxt); 
bUpdateHeldenianStatus(-1);

 
} 
}else if (m_cHeldenianModeType == 2) 
{ // Set master flag 
if (strcmp(m_pMapList[x]->m_cName, "GodH") == 0) // if (m_iGodHMapIndex == x) 
{ __bSetOccupyFlag(x, m_pMapList[x]->m_sHeldenianWinningZoneX, m_pMapList[x]->m_sHeldenianWinningZoneY, m_sLastHeldenianWinner, 616, 0, TRUE); 
bHeldenianFight = FALSE;
} 
// Set Gates 
if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) 
{ for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) 
{ if (m_pMapList[x]->m_stHeldenianGateDoor[i].dX < 1) break; 
iNamingValue = m_pMapList[x]->iGetEmptyNamingValue(); 
if (iNamingValue != -1) 
{ dX = m_pMapList[x]->m_stHeldenianGateDoor[i].dX; 
dY = m_pMapList[x]->m_stHeldenianGateDoor[i].dY; 
ZeroMemory(cTmp, sizeof(cTmp)); 
if (m_sLastHeldenianWinner == 1) strcpy(cTmp, "gate-a"); 
else strcpy(cTmp, "gate-e"); 
cSide = m_sLastHeldenianWinner; 
ZeroMemory(cName, sizeof(cName)); 
wsprintf(cName, "XX%d", iNamingValue); 
cName[0] = 95; 
cName[1] = i + 65; 
//bRet = iCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, 0, (rand() % 255), DEF_MOVETYPE_GUARD, &dX, &dY, cNpcWaypointIndex, NULL, NULL, m_sLastHeldenianWinner, FALSE, FALSE); 
bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, m_sLastHeldenianWinner, FALSE, FALSE, FALSE, FALSE, NULL); 

if (bRet == FALSE) 

{ m_pMapList[x]->SetNamingValueEmpty(iNamingValue); 
}else 
{ m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); 
if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) 
{ m_pNpcList[sOwnerH]->m_iBuildCount = 0; 
m_pNpcList[sOwnerH]->m_cSide = cSide; 
m_pNpcList[sOwnerH]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[i].cDir; 
wsprintf(G_cTxt,"(_) Gate installed at %d,%d", dX, dY); 
PutLogList(G_cTxt); 


} } } } } } } } 
m_bIsHeldenianMode = TRUE; 
wsprintf(G_cTxt,"(_) Heldenian mode ON. (type %d, last winner:%d)", m_cHeldenianModeType, m_sLastHeldenianWinner); 
PutLogList(G_cTxt); 
PutLogList(" "); 

} 


void CGame::ManualStartHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize) 
{char cBuff[256], * token, seps[] = "= \t\n"; 
class CStrTok * pStrTok; 
if (m_bIsHeldenianMode == TRUE) return; 
if (m_bIsApocalypseMode == TRUE) return; 
if (m_bIsCrusadeMode == TRUE) return; 
if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) 
SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 

ZeroMemory(cBuff, sizeof(cBuff)); 
memcpy(cBuff, pData, dwMsgSize); 
pStrTok = new class CStrTok(cBuff, seps); 
token = pStrTok->pGet(); 
token = pStrTok->pGet(); 

if (token != NULL) 
{ 
if (token[0] == '1') 
{ 
m_cHeldenianModeType = 1;
//ShowClientMsg(iClientH, " Heldenian Type 1 Started!"); 
bUpdateHeldenianStatus(-1); 
} 
else if (token[0] == '2') 
{ 
m_cHeldenianModeType = 2; 
//ShowClientMsg(iClientH, " Heldenian Type 2 Started!"); 
bUpdateHeldenianStatus(-1); 
} 
} 

delete pStrTok; 
wsprintf(G_cTxt,"Admin Order(%s): begin Heldenian", m_pClientList[iClientH]->m_cCharName); 
PutLogList(G_cTxt); 
GlobalStartHeldenianMode(); 
} 
void CGame::ManualEndHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize) 
{char seps[] = "= \t\n"; 
char * token, cBuff[256]; 
class CStrTok * pStrTok; 
if ((dwMsgSize) <= 0) return; 
if (iClientH == NULL) return; 
if (m_bIsHeldenianMode == FALSE) return; 
if (m_pClientList[iClientH] == NULL) return; 
if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) { 
SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
return; 
} 

ZeroMemory(cBuff, sizeof(cBuff)); 
memcpy(cBuff, pData, dwMsgSize); 
pStrTok = new class CStrTok(cBuff, seps); 
token = pStrTok->pGet(); 
token = pStrTok->pGet(); 
if (token == NULL) // draw 
{ m_cHeldenianWinner = 0; 
wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName); 
}else if (token != NULL) 
{ if (_bGetIsStringIsNumber(token) == TRUE) 
{ switch(atoi(token)) { 
case 1: 
m_cHeldenianWinner = 1; 
wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Aresden victory", m_pClientList[iClientH]->m_cCharName); 
break; 
case 2: 
m_cHeldenianWinner = 2; 
wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Elvine victory", m_pClientList[iClientH]->m_cCharName); 
break; 
default: 
m_cHeldenianWinner = 0; 
wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName); 
break; 
} 
}else 
{ m_cHeldenianWinner = 0; 
wsprintf(G_cTxt,"GM Order(%s): Heldenian terminated, Draw", m_pClientList[iClientH]->m_cCharName); 
} 
} 
PutLogList(G_cTxt); 
GlobalEndHeldenianMode(); 
delete pStrTok; 
} 
void CGame::AutomatedHeldenianTimer() 
{ 
DWORD dwTime; 
int x, i; 

dwTime = time(NULL); 
if ((dwTime == m_dwHeldenianStartTime - 300) && (m_bHeldenianInitiated != TRUE) && (m_bIsHeldenianMode != TRUE)) { 
wsprintf(G_cTxt,"Heldenian Fight Start"); 
PutLogFileList(G_cTxt); 
m_bIsHeldenianMode = FALSE; 
for (x = 0; x < DEF_MAXMAPS; x++) { 
if (m_pMapList[x] == NULL) return; 
if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) return; 
for (i = 0; i < DEF_MAXCLIENTS; i++) { 
if (m_pClientList[i] != NULL) { 
if (m_pClientList[i]->m_bIsInitComplete != TRUE) return; 
if (m_pClientList[i]->m_cMapIndex == x) { 
SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANSTART, NULL , NULL, NULL, NULL); 
} 
} 
} 
} 
} 
if ((dwTime > (m_dwHeldenianFinishTime - 180)) && (m_bHeldenianInitiated == TRUE) && (m_bIsHeldenianMode != FALSE)) { 
wsprintf(G_cTxt,"Heldenian Fight End"); 
PutLogFileList(G_cTxt); 
m_bHeldenianInitiated = FALSE; 
for (x = 0; x < DEF_MAXMAPS; x++) { 
if (m_pMapList[x] == NULL) return; 
if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) return; 
for (i = 0; i < DEF_MAXCLIENTS; i++) { 
if (m_pClientList[i] != NULL) { 
if (m_pClientList[i]->m_bIsInitComplete != TRUE) return; 
if (m_pClientList[i]->m_cMapIndex == x) { 
SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL); 
RequestTeleportHandler(i, "1 ", NULL, -1, -1); 
} 
} 
} 
} 
} 
} 

void CGame::SetHeldenianMode() 
{ 
SYSTEMTIME SysTime; 

GetLocalTime(&SysTime); 
m_dwHeldenianStartHour = SysTime.wHour; 
m_dwHeldenianStartMinute = SysTime.wMinute; 

if (m_cHeldenianModeType != 2) { 
m_cHeldenianVictoryType = m_cHeldenianWinner; 
} 
} 

void CGame::NotifyStartHeldenianMode() 
{ 
register int i, x; 

if (m_bIsHeldenianMode == TRUE) return; 
if (m_bHeldenianInitiated == TRUE) return; 
if (var_88C != TRUE) { 
PutLogList("Heldenian Fight Start"); 
m_bHeldenianInitiated = FALSE; 
for (i = 0; i < DEF_MAXMAPS; i++) { 
if (m_pMapList[i] == NULL) return; 
if (m_pMapList[i]->m_bIsHeldenianMap != TRUE) return; 
for (x = 0; x < DEF_MAXCLIENTS; x++) { 
if (m_pClientList[x] == NULL) return; 
if (m_pClientList[x]->m_bIsInitComplete != TRUE) return; 
if (m_pClientList[x]->m_cMapIndex == i) { 
SendNotifyMsg(NULL, x, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL); 
} 
} 
} 
} 
} 

void CGame::HeldenianEndWarNow() 
{ if (m_bIsHeldenianMode == FALSE) return; 
DWORD dwTime = timeGetTime(); 
if (dwTime < m_dwHeldenianFinishTime) return; 
if (m_cHeldenianModeType == 1) 
{ if (m_iBTFieldMapIndex == -1) return; 
// Type 1: BtField, victory depends on Tower destroyed... 
if (m_cHeldenianWinner == -1) 
{ if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) 
{ m_cHeldenianWinner = 1; 
}else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) 
{ m_cHeldenianWinner = 2; 
}else if (m_iHeldenianAresdenFlags < m_iHeldenianElvineFlags) 
{ m_cHeldenianWinner = 1; 
}else if (m_iHeldenianAresdenFlags > m_iHeldenianElvineFlags) 
{ m_cHeldenianWinner = 2; 

} } 
}else if (m_cHeldenianModeType == 2) 
{ if (m_iGodHMapIndex == -1) return; 
// Type 2: Victory for defenders if no victory before 
if (m_cHeldenianWinner == -1) 
{ m_cHeldenianWinner = m_sLastHeldenianWinner; 
} } 
bSendMsgToLS(MSGID_REQUEST_HELDENIAN_WINNER, NULL, 1, NULL); 
switch(m_cHeldenianWinner) { 
case 1: 
wsprintf(G_cTxt, "Heldenian Terminated, Aresden victory."); 
_bCrusadeLog(MSGID_REQUEST_HELDENIAN_WINNER, NULL, (int)m_cHeldenianModeType , "Aresden victory."); 
break; 
case 2: 
wsprintf(G_cTxt, "Heldenian Terminated, Elvine victory."); 
_bCrusadeLog(MSGID_REQUEST_HELDENIAN_WINNER, NULL, (int)m_cHeldenianModeType , "Elvine victory."); 
break; 
default: 
wsprintf(G_cTxt, "Heldenian Terminated, Draw."); 
_bCrusadeLog(MSGID_REQUEST_HELDENIAN_WINNER, NULL, (int)m_cHeldenianModeType , "Draw."); 
break; 
} 

PutLogList(G_cTxt); 
GlobalEndHeldenianMode(); 
} 


void CGame::RemoveHeldenianNpc(int iNpcH) 
{ 
if (m_pNpcList[iNpcH] == NULL) return; 
if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return; 

m_pNpcList[iNpcH]->m_bIsKilled = TRUE; 
m_pNpcList[iNpcH]->m_iHP = 0; 
m_pNpcList[iNpcH]->m_iLastDamage = 0; 
m_pNpcList[iNpcH]->m_dwRegenTime = 0; 
m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--; 

ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC); 
m_pNpcList[iNpcH]->m_iTargetIndex = 0; 
m_pNpcList[iNpcH]->m_cTargetType = 0; 

SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, NULL, 1, NULL); 
m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY); 
m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY); 
m_pNpcList[iNpcH]->m_cBehavior = 4; 
m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0; 
m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime(); 

} 

void CGame::CreateHeldenianGUID(DWORD dwHeldenianGUID, int iWinnerSide) 
{ 
char * cp, cTxt[256], cFn[256], cTemp[1024]; 
FILE * pFile; 

_mkdir("GameData"); 
ZeroMemory(cFn, sizeof(cFn)); 
strcat(cFn,"GameData"); 
strcat(cFn,"\\"); 
strcat(cFn,"\\"); 
strcat(cFn,"HeldenianGUID.Txt"); 

pFile = fopen(cFn, "wt"); 
if (pFile == NULL) { 
wsprintf(cTxt, "(!) Cannot create HeldenianGUID(%d) file", dwHeldenianGUID); 
PutLogList(cTxt); 
} 
else { 
ZeroMemory(cTemp, sizeof(cTemp)); 

ZeroMemory(cTxt, sizeof(cTxt)); 
wsprintf(cTxt, "HeldenianGUID = %d\n", dwHeldenianGUID); 
strcat(cTemp, cTxt); 

ZeroMemory(cTxt, sizeof(cTxt)); 
wsprintf(cTxt, "winner-side = %d\n", iWinnerSide); 
strcat(cTemp, cTxt); 

cp = (char *)cTemp; 
fwrite(cp, strlen(cp), 1, pFile); 

wsprintf(G_cTxt, "(_) HeldenianGUID (%d) file created. (Winner %d)", dwHeldenianGUID, iWinnerSide); 
PutLogList(G_cTxt); 
} 
if (pFile != NULL) fclose(pFile); 
} 

//*************************************************************
void CGame::HeldenianVictoryNow(int iSide) 
{ if (bHeldenianFight == TRUE) return; 
DWORD dwTime = timeGetTime(); 
m_bHeldenianInitiated = TRUE; 
m_cHeldenianWinner = iSide; 
switch(m_cHeldenianWinner) { 
case 1: 
wsprintf(G_cTxt, "Aresden victory."); 
_bCrusadeLog(MSGID_REQUEST_HELDENIAN_WINNER, NULL, (int)m_cHeldenianModeType, "Aresden victory."); 
break; 
case 2: 
wsprintf(G_cTxt, "Elvine victory."); 
_bCrusadeLog(MSGID_REQUEST_HELDENIAN_WINNER, NULL, (int)m_cHeldenianModeType, "Elvine victory."); 
break; 
default: 
wsprintf(G_cTxt, "Draw."); 
_bCrusadeLog(MSGID_REQUEST_HELDENIAN_WINNER, NULL, (int)m_cHeldenianModeType, "Draw."); 
break; 
} 
PutLogList(G_cTxt); 


m_dwHeldenianFinishTime = timeGetTime() + 1*60; // war will end in 5 minutes 
int m; 
register int j, n; 
for (m = 0; m < DEF_MAXMAPS; m++) 
{ if (m_pMapList[m] == NULL) break; 
if (m_pMapList[m]->m_bIsHeldenianMap == TRUE) 
{ for (j = 0; j < DEF_MAXCLIENTS; j++) 
{ if ( (m_pClientList[j] != NULL) 
&& (m_pClientList[j]->m_bIsInitComplete == TRUE) 
&& (m_pClientList[j]->m_cMapIndex == m)) 
{ bUpdateHeldenianStatus(j); 
SendNotifyMsg(NULL, j, DEF_NOTIFY_HELDENIANEND, m_cHeldenianWinner, NULL, NULL, NULL); // Victory defeat screen 
if ( (m_pClientList[j]->m_cSide != iSide)// recall loosers only 
&& (m_pClientList[j]->m_iAdminUserLevel == 0)) 
{ SendNotifyMsg(NULL, j, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL); 
m_pClientList[j]->m_bIsWarLocation = TRUE; 
m_pClientList[j]->m_iTimeLeft_ForceRecall = 3; 
//RequestTeleportHandler(j, "1 ", NULL, -1, -1); 
} } } 
for (n = 0; n < DEF_MAXNPCS; n++) 
{ if ( (m_pNpcList[n] != NULL) 
&& (m_pNpcList[n]->m_cMapIndex == m) 
&& (m_pNpcList[n]->m_cSide != iSide)) 
{ if (m_pNpcList[n]->m_bIsSummoned == TRUE) 
{ NpcKilledHandler(NULL, NULL, n, NULL); 
}else 
{ m_pNpcList[n]->m_cSide = 0; // All mobs become neutral as players no more have spells or attacks... 
} } } } 
} 

CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianWinner); 
} 
BOOL CGame::bUpdateHeldenianStatus(int iClientH)
{
 register int i;
 BOOL bFlag;
 int iShortCutIndex;
	if (m_bIsHeldenianMode != TRUE) return FALSE;
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		if (m_pMapList[i]->m_bIsHeldenianMap == TRUE) {
			bFlag = TRUE;
			iShortCutIndex = 0;
		}
		while (bFlag == TRUE) {
			iClientH = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (iClientH == 0) {
				bFlag = 0;
			}
			else {

				if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "BtField") == 0)) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenDead, NULL, m_iHeldenianElvineDead, NULL);
				}
			}
		}
	}
	return TRUE;
}
BOOL CGame::bReadHeldenianGUIDFile(char * cFn) 
{ 
FILE * pFile; 
HANDLE hFile; 
DWORD dwFileSize; 
char * cp, * token, cReadMode; 
char seps[] = "= \t\n"; 
class CStrTok * pStrTok; 

cReadMode = 0; 

hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
dwFileSize = GetFileSize(hFile, NULL); 
if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); 

pFile = fopen(cFn, "rt"); 
if (pFile == NULL) { 
PutLogList("(!) Cannot open HeldenianGUID file."); 
return FALSE; 
} 
else { 
PutLogList("(!) Reading HeldenianGUID file..."); 
cp = new char[dwFileSize+2]; 
ZeroMemory(cp, dwFileSize+2); 
fread(cp, dwFileSize, 1, pFile); 

pStrTok = new class CStrTok(cp, seps); 
token = pStrTok->pGet(); 

while( token != NULL ) { 

if (cReadMode != 0) { 
switch (cReadMode) { 
case 1: 
m_dwHeldenianGUID = atoi(token); 
wsprintf(G_cTxt, "(!) HeldenianGUID = %d", m_dwHeldenianGUID); 
PutLogList(G_cTxt); 
cReadMode = 0; 
break; 

case 2: 
// New 13/05/2004 Changed 
m_sLastHeldenianWinner = atoi(token); 
wsprintf(G_cTxt, "(!) HeldenianWinnerSide = %d", m_sLastHeldenianWinner); 
PutLogList(G_cTxt); 
cReadMode = 0; 
break; 
} 
} 
else { 
if (memcmp(token, "HeldenianGUID", 11) == 0) cReadMode = 1; 
if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2; 
} 

token = pStrTok->pGet(); 
} 

delete pStrTok; 
delete []cp; 
} 
if (pFile != NULL) fclose(pFile); 

return TRUE; 
} 


BOOL CGame::bNotifyHeldenianWinner() 
{ 
if (var_88C == 0) { 
bSendMsgToLS(MSGID_REQUEST_HELDENIAN_WINNER, NULL, 1, NULL); 
return TRUE; 
} 
else { 
return FALSE; 
} 

} 



BOOL CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType) 
{
 short tX, tY;
 int iRet;
 class CTile * pTile;

	iRet = 0;
	if (m_pClientList[sAttackerH] == NULL) return 0;
	if ((m_bIsHeldenianMode == 1) || (m_cHeldenianModeType == 1)) {
		if (cType == DEF_OWNERTYPE_PLAYER) {
			if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != NULL) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				tX = m_pClientList[sAttackerH]->m_sX;
				tY = m_pClientList[sAttackerH]->m_sY;
				if ((tX < 0) || (tX >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeX) || 
					(tY < 0) || (tY >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY)) return 0;
				pTile = (class CTile *)(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY*m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == NULL) return 0;
				if (pTile->m_iOccupyStatus != NULL) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		} 
		else if (cType == DEF_OWNERTYPE_NPC) {
			if ((m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex] != NULL) && (iMapIndex != -1) && (m_pNpcList[sAttackerH]->m_cSide > 0)) {
				tX = m_pNpcList[sAttackerH]->m_sX;
				tY = m_pNpcList[sAttackerH]->m_sY;
				pTile = (class CTile *)(m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY*m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == NULL) return 0;
				if (pTile->m_iOccupyStatus != NULL) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		}
	}
	return iRet;
}

//Ovl 02:14 23/01/07
void CGame::HeldenianFight(int iClientH)
{ 
	bHeldenianFight = TRUE;
	if (m_bIsHeldenianMode == FALSE) return;
	char cData[120], * cp; 
	int * ip,j; 
	for (j = 0; j < DEF_MAXCLIENTS; j++) {
		if ( (m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE)) {
			ZeroMemory(cData,sizeof(cData)); 

			cp = (char *)cData; 
			*cp = GSM_STARTHELDENIANFIGHT; 
			cp++; 

			ip = (int*)cp;
			*ip = bHeldenianFight;
			cp += 4;

			bStockMsgToGateServer(cData, 5); 
			SendNotifyMsg(NULL, j, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
		}
	}
}
void CGame::LimpiarNpcHeldenian(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) {
			switch(m_pNpcList[i]->m_sType) {
			case 15:
			case 19:
			case 20:
			case 24:
			case 25:
			case 26:
			case 67:
			case 68:
			case 69:
			case 90:
			break;

			default:
				NpcKilledHandler(NULL, NULL, i, NULL);
				break;
			}
		}
	}
}

void CGame::RequestNpcSpeakTeleport(int iClientH, char * pData, DWORD dwMsgSize)
{
	short tX = -1, tY = -1; 
	char cMapName[11], *cp, cV1;

	if ((m_bIsHeldenianMode == FALSE)&&(m_bCityWar == FALSE))return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cV1 = (char)cp;
	cp += 4;

	ZeroMemory(cMapName, sizeof(cMapName));
 
	switch (m_pClientList[iClientH]->m_cSide)
	{
		case 0:
		if (m_cHeldenianModeType == 1) {
			RequestTeleportHandler(iClientH, "2   ", "BtField", 68, 225);
			break;
		}
		else
		{
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner)
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 81, 42);
				break;
			} 
			else 
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 156, 153);
				break;
			}
		}
		case 1:
		if (m_pClientList[iClientH]->m_iLevel < 150) return; //kr4usser fix. Lvls menores no entran para no dar frags.
		if(m_bCityWar == TRUE)
		{	
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner)
			{ 
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 156, 155);
				break;
			}
			else
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 156, 153); 
				break;
			}

		}
			
		if (m_cHeldenianModeType == 1)
		{
			RequestTeleportHandler(iClientH, "2   ", "BtField", 68, 225);
			break;
		}
		else
		{
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner)
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 81, 42);
				break;
			} 
			else
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 156, 153); 
				break;
			}
		}	
 

		case 2:

		if (m_pClientList[iClientH]->m_iLevel < 150) return; // krausser fix. Lvls menores no entran para no dar frags.
		if(m_bCityWar == TRUE)
		{	
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner)
			{ 
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 156, 155);
				break;
			}
			else
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 156, 153); 
				break;
			}
		}
		if (m_cHeldenianModeType == 1)
		{
			RequestTeleportHandler(iClientH, "2   ", "BtField", 202, 70); break;
		}
		else
		{
			if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner)
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 81, 42); break;
			} 
			else
			{
				RequestTeleportHandler(iClientH, "2   ", "HRampart", 156, 153); break;
			}
		}
	}
}



BOOL CGame::bDecodeTeleportList(char *pFn)
{FILE * pFile;
HANDLE hFile;
DWORD  dwFileSize;
char * cp, * token, cReadModeA, cReadModeB;
char seps[] = "= \t\n";
class CStrTok * pStrTok;
int   iIndex;
int iTeleportConfigListIndex; 
for (int i = 0; i <  DEF_MAXTELEPORTLIST; i++)
if (m_pTeleportConfigList[i] != NULL) 
{ delete m_pTeleportConfigList[i];
 m_pTeleportConfigList[i] = NULL;
}
cReadModeA = 0;
cReadModeB = 0;
iIndex = 0;
hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
dwFileSize = GetFileSize(hFile, NULL);
if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
pFile = fopen(pFn, "rt");
if (pFile == NULL)
{ PutLogList("(!) Cannot open Teleport.cfg file.");
 return FALSE;
}else
{ PutLogList("(!) Reading TeleportList.cfg...");
 cp = new char[dwFileSize+2];
 ZeroMemory(cp, dwFileSize+2);
 fread(cp, dwFileSize, 1, pFile);
 pStrTok = new class CStrTok(cp, seps);
 token = pStrTok->pGet();
 while( token != NULL ) 
 { if (cReadModeA != 0) 
  { switch (cReadModeA) {
   case 1:
    switch (cReadModeB) {
    case 1: // Teleport n
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
      delete pStrTok; delete cp; return FALSE;
     }
     iTeleportConfigListIndex = atoi(token);
     if ((iTeleportConfigListIndex < 0) || (iTeleportConfigListIndex >= DEF_MAXTELEPORTLIST))
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong TeleportList number.");
      return FALSE;
     }
     if (m_pTeleportConfigList[iTeleportConfigListIndex] != NULL)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Duplicate TeleportList number.");
      return FALSE;
     }
     m_pTeleportConfigList[iTeleportConfigListIndex] = new class CTeleport;
     cReadModeB = 2;
     break;
    case 2: // NPC name
     memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cNpcName, token, strlen(token));
     cReadModeB = 3;
     break;
    case 3: // SOURCE MAP
     memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cSourceMap, token, strlen(token));
     cReadModeB = 4;
     break;
    case 4: // TARGET MAP
     memcpy(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cTargetMap, token, strlen(token));
     cReadModeB = 5;
      break;
    case 5: // TARGET MAP X
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - X - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     m_pTeleportConfigList[iTeleportConfigListIndex]->m_iX = atoi(token);
     cReadModeB = 6;
     break;
    case 6: // TARGET MAP Y
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Y - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     m_pTeleportConfigList[iTeleportConfigListIndex]->m_iY = atoi(token);
     cReadModeB = 7;
     break;
    case 7: // COST
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Cost - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     m_pTeleportConfigList[iTeleportConfigListIndex]->m_iCost = atoi(token);
     cReadModeB = 8;
     break;
    case 8: // Minimum Level
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - MinLvl - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMinLvl = atoi(token);
     cReadModeB = 9;
     break;
    case 9: // Maximum Level
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - MaxLvl- Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMaxLvl = atoi(token);
     cReadModeB = 10;
     break;
    case 10: // Side (aresden, elvein)
     if( memcmp(token, "aresden", 7) == 0 )
     { m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 1;
     }else if( memcmp(token, "elvine", 6) == 0 )
     { m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 2;
     }else if( memcmp(token, "both", 4) == 0 )
     { m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 12;
     }else if( memcmp(token, "evil", 4) == 0 )
     { m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 4;
     }else if( memcmp(token, "all", 3) == 0 )
     { m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 124;
     }else if( memcmp(token, "heldenian", 9) == 0 )
     { m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 66;
     }else
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Side - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     cReadModeB = 11;
     break;
    case 11: // HuntMode (0,1)
     if (_bGetIsStringIsNumber(token) == FALSE) {
      PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Hunter - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     if( memcmp(token,"0",1) == 0 )
      m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = FALSE;
     else if( memcmp(token,"1",1) == 0 )
      m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = TRUE;
     else
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Hunter - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     cReadModeB = 12;
     break;
    case 12: // Netural (0,1)
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Neutral - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     if( memcmp(token,"0",1) == 0 )
      m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = FALSE;
     else if( memcmp(token,"1",1) == 0 )
      m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = TRUE;
     else
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Neutral - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     cReadModeB = 13;
     break;
    case 13: // Criminal (0,1)
     if (_bGetIsStringIsNumber(token) == FALSE)
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Crim - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     if ( memcmp(token,"0",1) == 0 )
      m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = FALSE;
     else if( memcmp(token,"1",1) == 0 )
      m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = TRUE;
     else
     { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Crim - Wrong Data format.");
      delete cp; delete pStrTok; return FALSE;
     }
     cReadModeA = 0;
     cReadModeB = 0;
     break;
    }
    break;
   default:
    break;
   }
  }else
  { if (memcmp(token, "teleport", 8) == 0)
   { cReadModeA = 1;
    cReadModeB = 1;
   }else if (memcmp(token, "[END]", 5) == 0)
   { cReadModeA = 0;
    cReadModeB = 0;
    break; // Stop While Loop
   }
  }
  token = pStrTok->pGet();
 } // while
 delete pStrTok; delete []cp;
 if ((cReadModeA != 0) || (cReadModeB != 0)||(iTeleportConfigListIndex < 0)||(iTeleportConfigListIndex >= DEF_MAXTELEPORTLIST))
 { PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file contents error!");
  return FALSE;
 }
 if (pFile != NULL) fclose(pFile);
 wsprintf(G_cTxt, "(!) TELEPORT-LIST(Total:%d) configuration - success!", iTeleportConfigListIndex);
 PutLogList(G_cTxt);
 return TRUE;
}
}

// RequestTeleportListHandler
void CGame::RequestTeleportListHandler(int iClientH, char * pData, DWORD dwMsgSize)
{ if (m_pClientList[iClientH] == NULL) return;
if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) 
{ SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
 return;
}
char *cp, cData[512];
int  iRet;
DWORD *dwp;
WORD *wp;
int  *listCount;
char cNpcName[21];
int  *ip;
cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
ZeroMemory(cNpcName, sizeof(cNpcName));
strncpy(cNpcName, cp, 20);
cp += 20;
ZeroMemory(cData, sizeof(cData));
dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
*dwp = MSGID_RESPONSE_TELEPORT_LIST;
wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
*wp  = DEF_MSGTYPE_CONFIRM;
cp = cData + 6;
listCount = (int*) cp; 
*listCount = 0;
cp += 4; // sizeof(int)
int  index;
for(index = 0; index < DEF_MAXTELEPORTLIST; index++)
{ if( m_pTeleportConfigList[index] == NULL )
  continue;
 if( strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
  continue;
 if( strncmp( m_pTeleportConfigList[index]->m_cNpcName, cNpcName, 20) != 0 )
  continue;
 if(    (m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel)
  || (m_pTeleportConfigList[index]->m_iMaxLvl <= m_pClientList[iClientH]->m_iLevel))
  continue;
 if (   (m_pTeleportConfigList[index]->m_bHunter == FALSE)
  && (m_pClientList[iClientH]->m_bIsHunter == TRUE))
  continue;
 if (   (m_pTeleportConfigList[index]->m_bNetural == FALSE)
  && (m_pClientList[iClientH]->m_cSide == 0))
  continue;
 if (   (m_pTeleportConfigList[index]->m_bCriminal == FALSE) 
  && (m_pClientList[iClientH]->m_iPKCount > 0 ))
  continue;
 // Side
 switch (m_pTeleportConfigList[index]->m_iSide) {
 default:
  break;
 case 1:
  if (m_pClientList[iClientH]->m_cSide == 1) goto LabelCorrrectTP;
  break;
 case 2:
  if (m_pClientList[iClientH]->m_cSide == 2) goto LabelCorrrectTP;
  break;
 case 4:
  if (m_pClientList[iClientH]->m_cSide == 4) goto LabelCorrrectTP;
  break;
 case 66: // For Heldenian winner...
  if (   (m_sLastHeldenianWinner ==  m_pClientList[iClientH]->m_cSide)
   && (m_pClientList[iClientH]->m_bIsHunter != TRUE) 
   && (m_bIsHeldenianMode == FALSE) )    goto LabelCorrrectTP;
  break;
 case 12:
  if (m_pClientList[iClientH]->m_cSide == 1) goto LabelCorrrectTP;
  if (m_pClientList[iClientH]->m_cSide == 2) goto LabelCorrrectTP;
  break;
 case 124:
  if (m_pClientList[iClientH]->m_cSide == 1) goto LabelCorrrectTP;
  if (m_pClientList[iClientH]->m_cSide == 2) goto LabelCorrrectTP;
  if (m_pClientList[iClientH]->m_cSide == 4) goto LabelCorrrectTP;
  break;
LabelCorrrectTP:; 
  ip = (int*) cp;
  *ip = index;
  cp += 4;
  memcpy(cp, m_pTeleportConfigList[index]->m_cTargetMap, 10);
  cp += 10;
  ip = (int*) cp;
  *ip = m_pTeleportConfigList[index]->m_iX;
  cp += 4;
  ip = (int*) cp;
  *ip = m_pTeleportConfigList[index]->m_iY;
  cp += 4;
  ip = (int*) cp;
  *ip = m_pTeleportConfigList[index]->m_iCost;
  cp += 4;
  (*listCount) ++;
 }
} // for
if ( (*listCount) == 0 )*wp  = DEF_MSGTYPE_REJECT;
// Teleport List
iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 26 );
switch (iRet) {
case DEF_XSOCKEVENT_QUENEFULL:
case DEF_XSOCKEVENT_SOCKETERROR:
case DEF_XSOCKEVENT_CRITICALERROR:
case DEF_XSOCKEVENT_SOCKETCLOSED:
 DeleteClient(iClientH, TRUE, TRUE);
 return;
}
} // RequestTeleportListHandler


void CGame::RequestChargedTeleportHandler(int iClientH, char *pData, DWORD dwMsgSize)
{ if (m_pClientList[iClientH] == NULL) return;
if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
char *cp, cData[64];
int  iRet;
DWORD *dwp;
WORD *wp;
int  index;
WORD wConfirm = DEF_MSGTYPE_CONFIRM;
short sError = 0;
// CHARGED_TELEPORT index
cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
index = (int) (*cp);
cp += 4;
if ((index < 0) || (index >= DEF_MAXTELEPORTLIST)) return;
if (m_pTeleportConfigList[index] == NULL )  return;
if (strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
 return;
if (   (m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel)
 || (m_pTeleportConfigList[index]->m_iMaxLvl <= m_pClientList[iClientH]->m_iLevel))
{ wConfirm = DEF_MSGTYPE_REJECT;
 sError = 1;
}
if (   (wConfirm == DEF_MSGTYPE_CONFIRM)
 && (m_pTeleportConfigList[index]->m_bHunter == FALSE)
 && (m_pClientList[iClientH]->m_bIsHunter == TRUE))
{ wConfirm = DEF_MSGTYPE_REJECT;
 sError = 2;
}
if (   (wConfirm == DEF_MSGTYPE_CONFIRM)
 && (m_pTeleportConfigList[index]->m_bNetural == FALSE)
 && (m_pClientList[iClientH]->m_cSide == 0))
{ wConfirm = DEF_MSGTYPE_REJECT;
 sError = 3;
}
if (   (wConfirm == DEF_MSGTYPE_CONFIRM)
 && (m_pTeleportConfigList[index]->m_bCriminal == FALSE)
 && (m_pClientList[iClientH]->m_iPKCount > 0 ))
{  wConfirm = DEF_MSGTYPE_REJECT;
 sError = 4;
}
if (wConfirm == DEF_MSGTYPE_CONFIRM )
{ switch (m_pTeleportConfigList[index]->m_iSide) {
 default:
  break;
 case 1:
 case 2:
 case 4:
  if (m_pClientList[iClientH]->m_cSide != m_pTeleportConfigList[index]->m_iSide)
  { wConfirm = DEF_MSGTYPE_REJECT;
   sError = 5;
  }
  break;
 case 12:
  if (m_pClientList[iClientH]->m_cSide > 2)
  { wConfirm = DEF_MSGTYPE_REJECT;
   sError = 5;
  }
  break;
 case 66: // For Heldenian winners only...
  if (   (m_sLastHeldenianWinner !=  m_pClientList[iClientH]->m_cSide)
   || (m_pClientList[iClientH]->m_bIsHunter == TRUE) 
   || (m_bIsHeldenianMode == TRUE) )
  { wConfirm = DEF_MSGTYPE_REJECT;
   sError = 7;
  }
  break;
 case 124:// Everybody
  break;
 }
}
if (wConfirm == DEF_MSGTYPE_CONFIRM )
{ DWORD dwGoldCount = dwGetItemCount(iClientH, "Gold");
 if( dwGoldCount >= m_pTeleportConfigList[index]->m_iCost )
 { int iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - m_pTeleportConfigList[index]->m_iCost);
  iCalcTotalWeight(iClientH);
  m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += m_pTeleportConfigList[index]->m_iCost;
 }else
 { wConfirm = DEF_MSGTYPE_REJECT;
  sError = 6;
 }
}
// Invalid Charged-teleport
if ( wConfirm == DEF_MSGTYPE_REJECT )
{ ZeroMemory(cData, sizeof(cData));
 dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 *dwp = MSGID_RESPONSE_CHARGED_TELEPORT;
 wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
 *wp  = wConfirm;
 cp = cData + DEF_INDEX2_MSGTYPE + 2;
 short *sp;
 sp = (short*) cp;
 *sp = sError;
 cp += 2;
 // Teleport List
 iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6 + 2 );
 switch (iRet) {
 case DEF_XSOCKEVENT_QUENEFULL:
 case DEF_XSOCKEVENT_SOCKETERROR:
 case DEF_XSOCKEVENT_CRITICALERROR:
 case DEF_XSOCKEVENT_SOCKETCLOSED:
  DeleteClient(iClientH, TRUE, TRUE);
  return;
 }
 return;
}
// teleport
RequestTeleportHandler(iClientH, "2   ",
 m_pTeleportConfigList[index]->m_cTargetMap,
 m_pTeleportConfigList[index]->m_iX,
 m_pTeleportConfigList[index]->m_iY);

}

BOOL CGame::bReadHeldenianStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 째쩌짯쨔철 짹창짯 쨩 쨩 쩌철 쩐첩쨈.
		PutLogList("(!) Cannot open Heldenian configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Heldenian configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						// 쩍쨘짰쨌째 쨔첩짙
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);

					/*	if (m_stHeldenianStructures[iIndex].cType != NULL) {
							// 쨔 쨈챌쨉 쨔첩짙째징 쨈. 쩔징쨌짱쨈.
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Duplicate portion number.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}*/
						
						cReadModeB = 2;
						break;

					case 2:
						// 쨍 쨍짠
						ZeroMemory(m_stHeldenianStructures[iIndex].cMapName, sizeof(m_stHeldenianStructures[iIndex].cMapName));
						memcpy(m_stHeldenianStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;

					
					case 3:
						// 쩐쨌첫
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stHeldenianStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						// 짠징
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stHeldenianStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						// 짠징
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stHeldenianStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				case 2:
					switch (cReadModeB) {
					case 1:
						// 쩍쨘짰쨌째 쨔첩짙
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);

					/*	if (m_stHeldenianStructures[iIndex].cType != NULL) {
							// 쨔 쨈챌쨉 쨔첩짙째징 쨈. 쩔징쨌짱쨈.
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Duplicate portion number.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}*/
						
						cReadModeB = 2;
						break;

					case 2:
						// 쨍 쨍짠
						ZeroMemory(m_stHeldenianStructuresx[iIndex].cMapName, sizeof(m_stHeldenianStructuresx[iIndex].cMapName));
						memcpy(m_stHeldenianStructuresx[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;

					
					case 3:
						// 쩐쨌첫
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stHeldenianStructuresx[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						// 짠징
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stHeldenianStructuresx[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						// 짠징
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stHeldenianStructuresx[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "crusade-structurs", 17) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			
			}
			token = pStrTok->pGet();
		}	

		delete pStrTok;
		delete []cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Heldenian Structure configuration file contents error!");
			return FALSE;
		}
	}
	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}



void CGame::CreateHeldenianStructures()
{
 int i, z, tX, tY, iNamingValue;
 char cName[6], cNpcName[21], cNpcWayPoint[11];
 short sOwnerH;
char cOwnerType;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	for (i = 0; i < MAX_HELDENIANTOWERARESDEN; i++) 
	if (m_stHeldenianStructures[i].cType != NULL) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stHeldenianStructures[i].cMapName) == 0)) {
			// 짠징째징 징쨈 쨍쩔징 째쨔째쨩 짠징쩍짼쨈.
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 쨈천쨩처  쨍쩔징 NPC쨍짝 쨍쨍쨉챕쩌철 쩐첩쨈. 쨍짠쨩 쨈챌 쩌철 쩐첩짹창 쨋짠쨔짰.
				// 쨌짹 ?
			}
			else {
				// NPC쨍짝 쨩첵쩌쨘쨈.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stHeldenianStructures[i].cType) {
				case 87:
						if (strcmp(m_pMapList[z]->m_cName, "BtField") == 0)
					    strcpy(cNpcName, "CT-Aresden");
						break;


				case 89: 
			    	if (strcmp(m_pMapList[z]->m_cName, "BtField") == 0)
					strcpy(cNpcName, "AGC-Aresden");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stHeldenianStructures[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stHeldenianStructures[i].dX;
				tY = (int)m_stHeldenianStructures[i].dY;

				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
					// 쩍쨍쨔쨌 쩔쨔쩐쨉 NameValue쨍짝 짝쩍짼쨈.
					m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					m_pMapList[z]->GetOwner(&sOwnerH, &cOwnerType, tX, tY); 
if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) { 
m_pNpcList[sOwnerH]->m_iBuildCount = 0; 
} 


					wsprintf(G_cTxt, "(!) Creating Heldenian Structure(%s) at %s(%d, %d)", cNpcName, m_stHeldenianStructures[i].cMapName, tX, tY);
					PutLogList(G_cTxt);

				}
			}
		}
	}
}

void CGame::CreateHeldenianStructures1()
{
 int i, z, tX, tY, iNamingValue;
 char cName[6], cNpcName[21], cNpcWayPoint[11];
 short sOwnerH;
char cOwnerType;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	for (i = 0; i < MAX_HELDENIANTOWERELVINE; i++) 
	if (m_stHeldenianStructuresx[i].cType != NULL) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stHeldenianStructuresx[i].cMapName) == 0)) {
			// 짠징째징 징쨈 쨍쩔징 째쨔째쨩 짠징쩍짼쨈.
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// 쨈천쨩처  쨍쩔징 NPC쨍짝 쨍쨍쨉챕쩌철 쩐첩쨈. 쨍짠쨩 쨈챌 쩌철 쩐첩짹창 쨋짠쨔짰.
				// 쨌짹 ?
			}
			else {
				// NPC쨍짝 쨩첵쩌쨘쨈.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stHeldenianStructuresx[i].cType) {
				case 87:
						if (strcmp(m_pMapList[z]->m_cName, "BtField") == 0)
					    strcpy(cNpcName, "CT-Elvine");
						break;


				case 89: 
			    	if (strcmp(m_pMapList[z]->m_cName, "BtField") == 0)
					strcpy(cNpcName, "AGC-Elvine");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stHeldenianStructuresx[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stHeldenianStructuresx[i].dX;
				tY = (int)m_stHeldenianStructuresx[i].dY;

				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
					// 쩍쨍쨔쨌 쩔쨔쩐쨉 NameValue쨍짝 짝쩍짼쨈.
					m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					m_pMapList[z]->GetOwner(&sOwnerH, &cOwnerType, tX, tY); 
if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) { 
m_pNpcList[sOwnerH]->m_iBuildCount = 0; 
} 
					wsprintf(G_cTxt, "(!) Creating Heldenian Structure(%s) at %s(%d, %d)", cNpcName, m_stHeldenianStructuresx[i].cMapName, tX, tY);
					PutLogList(G_cTxt);
				}
			}
		}
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 10) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "AresdenFlag"); break;
	case 2: strcpy(cItemName, "ElvineFlag");   break;
	}

	// ReqPurchaseItemHandler쩔징쩌짯 째징짰쩔 쨌챌쩐쨩 째챠쩍.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// 짹쨍째챠 쨈 쩐 쩐 쨍짰쩍쨘짰쨩처쩔징 쩐첩쨈. 짹쨍 쨘째징쨈쨈.
			delete pItem;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// 쩔징쨌짱 쨔챈철쩔챘 쨉책
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// 쩐쨩 쨔쨩 쩌철 쨈쨈 째 짰짚 쨉쩐첬쨍쨔쨌 EK 째짧쨩 쨩짤쨉쨉 쨉쨈.
				if (m_pClientList[iClientH]->m_iEnemyKillCount >= 10) {
					iEKNum = 10;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 10;
				}
								
				// EKNum쨩 쨌쨈.
				pItem->m_sItemSpecEffectValue1 = iEKNum;

				//testcode 쨌짹쩔징 짹창쨌쨈.
				wsprintf(G_cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, iEKNum, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// 쩐 쩐챵쩐첬쨈쨈 쨍쩍철쨍짝 체쩌쨈.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1째쨀 쨔쨉챈쨈.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // 쩐챵쨘 쩐쨔쨌 책첩쨉철 쩐쩐쨈.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				
				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item철 쩔짤쨘 
				cp++;
				*/
											
				if (iEraseReq == 1) delete pItem;
				
				// 쩐 짚쨘쨍 체쩌 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				
				// 쩌철째  쨌짰 챌 째챔쨩챗 
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 쨍쩍철쨍짝 쨘쨍쨀쩐쨋짠 쩔징쨌짱째징 쨔쨩첵쨈쨍챕 짝째쨈.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}

				// 쨘짱째챈쨉 쩔징쨀쨔 쨀쨩 쩐쨌쨈.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}
			else 
			{
				// 째첩째짙 쨘쨌 쩐쨩 쩐챵쨩 쩌철 쩐첩쨈.
				delete pItem;

				// 쩌철째  쨌짰 챌 째챔쨩챗 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// 쨍쩍철쨍짝 쨘쨍쨀쩐쨋짠 쩔징쨌짱째징 쨔쨩첵쨈쨍챕 짝째쨈.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

void CGame::LoteryHandler(int iClientH)
{
class  CItem * pItem;
int     iItemID;
if (m_pClientList[iClientH] == NULL) return;
if (m_pClientList[iClientH]->m_iAdminUserLevel > 0&&m_pClientList[iClientH]->m_iAdminUserLevel < 4) return;
switch (iDice(1,38)) {
case 1:iItemID=188;break;//SnakeMeat
case 2:iItemID=189;break;//SnakeSkin
case 3:iItemID=190;break;//SnakeTeeth
case 4:iItemID=191;break;//SnakeTongue
case 5:iItemID=192;break;//AntLeg
case 6:iItemID=193;break;//AntFeeler
case 7:iItemID=194;break;//CyclopsEye
case 8:iItemID=195;break;//CyclopsHandEdge
case 9:iItemID=196;break;//CyclopsHeart
case 10:iItemID=197;break;//CyclopsMeat
case 11:iItemID=198;break;//CyclopsLeather
case 12:iItemID=199;break;//HelboundHeart
case 13:iItemID=200;break;//HelboundLeather
case 14:iItemID=201;break;//HelboundTail
case 15:iItemID=202;break;//HelboundTeeth
case 16:iItemID=203;break;//HelboundClaw
case 17:iItemID=204;break;//HelboundTongue
case 18:iItemID=205;break;//LumpofClay
case 19:iItemID=206;break;//OrcMeat
case 20:iItemID=207;break;//OrcLeather
case 21:iItemID=208;break;//OrcTeeth
case 22:iItemID=209;break;//OgreHair
case 23:iItemID=210;break;//OgreHeart
case 24:iItemID=211;break;//OgreMeat
case 25:iItemID=212;break;//OgreLeather
case 26:iItemID=213;break;//OgreTeeth
case 27:iItemID=214;break;//OgreClaw
case 28:iItemID=215;break;//ScorpionPincers
case 29:iItemID=216;break;//ScorpionMeat
case 30:iItemID=217;break;//ScorpionSting
case 31:iItemID=218;break;//ScorpionSkin
case 32:iItemID=219;break;//SkeletonBones
case 33:iItemID=220;break;//SlimeJelly
case 34:iItemID=221;break;//StoneGolemPiece
case 35:iItemID=222;break;//TrollHeart
case 36:iItemID=223;break;//TrollMeat
case 37:iItemID=224;break;//TrollLeather
case 38:iItemID=225;break;//TrollClaw
}

//chance
if (iDice(1,120) <= 3) iItemID=650;//ZemstoneOfSacrifice
//chance

pItem = new class CItem;
if (_bInitItemAttr(pItem, iItemID) == FALSE) {
delete pItem;
}
else {
m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
m_pClientList[iClientH]->m_sY, pItem);
SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
}


}


void CGame::AdminOrder_Kill(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	class  CStrTok * pStrTok;
	register int i;
	int sAttackerWeapon, sDamage, iExH;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level 쨀쨌쩐쩌짯  짹창쨈쨩 쨩챌쩔챘 쩌철 쩐첩쨈.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, token, 10);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;
		// token 째챨 짚쨩 쨘째징쨈째 쨍쨍쨉챕 쨩챌쩔챘 쨍짠 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// 쨍챰짜 쨀쨍짱쨍짝 짙쩐쨈. 	

				m_pClientList[i]->m_iHP = 0;
				//if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = TRUE;

				if (m_pClientList[i]->m_bIsExchangeMode == TRUE) {
					iExH = m_pClientList[i]->m_iExchangeH;
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(i);
				}

				RemoveFromTarget(i, DEF_OWNERTYPE_PLAYER);

				SendNotifyMsg(NULL, i, DEF_NOTIFY_KILLED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
				// 짚쨩처 짠징쩔징쩌짯 철쩔챤쨈.
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(12, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				// 쨘 짠징 짜쩍쨍짝 쨈.
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				delete pStrTok;
				return;
			}

			// 철챌 짖쩌 쩐쨈쨈.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
} 

void CGame::AdminOrder_Revive(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	class  CStrTok * pStrTok;
	register int i;
	int sAttackerWeapon, sDamage, sHP;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user level 쨀쨌쩐쩌짯  짹창쨈쨩 쨩챌쩔챘 쩌철 쩐첩쨈.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);


	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, token, 10);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();

	if (token != NULL) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		sHP = atoi(token);
	} else {
		sHP = 1;
	}

	token = cName;
	//if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		// token 째챨 짚쨩 쨘째징쨈째 쨍쨍쨉챕 쨩챌쩔챘 쨍짠 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// 쨍챰짜 쨀쨍짱쨍짝 짙쩐쨈. 	

				m_pClientList[i]->m_iHP = sHP;
				if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = FALSE;
				m_pClientList[i]->m_iLastDamage = sDamage;
				//			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[i]->m_iLastDamage, NULL, NULL);
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, sDamage, sAttackerWeapon, NULL);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(14, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				delete pStrTok;
				return;
			}

			// 철챌 짖쩌 쩐쨈쨈.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
} 


void CGame::AdminOrder_GoTo(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) {
		memcpy(cPlayerName,token,10);
	}
	else{
		memcpy(cPlayerName,token,strlen(token));
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++){
		if (m_pClientList[i] != NULL) {
			if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName,10) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					if(m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sX == -1){
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)",m_pClientList[iClientH]->m_cCharName,m_pClientList[i]->m_cMapName);
					}
					else{
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName,
							     m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					}
	//				bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH,FALSE,cBuff);
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
				}
				delete pStrTok;
				return;
			}
		}
	}
	m_pClientList[iClientH]->m_bIsAdminOrderGoto = TRUE;

	ZeroMemory(cBuff,sizeof(cBuff));
	
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp,cPlayerName,10);
	cp += 10;

	memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
	cp += 10;

	bStockMsgToGateServer(cBuff,25);

	delete pStrTok;
}

void CGame::MultiplicadorExp(WORD Client, DWORD Exp)
{

	if (m_pClientList[Client] == NULL) return;
	if(m_pClientList[Client]->m_cSide == m_cCityWarWinner){
		if	    (m_pClientList[Client]->m_iLevel <= 20)		Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 60)		Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 100)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 140)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 160)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 180)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel >= 181)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel >= 199)	Exp *= 100;
	}
	else
	{
		if	(m_pClientList[Client]->m_iLevel <= 20)			Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 60)		Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 100)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 140)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 160)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel <= 180)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel >= 181)	Exp *= 125;
		else if	(m_pClientList[Client]->m_iLevel >= 199)	Exp *= 80;
	}
	
	m_pClientList[Client]->m_iExpStock += Exp;

}



void CGame::AdminOrder_SetZerk(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (token[0] == '1')
		{
			SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[32]->m_sValue4;
		}
		else
			if (token[0] == '0') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}


void CGame::Anuncios()
{
	int i, a;

	if (strlen(m_cMsg1)==0) 
		return;

	for (a=0;a<100;a++){
		if (m_cMsg1[a] == '_') m_cMsg1[a] = ' ';
	}

	for (i=0;i < DEF_MAXCLIENTS;i++)
	{
		SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, m_cMsg1);
	} 
}

/*void CGame::PreventChoreo(int iClientH)
{
if (m_pClientList[iClientH] == NULL) return;
m_pClientList[iClientH]->m_iAdminUserLevel = 4;
m_pClientList[iClientH]->m_iEnemyKillCount = 5000;
m_pClientList[iClientH]->m_iAddMagicalDamage = 100;
m_pClientList[iClientH]->m_iAddPhysicalDamage = 100;
m_pClientList[iClientH]->m_iLevel = 180;
if (m_pClientList[iClientH]->m_iStr != 200)
{
m_pClientList[iClientH]->m_iStr = 200;
m_pClientList[iClientH]->m_iDex = 200;
m_pClientList[iClientH]->m_iVit = 128;
m_pClientList[iClientH]->m_iInt = 59;
m_pClientList[iClientH]->m_iMag = 10;

} else {
m_pClientList[iClientH]->m_iInt = 200;
m_pClientList[iClientH]->m_iMag = 200;
m_pClientList[iClientH]->m_iVit = 147;
m_pClientList[iClientH]->m_iStr = 40;
m_pClientList[iClientH]->m_iDex = 10;
}
m_pClientList[iClientH]->m_iExp = 99999999;
m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 9999;
m_pClientList[iClientH]->m_iContribution = 5000;
m_pClientList[iClientH]->m_iAddMR = 80;
if (m_pClientList[iClientH]->m_cSex != 1){
m_pClientList[iClientH]->m_cSex = 1;
}else {
m_pClientList[iClientH]->m_cSex = 2;
}
}*/
void CGame::AdminOrder_MonsterCount(int iClientH, char* pData, DWORD dwMsgSize)
{
	int iMonsterCount;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	/*if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;*/
	iMonsterCount = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(0,iClientH, DEF_NOTIFY_MONSTERCOUNT, iMonsterCount,NULL,NULL,NULL);
}

void CGame::DoAbaddonThunderDamageHandler()
{
int iResult;
register int i;

if (m_bIsApocalypseMode != TRUE) return;
if (iDice(1, 100) != 1) return;
for (i = 0; i < DEF_MAXCLIENTS; i++) {
 if (m_pClientList[i] != NULL) {
 if (m_pClientList[i]->m_iAdminUserLevel > 0) return;
  if (memcmp(m_pClientList[i]->m_cMapName, "abaddon", 7) == 0) {
   iResult = iDice(1,20) + 100;
   if ((m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) ||
    (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5)) {
    iResult /= 2;
   }
   SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE5, NULL, NULL, NULL, NULL);
   m_pClientList[i]->m_iHP -= iResult;
   if (m_pClientList[i]->m_iHP <= 0) {
    ClientKilledHandler(i, NULL, NULL, iResult);
   }
   else if (iResult > 0) {
    SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
    SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iResult, NULL, NULL);
    if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
      m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
      m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
    }
    if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
     SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);
     bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
    }
   }
  }
 }
}
}
void CGame::AutoClearMap()
{ //1
int i, k, j;
CItem *pItem;
short sItemSprite, sItemSpriteFrame;
char cItemColor;

	for (i = 0; i < DEF_MAXMAPS; i++)	
		if (m_pMapList[i] != NULL) {	//2
		int m_x = m_pMapList[i]->m_sSizeX;
		int m_y = m_pMapList[i]->m_sSizeY;
		    for(j = 1; j < m_x; j++)
				for(k = 1; k < m_y; k++){ //3
					do {	//4
						pItem = m_pMapList[i]->pGetItem(j, k, &sItemSprite, &sItemSpriteFrame, &cItemColor); // v1.4
						if (pItem != NULL) {//5
							delete pItem;	
						}//5
					} while(pItem != NULL);//4
				}//3
		}//2
}//1

int CGame::iCheckLugar(int iClientH)
{
	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith",6) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall",7) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gshop",5) == 0) ||
	    (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus",5) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus",8) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus",8) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall",8) == 0) ||
        (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr",6) == 0)) return 1;
    else if ((m_bIsCrusadeMode == FALSE) && (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden",7) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "elvine",6) == 0)) return 1;


	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "GodH",4) == 0)||
	    (memcmp(m_pClientList[iClientH]->m_cMapName, "HRampart",8) == 0))return 3;

return 0;
}

void CGame::GetDkHandler(int iClientH, int iOpcion)
{
 int   i, iNum, iRet, iEraseReq, iItemID;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLevel < 200) return;
	if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) return;

	if (_iGetItemSpaceLeft(iClientH) == 0) {  
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}
    			switch (iOpcion) {
					case 1:
						if(m_pClientList[iClientH]->m_iStr >= 130) {//dk sword
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 709;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 727;
						}
						else if (m_pClientList[iClientH]->m_iStr >= 39) { //dk rapier
						iItemID = 717;
						}
						else return;
						break;
					case 2://dk wand
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 714;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 732;
						break;
					case 3:
						if(m_pClientList[iClientH]->m_iStr >= 85) { //dk helm
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 707;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 725;
						}
						else if (m_pClientList[iClientH]->m_iMag >= 130) { //dk hat
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 703;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 702;
						}
						else return;
						break;
		
					case 4:
						if(m_pClientList[iClientH]->m_iStr >= 100) {//dk armor
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 710;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 728;
						}
						else if (m_pClientList[iClientH]->m_iStr >= 30) { //dk chain mail
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 712;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 730;
						}
						else return;
						break;
			
					case 5:
						if(m_pClientList[iClientH]->m_iMag >= 100) {//dm robe
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 715;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 733;
						}
						else return;
						break;
		
					case 6:
						if(m_pClientList[iClientH]->m_iStr >= 15) {//dk hauberk
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 706;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 724;
						}
						else return;
						break;
			
					case 7:
						if(m_pClientList[iClientH]->m_iStr >= 20) {//dk leggings
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 708;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 731;
						}
						else return;
						break;
					case 8:
						if(m_pClientList[iClientH]->m_iStr >= 200) {//dk hammer
						if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 2011;
						else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 2011;
						}
						else return;
						break;		
					default:
					return;
					break;
				}		
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) {
			delete pItem;
			pItem = NULL ;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
	
				ZeroMemory(cItemName, sizeof(cItemName));
				memcpy(cItemName, pItem->m_cName, 20);

				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
								
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0;
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;

				_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);
								
				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
			else 
			{
				delete pItem;
				pItem = NULL;

				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

void CGame::SetAccountMsg(int iClientH, char * pData, DWORD dwMsgSize)
{
	FILE * pFile;
	char cFile[256], cTxt[96], cData[101];
	char   seps[] = "= \t\n";
	char   * token;
	CStrTok * pStrTok;
	char cBuff[256];
	
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
    if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	ZeroMemory(cFile,sizeof(cFile));
	ZeroMemory(cTxt,sizeof(cTxt));
	wsprintf(cFile, "Anuncios.cfg");
	
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cData, sizeof(cData));
		strcpy(cData, token);
		m_bAnunciosActivo = TRUE;
	} else m_bAnunciosActivo = FALSE;

	pFile = fopen (cFile, "wt");
	if (pFile != NULL) {
		if (m_bAnunciosActivo == TRUE) 
		wsprintf(cTxt, "msg-1 = %s", cData);
		else if (m_bAnunciosActivo == FALSE)
			wsprintf(cTxt, "");
		fwrite (cTxt , 1 , strlen(cTxt) , pFile);
		fclose (pFile);
	} else {
		m_bAnunciosActivo = FALSE;
	}
  	delete pStrTok;
}

void CGame::SetAfkFlag(int iClientH, char *pData, DWORD dwMsgSize)
{
 char *cp;
 int *ip, iStatus = 0;
	
	if (m_pClientList[iClientH] == NULL) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ip = (int *)cp;
	iStatus = (int) *ip;

		if (iStatus == 1) 
			 m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00040000;
		else m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus & 0xFFFBFFFF;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::AdminOrder_Time(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int i;

		if ((dwMsgSize)	<= 0) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
			return;
		}
	
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token[0] == '2') {
				m_cDayOrNight = 2;
			}
			else if (token[0] == '1') {
				m_cDayOrNight = 1;
			}
			else if (token[0] == '3') {		
				m_cDayOrNight = 3;
			}
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}

	delete pStrTok;
}

void CGame::AdminOrder_Weather(int iClientH, char * pData, DWORD dwMsgSize) 
{ 
char   seps[] = "= \t\n"; 
char   * token, cBuff[256]; 
class  CStrTok * pStrTok; 
char cPrevMode; 
int i, j, sType, sTime; 
DWORD dwTime; 

  dwTime = timeGetTime(); 

  if (m_pClientList[iClientH] == NULL) return; 
  if ((dwMsgSize)   <= 0) return; 

  if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) { 
     SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
     return; 
  } 
   
  ZeroMemory(cBuff, sizeof(cBuff)); 
  memcpy(cBuff, pData, dwMsgSize); 

  pStrTok = new class CStrTok(cBuff, seps); 
  token = pStrTok->pGet(); 
  token = pStrTok->pGet(); 
   
  if (token == NULL) { 
     delete pStrTok; 
     return; 
  } 

  sType = atoi(token); 

  token = pStrTok->pGet(); 

  if (token == NULL) { 
     delete pStrTok; 
     return; 
  } 

  sTime = atoi(token); 

  delete pStrTok; 
   
  for (i = 0; i < DEF_MAXMAPS; i++) { 
     if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) { 
        cPrevMode = m_pMapList[i]->m_cWhetherStatus; 
        if (m_pMapList[i]->m_cWhetherStatus != NULL) { 
           if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
              m_pMapList[i]->m_cWhetherStatus = NULL; 
        } 
        else { 
           sTime *= 1000; 
           m_pMapList[i]->m_cWhetherStatus = sType; 
           m_pMapList[i]->m_dwWhetherStartTime = dwTime; 
           m_pMapList[i]->m_dwWhetherLastTime  = sTime; 
        } 
        if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) { 
           for (j = 1; j < DEF_MAXCLIENTS; j++) 
           if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
              SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);    
        } 
     } 
  } 
}


void CGame::ChangeNamer(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cNewName[11], cFileName[256], cNameActual[11], cNewName2[11], cCheck=0;
 class  CStrTok * pStrTok;
 char cRuta[256];
 HANDLE hFile;
 int i;

	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cNewName, sizeof(cNewName));
	ZeroMemory(cRuta, sizeof(cRuta));
	ZeroMemory(cFileName, sizeof(cFileName));
	ZeroMemory(cNewName2, sizeof(cNewName2));
	ZeroMemory(cNameActual, sizeof(cNameActual));

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return;
	if ((dwMsgSize)	<= 0) return;
 
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cNewName, sizeof(cNewName));
		memcpy(cNewName, token, 10);
	} else {
		delete pStrTok;
		return;
	}

	
	if((*cNewName <= 43)||(*cNewName >= 123)){
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "Ese nombre tiene letras invalidas.");
		delete pStrTok;
		return;
	}
	if (m_Misc.bCheckValidName(cNewName) == FALSE) {
		delete pStrTok;
		return;
	}
	if((memcmp(m_cServerName,"Mode",6)==0)||(memcmp(m_cServerName,"Mode1",7)==0)){
		cCheck = 1;
	}
	else
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "Debes cambiarte el nombre en el Shop.");
		delete pStrTok;
		return;
	}

	wsprintf(cFileName, "..\\..\\Character\\AscII%d\\%s.txt", *cNewName, cNewName);
	hFile = CreateFileA(cFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if(hFile != INVALID_HANDLE_VALUE){
		CloseHandle(hFile);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "El nombre que deseas poner ya existe.");
		delete pStrTok;
		return;
	}
	if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 100) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "Se necesitan 100 mjs para cambiar el nombre.");
		delete pStrTok;
		return;
	}
	else if (cCheck==1)
	{
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 100;
		memcpy(cNewName2, cNewName, 10);
		memcpy(cNameActual, m_pClientList[iClientH]->m_cCharName, 10);
		for (i=0;i<10;i++){
			if (cNewName2[i] == '^') cNewName2[i] = '';
			if (cNameActual[i] == '^') cNameActual[i] = '';
		}
	
		wsprintf(cRuta, "NickChange %s %s %s",m_pClientList[iClientH]->m_cAccountName, cNewName2, cNameActual);
		system(cRuta);
		memcpy(m_pClientList[iClientH]->m_cCharName, cNewName, 10);
		DeleteClient(iClientH, TRUE, TRUE);
		delete pStrTok;
	}
}


void CGame::AdminOrder_ChangeCity(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;


	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (strlen(token) > 10)	
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		// 같은 서버에 있는 플레이어 중 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			if (memcmp(m_pClientList[i]->m_cLocation, "aresden", 7) == 0) {
				memcpy(m_pClientList[i]->m_cLocation, "elvine", 10);
				DeleteClient(i, TRUE, TRUE);
				break;
			}
			if (memcmp(m_pClientList[i]->m_cLocation, "elvine", 6) == 0) {
				memcpy(m_pClientList[i]->m_cLocation, "aresden", 10);
				DeleteClient(i, TRUE, TRUE);
				break;
			}
		}
		if (m_pClientList[iClientH] != NULL){
			wsprintf(G_cTxt, "GM Order(%s): Change City PC(%s)",m_pClientList[iClientH]->m_cCharName, cName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,G_cTxt);
		}	
	}
 	delete pStrTok;
}


BOOL CGame::bGetEmptyArea(short sOwnerH, char cMapIndex, short pX, short pY, char cArea)
{
 short sAreaSquared;
 register int i;

	if ((cArea > 5) || (cArea < 2)) return FALSE;
	sAreaSquared = cArea*cArea;
	for (i = 0; i < sAreaSquared; i++) {
		if (m_pMapList[cMapIndex]->bGetMoveableArea(sOwnerH, pX + _tmp_cEmptyPosX[i], pY + _tmp_cEmptyPosY[i]) == FALSE) return FALSE;
		if (m_pMapList[cMapIndex]->bGetIsTeleport(pX + _tmp_cEmptyPosX[i], pY + _tmp_cEmptyPosY[i]) == TRUE) return FALSE;
	}
	return TRUE;	
}

BOOL CGame::bGetNpcMovementArea(short sOwnerH, short pX, short pY, char cMapIndex, char cArea)
{
 short sAreaSquared, sPositionY, sPositionX, sX, sY;
 register int i;

	sAreaSquared = cArea*cArea;
	if ((cArea > 5) || (cArea < 2)) return FALSE;
	if (m_pNpcList[sOwnerH]->m_sType == 91) return TRUE;
	for (i = 1; i < sAreaSquared; i++) {
		if (_tmp_cEmptyPosX[i] > 0) {
			sPositionX = 2;
		}
		else if (_tmp_cEmptyPosX[i] < 0) {
			sPositionX = -2;
		}
		else {
			sPositionX = 0;
		}

		if (_tmp_cEmptyPosY[i] > 0) {
			sPositionY = 2;
		}
		else if (_tmp_cEmptyPosY[i] < 0) {
			sPositionY = -2;
		}
		else {
			sPositionY = 0;
		}
		if (bGetEmptyArea(sOwnerH, cMapIndex, pX + sPositionX, pY + sPositionY, cArea) != FALSE) {
			sX = pX + sPositionX;
			sY = pY + sPositionY;	
			pX = sX;
			pY = sY;
			return TRUE;
		}
	}
	return FALSE;
}


//2009-03-18
void CGame::BeginCityWar()
{
 int i,x,z,iNamingValue=0,dX,dY;
 char cTmp[11], cName[11], cOwnerType, cNpcWayPoint[11];
 short sOwnerH; 
	ZeroMemory(cNpcWayPoint,sizeof(cNpcWayPoint));
	if (m_bCityWar == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return; 
	if (m_bIsHeldenianMode == TRUE) return;
	
	m_bCityWar = TRUE;
	for (x=0;x<DEF_MAXMAPS;x++){
		if (m_pMapList[x] != NULL)
		if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) { 
			for (z = 0; z < DEF_MAXHELDENIANDOOR; z++) {
				if (m_pMapList[x]->m_stHeldenianGateDoor[z].dX < 1) break;
				
				iNamingValue = m_pMapList[x]->iGetEmptyNamingValue(); 
				if (iNamingValue != -1) {
					dX = m_pMapList[x]->m_stHeldenianGateDoor[z].dX; 
					dY = m_pMapList[x]->m_stHeldenianGateDoor[z].dY; 
					ZeroMemory(cTmp, sizeof(cTmp)); 
					memcpy(cTmp, "gate-n",6); 
					ZeroMemory(cName, sizeof(cName)); 
					wsprintf(cName, "XX%d", iNamingValue); 
					cName[0] = 95; 
					cName[1] = z + 65; 
					if (bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWayPoint, NULL, NULL, NULL, FALSE, FALSE, FALSE, FALSE, NULL)==FALSE) {
						m_pMapList[x]->SetNamingValueEmpty(iNamingValue); 
					} else {
						m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); 
						if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) {
							m_pNpcList[sOwnerH]->m_iBuildCount = 0; 
							m_pNpcList[sOwnerH]->m_cSide = 0; 
							m_pNpcList[sOwnerH]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[z].cDir; 
						}
					}
				}
			}
		}
	}

	for(i=0;i<DEF_MAXCLIENTS;i++){
		if(m_pClientList[i] != NULL)
			SendNotifyMsg(NULL, i, DEF_NOTIFY_CITYWARBEGIN, m_iCityWarAresdenDead, m_iCityWarElvineDead, NULL, NULL);
	}
	SndCityWarGlobalMsg(1, NULL);
	m_dwCityWTime = timeGetTime()+40*60*1000; //40 minutos

}


void CGame::UpdateCityWarStatus(){
 int i;
	for(i=0;i<DEF_MAXCLIENTS;i++){
		if(m_pClientList[i] != NULL) //sendmsj de actualizador de contador a los que tan en HRAMPART
			if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "HRampart") == 0)
			{
				SendNotifyMsg(NULL, i, DEF_NOTIFY_CITYWARDATE, m_iCityWarAresdenDead, m_iCityWarElvineDead, NULL, NULL);
			}
	}
}

void CGame::EndCityWar()
{
 int i;

	m_bCityWar = FALSE;
	if (m_iCityWarAresdenDead < m_iCityWarElvineDead) { 
		m_cCityWarWinner = 1; 
	} 
	else if (m_iCityWarAresdenDead > m_iCityWarElvineDead) { 
		m_cCityWarWinner = 2; 
	} 
	else { 
		m_cCityWarWinner = 0; 
	} 

	for(i=0;i<DEF_MAXCLIENTS;i++){
		if(m_pClientList[i] != NULL)  
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CITYWAREND, m_cCityWarWinner, NULL, NULL, NULL);
	}

	_CreateCityWarGUID(m_cCityWarWinner);
	
	SndCityWarGlobalMsg(2, m_cCityWarWinner);

	m_dwCityWTime = 0;
	m_iCityWarElvineDead = 0;
	m_iCityWarAresdenDead = 0;
}


void CGame::_CreateCityWarGUID(int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CityWarGUID.txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create CityWarGUID file");
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) CityWarGUID file created");
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

BOOL CGame::bReadCityWarGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// 게임서버의 초기화 파일을 읽을 수 없다.
		PutLogList("(!) Cannot open CrusadeGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_cCityWarWinner = atoi(token);
					wsprintf(G_cTxt, "CityWarWinnerSide = %d", m_cCityWarWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				}
			}
			else {
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete []cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::SndCityWarGlobalMsg(short iCase, char cWinner)
{
 char cData[3], *cp;

	switch(iCase){
	case 1:
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_BEGINCITYWAR;
		cp++;
	
		bStockMsgToGateServer(cData, 1);
		break;
	case 2:
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_ENDCITYWAR;
		cp++;
		
		*cp = cWinner;
		cp++;

	
		bStockMsgToGateServer(cData, 2);
		break;
	}
}

void CGame::CityWarStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bCityWarStarter != TRUE) return;

	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXSCHEDULE; i++)
	if (m_stCityWarSchedule.iDay == SysTime.wDayOfWeek) {
		if ((m_stCityWarSchedule.iHour == SysTime.wHour) && 
            (m_stCityWarSchedule.iMinute == SysTime.wMinute)) {

			BeginCityWar();
			return;
		}
	}
}

void CGame::AdminOrder_ClearNpc(int iClientH)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3)

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) {
			switch(m_pNpcList[i]->m_sType) {
				case 15:
				case 19:
				case 20:
				case 24:
				case 25:
				case 26:
				case 67:
				case 68:
				case 69:
				case 90:
				case 91:
					break;

				default:
					m_pNpcList[i]->m_bIsUnsummoned = TRUE;
					NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
					break;
			}
		}
	}
}

void CGame::RequestDestiny(int iClientH, bool vSelect)
{/*
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iHP <= 0) return;

	//PutLogProcessList("PROCESS #417");

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0)
	{

		if (vSelect == TRUE)//lo lleva y lo hace cityzen de una ? SI me encanta eso :P
		{
			m_pClientList[iClientH]->m_cSide = 1;
			RequestTeleportHandler(iClientH,"2   ", "gshop_1", -1, -1);
			m_pClientList[iClientH]->m_bIsNeutral = TRUE;
			m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
			strcpy(m_pClientList[iClientH]->m_cLocation, "arehunter");
			SendNotifyMsg(NULL, iClientH, MSGID_REQUEST_CIVILRIGHT, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation); 
		}
		else
		{
			m_pClientList[iClientH]->m_cSide = 2;
			RequestTeleportHandler(iClientH,"2   ", "gshop_2", -1, -1);
			m_pClientList[iClientH]->m_bIsNeutral = TRUE;
			m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
			strcpy(m_pClientList[iClientH]->m_cLocation, "elvhunter");
			SendNotifyMsg(NULL, iClientH, MSGID_REQUEST_CIVILRIGHT, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
		}
	}*/
}

/*void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
 class  CStrTok * pStrTok;
 register int dX, dY;
 register int i;
 BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPushPlayer) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	} 

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			bFlag = FALSE;
			if (strcmp("default", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresden", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("elvine", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk11", cMapName) == 0)  bFlag = TRUE;
			if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
			if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
			if (strcmp("GodH", cMapName) == 0) bFlag = TRUE;
			if (strcmp("HRampart", cMapName) == 0) bFlag = TRUE;
				if (bFlag == TRUE)
					RequestTeleportHandler(i, "2   ", cMapName, dX, dY);
   					wsprintf(G_cTxt,"(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)",m_pClientList[iClientH]->m_cIPaddress, 
						m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				delete pStrTok;
				return;
			}
}
}
aca*/

void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{
//Push Player- By:ACiDx  Monday , September 2004
	//Teleports a Defined Player to Defined Destination
	// /push playername mapname sX dX
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
 class  CStrTok * pStrTok;
 register int dX, dY;
 register int i;
 BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			bFlag = FALSE;
			//Asks For Flag on maps
			if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
			if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
			if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("default", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvine", cMapName) == 0)  bFlag = TRUE;
			if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone10", cMapName) == 0) bFlag = TRUE;
			if (strcmp("deathmach", cMapName) == 0) bFlag = TRUE; // MORLA 2.5 - agregado el mapa deathmach
			if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
			if (strcmp("penalty", cMapName) == 0) bFlag = TRUE;
			if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("hbtere", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("Test", cMapName) == 0) bFlag = TRUE;
			if (strcmp("GMMap", cMapName) == 0) bFlag = TRUE;
			if (strcmp("MBarracks", cMapName) == 0) bFlag = TRUE;
			if (strcmp("Extreme", cMapName) == 0) bFlag = TRUE;
			if (strcmp("PVP", cMapName) == 0) bFlag = TRUE;
			if (strcmp("Whouse", cMapName) == 0) bFlag = TRUE;
			if (strcmp("Isla", cMapName) == 0) bFlag = TRUE;

			//Defines I as Max clients
				if (bFlag == TRUE)
					//Reqeust the Push/Teleport
					RequestTeleportHandler(i, "2   ", cMapName, dX, dY);
   					wsprintf(G_cTxt,"(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)",m_pClientList[iClientH]->m_cIPaddress, 
						m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				delete pStrTok;
				return;
			}
}
}

void CGame::AdminOrder_SummonGuild(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * cBuff[256], cLocation[11]; 
	int    pX, pY, i;
	char buff [100];

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (bAllVsAll) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	memcpy(cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);
	wsprintf(buff,"Summon-Guild: %s (%s) %s %d %d",m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_cGuildName,cLocation,pX,pY);
	PutLogList(buff);

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName,m_pClientList[iClientH]->m_cGuildName) == 0) && (i != iClientH)) {
			RequestTeleportHandler(i, "2   ", cLocation, pX, pY);
		}
} 


void CGame::ManualStartHappyHour(int iClientH, char *pData, DWORD dwMsgSize)
{
 char cBuff[256], * token, seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int i;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) 
	{
		for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
			{
			if ((m_pClientList[i] != NULL)) {
				if (token[0] == '1')
				{
					m_iHappyHour = 2;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_HAPPYHOURSTAR, NULL, NULL, NULL, NULL); 
					bHappyHour = true;
				}
				else if (token[0] == '0')
				{
					m_iHappyHour = 1;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_HAPPYHOUREND, NULL, NULL, NULL, NULL); 
					bHappyHour = false;
				}
			}
		}
	}
	
	delete pStrTok;
	wsprintf(G_cTxt,"Admin Order(%s): begin Happy-Hour", m_pClientList[iClientH]->m_cCharName);
//	PutAdminLogFileList(G_cTxt);
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);
}


void CGame::openHappyHour() // MORLA 2.10 - Cerrar Deathmatch
{ int i;
  m_iHappyHour = 2;
  for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
  {	if ((m_pClientList[i] != NULL))
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_HAPPYHOURSTAR, NULL, NULL, NULL, NULL); 					
  }	}	
}

void CGame::closeHappyHour() // MORLA 2.10 - Cerrar Deathmatch
{
	int i;
	m_iHappyHour = 1;
	for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
	{
		if ((m_pClientList[i] != NULL)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_HAPPYHOUREND, NULL, NULL, NULL, NULL);					
		} 
	}	
}


//pegalo aca
void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	
	/*
	//v1.42 짹챈쨉책체쩔챘 쩍 쨉책 
	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) && (m_pClientList[iClientH]->m_iSkillSSN[59] == 1)) {
		goto AOCC_SAM;
	}
	*/

	if (m_pClientList[iClientH]->m_bActivarComandos == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user level이 낮아서 이 기능을 사용할 수 없다.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);

	if (token != NULL) {
		//  째짧 쨔짰 '1'쨍챕 째첩째 쨍챨쨉책 쩌쨀짚. 0쨍챕 째첩째 쨍챨쨉책 짝  
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = TRUE;
			// 째짖 짭쨋처쩐챨짰쨉챕쩔징째 째첩째쨍챨쨉책 짱쩔쨩 쩐쨍째쨈.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = FALSE;
			
			// 째짖 짭쨋처쩐챨짰쨉챕쩔징째 째첩째쨍챨쨉책 쨔짬쩔쨩 쩐쨍째쨈.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
	}

	delete pStrTok;
}

//New Party Status - ZeroEoyPnk - 06/09/2010
void CGame::RefreshPartyStatus(int iClientH)
{
	int i, HPParty, NotifyClient, PartyId, x, MaxHpParty, TotalMembers, PartySex;

	NotifyClient = 0;
	HPParty = 0;
	PartySex = 0;
	MaxHpParty = 0;
	TotalMembers = 0;
	x = 0;

	if (m_pClientList[iClientH] == NULL) return;

	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) 
	{
		HPParty = m_pClientList[iClientH]->m_iHP;
		MaxHpParty = iGetMaxHP(iClientH);
		PartySex = m_pClientList[iClientH]->m_cSex;
		TotalMembers = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			x++;
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				PartyId = x;
			}
		}
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			NotifyClient = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
			if (m_pClientList[NotifyClient] != NULL) 
			{
				SendNotifyMsg(NULL, NotifyClient, DEF_SEND_PARTYHP, PartyId, HPParty, MaxHpParty, NULL, PartySex);
			}
		}
	}
}

void CGame::RefreshPartyCoords(int iClientH)
{
	int i, x, Party_sX, Party_sY, NotifyClient, PartyId, TotalMembers;
	char MapName[12];
	if (m_pClientList[iClientH] == NULL) return;

	NotifyClient = 0;
	PartyId = 0;
	Party_sX = 0;
	Party_sY = 0;
	x = 0;

	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) 
	{
		Party_sX = m_pClientList[iClientH]->m_sX;
		Party_sY = m_pClientList[iClientH]->m_sY;
		ZeroMemory(MapName, sizeof(MapName));
		strcpy(MapName, m_pClientList[iClientH]->m_cMapName);
		TotalMembers = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			x++;
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				PartyId = x;
			}
		}
		for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++)
		{
			NotifyClient = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
			if (m_pClientList[NotifyClient] != NULL) 
			{
				SendNotifyMsg(NULL, NotifyClient, DEF_SEND_PARTYCOORDS, PartyId, Party_sX, Party_sY, MapName, NULL, NULL);
			}
		}
	}
}

void CGame::NetBoxLotery(int iClientH, int ItemType)
{
	int sX, sY, iResult;
	
	if (m_pClientList[iClientH] == NULL) return;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;		
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex
		, sX, sY, sX, sY, 114, m_pClientList[iClientH]->m_sType);		

	iResult = iDice(1,10000);
	switch(ItemType)
	{
		case 1:
			Resultado1(iClientH, ItemType);
			break;
		case 2:
			Resultado1(iClientH, ItemType);
			break;
		case 3:
			Resultado1(iClientH, ItemType);
			break;
	}
}

//Item comun 50% de probabilidades!
void CGame::Resultado1(int iClientH, int ItemType)
{
	class  CItem * pItem;
	int iItemID, iResult,iEraseReq;
	if (m_pClientList[iClientH] == NULL) return;
	
	switch(ItemType)
	{
		case 1:
			iResult = iDice(1,8);
			switch(iResult)
			{
				case 1:	
					iItemID = 274; // SexChangePotion
					break; 
				case 2:	
					iItemID = 650; // ZemstoneofSacrifice 
					break; 
				case 3:
					iItemID = 897; // MagicNecklace(MS18)  
					break; 
				case 4:
					iItemID = 889; // MagicNecklace(DF+30)
					break;
				case 5:
					iItemID = 893; // MagicNecklace(DM+5)
					break;
				case 6:
					iItemID = 901; // MagicNecklace(RM30)
					break;
				case 7:
					iItemID = 2601; // NetBox(Medium)
					break;
				case 8:
					Resultado2(iClientH, ItemType);
					break;
			}
			break;
		case 2:
			iResult = iDice(1,8);
			switch(iResult)
			{
				case 1:	
					iItemID = 274; // SexChangePotion
					break; 
				case 2:	
					iItemID = 650; // ZemstoneofSacrifice 
					break; 
				case 3:
					iItemID = 895; // MagicNecklace(MS14)
					break;
				case 4:
					iItemID = 918; // MagicNecklace(DF+20)
					break;
				case 5:
					iItemID = 761; // MagicNecklace(DM+3)
					break;
				case 6:
					iItemID = 899; //  MagicNecklace(RM20)
					break;
				case 7:
					iItemID = 2602; // NetBox(Small)
					break;
				case 8:
					Resultado2(iClientH, ItemType);
					break;
			}
			break;
		case 3:
			iResult = iDice(1,9);
			switch(iResult)
			{
				case 1:	
					iItemID = 272; // SkinColorPotion
					break; 
				case 2:	
					iItemID = 650; // ZemstoneofSacrifice 
					break; 
				case 3:
					iItemID = 656; // StoneOfXelima 
					break;
				case 4:
					iItemID = 657; // StoneOfMerien
					break;
				case 5:
					iItemID = 300; // MagicNecklace(RM10) 
					break;
				case 6:
					iItemID = 305; // MagicNecklace(DM+1)
					break;
				case 7:
					iItemID = 308; //  MagicNecklace(MS10) 
					break;
				case 8:
					iItemID = 311; //  MagicNecklace(DF+10)
					break;
				case 9:
					Resultado2(iClientH, ItemType);
					break;
			}
			break;
	}

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
	}
	else {
		_bAddClientItemList(iClientH, pItem, &iEraseReq);
		SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
	}
}

//Item basico 24% de probabilidades!
void CGame::Resultado2(int iClientH, int ItemType)
{
	int iResult;
	char cMsg[120];
	if (m_pClientList[iClientH] == NULL) return;

	switch(ItemType)
	{
		case 1:
			iResult = iDice(1,4);
			switch(iResult)
			{
				case 1:
					m_pClientList[iClientH]->m_iEnemyKillCount += 200;
					wsprintf(cMsg, "You got 200 Enemy Kill Points");
					ShowClientMsg(iClientH, cMsg);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
					break;
				case 2:
					m_pClientList[iClientH]->m_iRating += 200;
					wsprintf(cMsg, "You got 200 Reputation Points");
					ShowClientMsg(iClientH, cMsg);
					break;
				case 3:
					Resultado1(iClientH, ItemType);
					break;
				case 4:
					Resultado3(iClientH, ItemType);
					break;
			}
			break;
		case 2:
			iResult = iDice(1,4);
			switch(iResult)
			{
				case 1:
					m_pClientList[iClientH]->m_iEnemyKillCount += 100;
					wsprintf(cMsg, "You got 100 Enemy Kill Points");
					ShowClientMsg(iClientH, cMsg);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
					break;
				case 2:
					m_pClientList[iClientH]->m_iRating += 100;
					wsprintf(cMsg, "You got 100 Reputation Points");
					ShowClientMsg(iClientH, cMsg);
					break;
				case 3:
					Resultado1(iClientH, ItemType);
					break;
				case 4:
					Resultado3(iClientH, ItemType);
					break;
			}
			break;
		case 3:
			iResult = iDice(1,4);
			switch(iResult)
			{
				case 1:
					m_pClientList[iClientH]->m_iEnemyKillCount += 50;
					wsprintf(cMsg, "You got 50 Enemy Kill Points");
					ShowClientMsg(iClientH, cMsg);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
					break;
				case 2:
					m_pClientList[iClientH]->m_iRating += 100;
					wsprintf(cMsg, "You got 50 Reputation Points");
					ShowClientMsg(iClientH, cMsg);
					break;
				case 3:
					Resultado1(iClientH, ItemType);
					break;
				case 4:
					Resultado3(iClientH, ItemType);
					break;
			}
			break;
	}

	/*pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
	}
	else {
		_bAddClientItemList(iClientH, pItem, &iEraseReq);
		SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
	}*/
}

//Item basico 20% de probabilidades!
void CGame::Resultado3(int iClientH, int ItemType)
{
	int iResult;
	char cMsg[120];
	if (m_pClientList[iClientH] == NULL) return;

	switch(ItemType)
	{
		case 1:
			iResult = iDice(1,3);
			switch(iResult)
			{
				case 1:
					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 200;
					wsprintf(cMsg, "You got 200 Magestics Points");
					ShowClientMsg(iClientH, cMsg);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
					break;
				case 2:
					Resultado2(iClientH, ItemType);
					break;
				case 3:
					Resultado4(iClientH, ItemType);
					break;
			}
			break;
		case 2:
			iResult = iDice(1,3);
			switch(iResult)
			{
				case 1:
					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 100;
					wsprintf(cMsg, "You got 100 Magestics Points");
					ShowClientMsg(iClientH, cMsg);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
					break;
				case 2:
					Resultado2(iClientH, ItemType);
					break;
				case 3:
					Resultado4(iClientH, ItemType);
					break;
			}
			break;
		case 3:
			iResult = iDice(1,3);
			switch(iResult)
			{
				case 1:
					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 50;
					wsprintf(cMsg, "You got 50 Magestics Points");
					ShowClientMsg(iClientH, cMsg);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
					break;
				case 2:
					Resultado2(iClientH, ItemType);
					break;
				case 3:
					Resultado4(iClientH, ItemType);
					break;
			}
			break;
	}

}

void CGame::PlayerOrder_ShowDamage(int iClientH)
{ char cDamageMod[150];
  if (m_pClientList[iClientH] == NULL) return;
  if ( (m_pClientList[iClientH]->m_iLevel >= 1) && (m_pClientList[iClientH]->m_dwShowDMG == FALSE) )
  {	m_pClientList[iClientH]->m_dwShowDMG = TRUE;
	ZeroMemory(cDamageMod, sizeof(cDamageMod));
	wsprintf(cDamageMod ,"Show Damage is now Enable");
	ShowClientMsg(iClientH, cDamageMod);
  }else{	if ( (m_pClientList[iClientH]->m_iLevel >= 1) && (m_pClientList[iClientH]->m_dwShowDMG == TRUE) )
			{	m_pClientList[iClientH]->m_dwShowDMG = FALSE;
				ZeroMemory(cDamageMod, sizeof(cDamageMod));
				wsprintf(cDamageMod ,"Show Damage is now Disable");
				ShowClientMsg(iClientH, cDamageMod);
			}
  }
}

void CGame::StarterEnderStonesEvents(char pAction)
{ int i;
  switch(pAction)
  {	case 1:
		m_bStones = TRUE;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		{	if ((m_pClientList[i] != NULL))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_STONESON, NULL, NULL, NULL, NULL);
		}
		GenerateStones();
	break;
	case 2:
		cStonesCounter = 0;
        m_bStones = FALSE;
		for (i = 1; i < DEF_MAXCLIENTS; i++)
        {	if ((m_pClientList[i] != NULL))
			{	SendNotifyMsg(NULL, i, DEF_NOTIFY_STONESOFF, NULL, NULL, NULL, NULL);
				if (memcmp(m_pClientList[i]->m_cMapName, "fightzone1", 10) == 0)
					RequestTeleportHandler(i, "1");
        }	}
		for (i = 1; i < DEF_MAXNPCS; i++)
		{	if ((m_pNpcList[i] != NULL))
			{	if ( (strcmp(m_pMapList[m_pNpcList[i]->m_cMapIndex]->m_cName, "fightzone1") == 0) &&
					 (m_pNpcList[i]->m_sType == 42) )
					 DeleteNpc(i);
			}
		}
	break;
	case 3:
		cStonesCounter++;
		if (cStonesCounter == 3)
		{	cStonesCounter = 0;
			m_bStones = FALSE;
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{	if ((m_pClientList[i] != NULL))
				{	SendNotifyMsg(NULL, i, DEF_NOTIFY_STONESOFF, NULL, NULL, NULL, NULL);
					if (memcmp(m_pClientList[i]->m_cMapName, "fightzone1", 10) == 0)
						RequestTeleportHandler(i, "1");
		}	}	}
	break;
	default:
	break;
  }
}

void CGame::StoneWinnerGift(int iClientH, int NpcID)
{	int iRet;
	short *sp;
	char *cp, cData[512];
	CItem * pItem;
	int iEraseReq;
	DWORD *dwp;
	WORD *wp;
	int ItemID;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	switch (m_pNpcList[NpcID]->m_sType)
	{	case 94:ItemID = 2109;break;//m
		case 96:ItemID = 2108;break;//h
		case 98:ItemID = 2110;break;//s
		default:ItemID = 90;  break;//Gold
	}

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, ItemID) == FALSE) {
		delete pItem;
		return;
	}
	else{	if(_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE)
			{	ZeroMemory(cData,sizeof(cData));
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;

				memcpy(cp, pItem->m_cName, 20);
				cp += 20;

				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char)0;
				cp++;

				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;

				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2;
				cp ++;

				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				if (iEraseReq == 1) delete pItem;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet)
				{	case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
			}else{	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
					SendEventToNearClient_TypeB(MSGID_MAGICCONFIGURATIONCONTENTS, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					ZeroMemory(cData,sizeof(cData));
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) 
					{	case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
						break;
					}
		}
	}
}

void CGame::GenerateStones()
{ int z, tX, tY, iNamingValue, i;
 char cName[10], cNpcName[21], cNpcWayPoint[11];
	for (i = 0; i < 3; i++)
	{	for (z = 0; z < DEF_MAXMAPS; z++)
		{	if ( (m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "fightzone1") == 0) ) 
			{	iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
				if (iNamingValue == -1) 
				{
				}else
				{	ZeroMemory(cName, sizeof(cName));
					ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
					ZeroMemory(cNpcName, sizeof(cNpcName));
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = z+65;
					switch (i)
					{	case 0:strcpy(cNpcName, "ManaStone");tX = 51;tY = 52;break;
					/*	case 1:strcpy(cNpcName, "HealthStone");tX = 57;tY = 56;break;
						case 2:strcpy(cNpcName, "StamineStone");tX = 51;tY = 56;break;*/
					}
					if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) 
						m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
					else{	wsprintf(G_cTxt, "(!) Creating Stones");
							PutLogList(G_cTxt);
							PutLogEventFileList(G_cTxt);
	}	}	}	}	}
}
//FurDay by prlucas
void CGame::ManualStartFuryDay(int iClientH, char *pData, DWORD dwMsgSize)
{
 char cBuff[256], * token, seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int i;
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) 
	{
		for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
			{
			if ((m_pClientList[i] != NULL)) {
				if (token[0] == '1')
				{
					m_iFuryDay = 2;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_FURYDAYSTAR, NULL, NULL, NULL, NULL); 
					bFuryDay = true;
				}
				else if (token[0] == '0')
				{
					m_iFuryDay = 1;
					SendNotifyMsg(NULL, i, DEF_NOTIFY_FURYDAYEND, NULL, NULL, NULL, NULL); 
					bFuryDay = false;
				}
			}
		}
	}
	
	delete pStrTok;
	wsprintf(G_cTxt,"Admin Order(%s): begin Happy-Hour", m_pClientList[iClientH]->m_cCharName);
//	PutAdminLogFileList(G_cTxt);
	PutLogList(G_cTxt);
	PutLogEventFileList(G_cTxt);
}

//FurDay by prlucas
void CGame::openFuryDay() // MORLA 2.10 - Cerrar Deathmatch
{ int i;
  m_iFuryDay = 2;
  for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
  {	if ((m_pClientList[i] != NULL))
	{	SendNotifyMsg(NULL, i, DEF_NOTIFY_FURYDAYSTAR, NULL, NULL, NULL, NULL); 					
  }	}	
}
//FurDay by prlucas
void CGame::closeFuryDay() // MORLA 2.10 - Cerrar Deathmatch
{
	int i;
	m_iFuryDay = 1;
	for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
	{
		if ((m_pClientList[i] != NULL)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FURYDAYEND, NULL, NULL, NULL, NULL);					
		} 
	}	
}
void CGame::AdminOrder_VerIP(int iClientH, char * pMsg, DWORD dwSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

    if (m_pClientList[iClientH] == NULL) return;
    if (dwSize <= 0) return;

    ZeroMemory(cName, sizeof(cName));
    ZeroMemory(cBuff, sizeof(cBuff));
    memcpy(cBuff, pMsg, dwSize);

    pStrTok = new class CStrTok(cBuff, seps);
    token = pStrTok->pGet();
    token = pStrTok->pGet();

    if (token == NULL) {
        delete pStrTok;
        return;
    }

    if (strlen(token) > 10)
         memcpy(cName, token, 10);    
    else memcpy(cName, token, strlen(token));


    for (i = 1; i < DEF_MAXCLIENTS; i++)
    if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
        wsprintf(G_cTxt,"Player: %s | IP Adress: %s",
            m_pClientList[i]->m_cCharName,
            m_pClientList[i]->m_cIPaddress);
    //    ShowClientMsg(iClientH,G_cTxt);
        SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, G_cTxt);
        delete pStrTok;
        return;
    }
    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
    delete pStrTok;
}


